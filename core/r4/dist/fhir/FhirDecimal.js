// Minimum TypeScript Version: 3.7
// FHIR Primitive: decimal
import * as fhir from '../fhir.js';
/**
 * Do not use an IEEE type floating point type, instead use something that works like a true decimal, with inbuilt precision (e.g. Java BigInteger)
 */
export class FhirDecimal extends fhir.FhirPrimitive {
    /**
       * Create a FhirDecimal
       * @param value Do not use an IEEE type floating point type, instead use something that works like a true decimal, with inbuilt precision (e.g. Java BigInteger)
       * @param id Unique id for inter-element referencing (uncommon on primitives)
       * @param extension Additional content defined by implementations
       * @param options Options to pass to extension constructors
    */
    constructor(source = {}, options = {}) {
        super(source, options);
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        let issues = super.doModelValidation();
        if ((this.value) && (!FhirDecimal._fts_regex.test(this.value.toString()))) {
            issues.push({ severity: 'error', code: 'invalid', diagnostics: 'Invalid value in primitive type decimal', });
        }
        return issues;
    }
}
/**
 * Mapping of this datatype to a FHIR equivalent
 */
FhirDecimal._fts_dataType = 'Decimal';
/**
 * Mapping of this datatype to a JSON equivalent
 */
FhirDecimal._fts_jsonType = 'number';
// published regex: -?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?
FhirDecimal._fts_regex = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$/;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmhpckRlY2ltYWwuanMiLCJzb3VyY2VSb290IjoiLi9zcmMvIiwic291cmNlcyI6WyJmaGlyL0ZoaXJEZWNpbWFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUNsQywwQkFBMEI7QUFFMUIsT0FBTyxLQUFLLElBQUksTUFBTSxZQUFZLENBQUM7QUFZbkM7O0dBRUc7QUFDSCxNQUFNLE9BQU8sV0FBWSxTQUFRLElBQUksQ0FBQyxhQUFhO0lBZWpEOzs7Ozs7TUFNRTtJQUNGLFlBQVksU0FBa0MsRUFBRSxFQUFFLFVBQXNDLEVBQUc7UUFDekYsS0FBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBQ0Q7O09BRUc7SUFDYSxpQkFBaUI7UUFDL0IsSUFBSSxNQUFNLEdBQW1CLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFO1lBQ3pFLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUcsV0FBVyxFQUFFLHlDQUF5QyxHQUFHLENBQUMsQ0FBQztTQUMvRztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0FBakNEOztHQUVHO0FBQzZCLHlCQUFhLEdBQVUsU0FBUyxDQUFDO0FBQ2pFOztHQUVHO0FBQzZCLHlCQUFhLEdBQVUsUUFBUSxDQUFDO0FBQ2hFLGtFQUFrRTtBQUNsQyxzQkFBVSxHQUFVLGtEQUFrRCxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTWluaW11bSBUeXBlU2NyaXB0IFZlcnNpb246IDMuN1xyXG4vLyBGSElSIFByaW1pdGl2ZTogZGVjaW1hbFxyXG5cclxuaW1wb3J0ICogYXMgZmhpciBmcm9tICcuLi9maGlyLmpzJztcclxuXHJcbi8qKlxyXG4gKiBEbyBub3QgdXNlIGFuIElFRUUgdHlwZSBmbG9hdGluZyBwb2ludCB0eXBlLCBpbnN0ZWFkIHVzZSBzb21ldGhpbmcgdGhhdCB3b3JrcyBsaWtlIGEgdHJ1ZSBkZWNpbWFsLCB3aXRoIGluYnVpbHQgcHJlY2lzaW9uIChlLmcuIEphdmEgQmlnSW50ZWdlcilcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmhpckRlY2ltYWxBcmdzIGV4dGVuZHMgZmhpci5GaGlyUHJpbWl0aXZlQXJncyB7XHJcbiAgLyoqXHJcbiAgICogRG8gbm90IHVzZSBhbiBJRUVFIHR5cGUgZmxvYXRpbmcgcG9pbnQgdHlwZSwgaW5zdGVhZCB1c2Ugc29tZXRoaW5nIHRoYXQgd29ya3MgbGlrZSBhIHRydWUgZGVjaW1hbCwgd2l0aCBpbmJ1aWx0IHByZWNpc2lvbiAoZS5nLiBKYXZhIEJpZ0ludGVnZXIpXHJcbiAgICovXHJcbiAgdmFsdWU/OkZoaXJEZWNpbWFsfG51bWJlcnx1bmRlZmluZWR8bnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvIG5vdCB1c2UgYW4gSUVFRSB0eXBlIGZsb2F0aW5nIHBvaW50IHR5cGUsIGluc3RlYWQgdXNlIHNvbWV0aGluZyB0aGF0IHdvcmtzIGxpa2UgYSB0cnVlIGRlY2ltYWwsIHdpdGggaW5idWlsdCBwcmVjaXNpb24gKGUuZy4gSmF2YSBCaWdJbnRlZ2VyKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZoaXJEZWNpbWFsIGV4dGVuZHMgZmhpci5GaGlyUHJpbWl0aXZlIHtcclxuICAvKipcclxuICAgKiBNYXBwaW5nIG9mIHRoaXMgZGF0YXR5cGUgdG8gYSBGSElSIGVxdWl2YWxlbnRcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIHJlYWRvbmx5IF9mdHNfZGF0YVR5cGU6c3RyaW5nID0gJ0RlY2ltYWwnO1xyXG4gIC8qKlxyXG4gICAqIE1hcHBpbmcgb2YgdGhpcyBkYXRhdHlwZSB0byBhIEpTT04gZXF1aXZhbGVudFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgcmVhZG9ubHkgX2Z0c19qc29uVHlwZTpzdHJpbmcgPSAnbnVtYmVyJztcclxuICAvLyBwdWJsaXNoZWQgcmVnZXg6IC0/KDB8WzEtOV1bMC05XSopKFxcLlswLTldKyk/KFtlRV1bKy1dP1swLTldKyk/XHJcbiAgcHVibGljIHN0YXRpYyBvdmVycmlkZSByZWFkb25seSBfZnRzX3JlZ2V4OlJlZ0V4cCA9IC9eLT8oMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8oW2VFXVsrLV0/WzAtOV0rKT8kL1xyXG4gIC8qKlxyXG4gICAqIEEgZGVjaW1hbCB2YWx1ZSwgcmVwcmVzZW50ZWQgYXMgYSBKUyBudW1iZXJcclxuICAgKi9cclxuICBkZWNsYXJlIHZhbHVlPzpudW1iZXJ8bnVsbHx1bmRlZmluZWQ7XHJcbiAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBGaGlyRGVjaW1hbFxyXG4gICAgICogQHBhcmFtIHZhbHVlIERvIG5vdCB1c2UgYW4gSUVFRSB0eXBlIGZsb2F0aW5nIHBvaW50IHR5cGUsIGluc3RlYWQgdXNlIHNvbWV0aGluZyB0aGF0IHdvcmtzIGxpa2UgYSB0cnVlIGRlY2ltYWwsIHdpdGggaW5idWlsdCBwcmVjaXNpb24gKGUuZy4gSmF2YSBCaWdJbnRlZ2VyKVxyXG4gICAgICogQHBhcmFtIGlkIFVuaXF1ZSBpZCBmb3IgaW50ZXItZWxlbWVudCByZWZlcmVuY2luZyAodW5jb21tb24gb24gcHJpbWl0aXZlcylcclxuICAgICAqIEBwYXJhbSBleHRlbnNpb24gQWRkaXRpb25hbCBjb250ZW50IGRlZmluZWQgYnkgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gZXh0ZW5zaW9uIGNvbnN0cnVjdG9yc1xyXG4gICovXHJcbiAgY29uc3RydWN0b3Ioc291cmNlOlBhcnRpYWw8RmhpckRlY2ltYWxBcmdzPiA9IHt9LCBvcHRpb25zOmZoaXIuRmhpckNvbnN0cnVjdG9yT3B0aW9ucyA9IHsgfSApIHtcclxuICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRvIHBlcmZvcm0gYmFzaWMgbW9kZWwgdmFsaWRhdGlvbiAoZS5nLiwgY2hlY2sgaWYgcmVxdWlyZWQgZWxlbWVudHMgYXJlIHByZXNlbnQpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBkb01vZGVsVmFsaWRhdGlvbigpOmZoaXIuRnRzSXNzdWVbXSB7XHJcbiAgICBsZXQgaXNzdWVzOmZoaXIuRnRzSXNzdWVbXSA9IHN1cGVyLmRvTW9kZWxWYWxpZGF0aW9uKCk7XHJcbiAgICBpZiAoKHRoaXMudmFsdWUpICYmICghRmhpckRlY2ltYWwuX2Z0c19yZWdleC50ZXN0KHRoaXMudmFsdWUudG9TdHJpbmcoKSkpKSB7XHJcbiAgICAgIGlzc3Vlcy5wdXNoKHsgc2V2ZXJpdHk6ICdlcnJvcicsIGNvZGU6ICdpbnZhbGlkJywgIGRpYWdub3N0aWNzOiAnSW52YWxpZCB2YWx1ZSBpbiBwcmltaXRpdmUgdHlwZSBkZWNpbWFsJywgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNzdWVzO1xyXG4gIH1cclxufVxyXG4iXX0=