/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { OrientationTypeCodings } from '../fhirValueSets/OrientationTypeCodings.js';
import { StrandTypeCodings } from '../fhirValueSets/StrandTypeCodings.js';
import { QualityTypeCodings } from '../fhirValueSets/QualityTypeCodings.js';
import { RepositoryTypeCodings } from '../fhirValueSets/RepositoryTypeCodings.js';
import { SequenceTypeCodings } from '../fhirValueSets/SequenceTypeCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { BackboneElement } from './BackboneElement.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { DomainResource } from './DomainResource.js';
import { CodeableConcept } from './CodeableConcept.js';
import { FhirString } from './FhirString.js';
import { Reference } from './Reference.js';
import { FhirInteger } from './FhirInteger.js';
import { FhirDecimal } from './FhirDecimal.js';
import { Quantity } from './Quantity.js';
import { FhirUri } from './FhirUri.js';
import { FhirBoolean } from './FhirBoolean.js';
import { Identifier } from './Identifier.js';

// <auto-generated/>
/**
 * A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
 */
var MolecularSequenceReferenceSeq = /** @class */ (function (_super) {
    __extends(MolecularSequenceReferenceSeq, _super);
    /**
     * Default constructor for MolecularSequenceReferenceSeq - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceReferenceSeq(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['chromosome']) {
            _this.chromosome = new CodeableConcept(source.chromosome);
        }
        if (source['genomeBuild']) {
            _this.genomeBuild = new FhirString({ value: source.genomeBuild });
        }
        if (source['orientation']) {
            _this.orientation = source.orientation;
        }
        if (source['referenceSeqId']) {
            _this.referenceSeqId = new CodeableConcept(source.referenceSeqId);
        }
        if (source['referenceSeqPointer']) {
            _this.referenceSeqPointer = new Reference(source.referenceSeqPointer);
        }
        if (source['referenceSeqString']) {
            _this.referenceSeqString = new FhirString({ value: source.referenceSeqString });
        }
        if (source['strand']) {
            _this.strand = source.strand;
        }
        if (source['windowStart']) {
            _this.windowStart = new FhirInteger({ value: source.windowStart });
        }
        if (source['windowEnd']) {
            _this.windowEnd = new FhirInteger({ value: source.windowEnd });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for orientation (MolecularSequence.referenceSeq.orientation)
     */
    MolecularSequenceReferenceSeq.orientationRequiredCoding = function () {
        return OrientationTypeCodings;
    };
    /**
     * Required-bound Value Set for strand (MolecularSequence.referenceSeq.strand)
     */
    MolecularSequenceReferenceSeq.strandRequiredCoding = function () {
        return StrandTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceReferenceSeq.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["chromosome"]) {
            (_a = outcome.issue).push.apply(_a, this.chromosome.doModelValidation().issue);
        }
        if (this["genomeBuild"]) {
            (_b = outcome.issue).push.apply(_b, this.genomeBuild.doModelValidation().issue);
        }
        if (this["referenceSeqId"]) {
            (_c = outcome.issue).push.apply(_c, this.referenceSeqId.doModelValidation().issue);
        }
        if (this["referenceSeqPointer"]) {
            (_d = outcome.issue).push.apply(_d, this.referenceSeqPointer.doModelValidation().issue);
        }
        if (this["referenceSeqString"]) {
            (_e = outcome.issue).push.apply(_e, this.referenceSeqString.doModelValidation().issue);
        }
        if (this["windowStart"]) {
            (_f = outcome.issue).push.apply(_f, this.windowStart.doModelValidation().issue);
        }
        if (this["windowEnd"]) {
            (_g = outcome.issue).push.apply(_g, this.windowEnd.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceReferenceSeq._fts_dataType = 'MolecularSequenceReferenceSeq';
    return MolecularSequenceReferenceSeq;
}(BackboneElement));
/**
 * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
 */
var MolecularSequenceVariant = /** @class */ (function (_super) {
    __extends(MolecularSequenceVariant, _super);
    /**
     * Default constructor for MolecularSequenceVariant - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceVariant(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['start']) {
            _this.start = new FhirInteger({ value: source.start });
        }
        if (source['end']) {
            _this.end = new FhirInteger({ value: source.end });
        }
        if (source['observedAllele']) {
            _this.observedAllele = new FhirString({ value: source.observedAllele });
        }
        if (source['referenceAllele']) {
            _this.referenceAllele = new FhirString({ value: source.referenceAllele });
        }
        if (source['cigar']) {
            _this.cigar = new FhirString({ value: source.cigar });
        }
        if (source['variantPointer']) {
            _this.variantPointer = new Reference(source.variantPointer);
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceVariant.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["start"]) {
            (_a = outcome.issue).push.apply(_a, this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            (_b = outcome.issue).push.apply(_b, this.end.doModelValidation().issue);
        }
        if (this["observedAllele"]) {
            (_c = outcome.issue).push.apply(_c, this.observedAllele.doModelValidation().issue);
        }
        if (this["referenceAllele"]) {
            (_d = outcome.issue).push.apply(_d, this.referenceAllele.doModelValidation().issue);
        }
        if (this["cigar"]) {
            (_e = outcome.issue).push.apply(_e, this.cigar.doModelValidation().issue);
        }
        if (this["variantPointer"]) {
            (_f = outcome.issue).push.apply(_f, this.variantPointer.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceVariant._fts_dataType = 'MolecularSequenceVariant';
    return MolecularSequenceVariant;
}(BackboneElement));
/**
 * Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
 */
var MolecularSequenceQualityRoc = /** @class */ (function (_super) {
    __extends(MolecularSequenceQualityRoc, _super);
    /**
     * Default constructor for MolecularSequenceQualityRoc - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceQualityRoc(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['score']) {
            _this.score = source.score.map(function (x) { return new FhirInteger({ value: x }); });
        }
        else {
            _this.score = [];
        }
        if (source['numTP']) {
            _this.numTP = source.numTP.map(function (x) { return new FhirInteger({ value: x }); });
        }
        else {
            _this.numTP = [];
        }
        if (source['numFP']) {
            _this.numFP = source.numFP.map(function (x) { return new FhirInteger({ value: x }); });
        }
        else {
            _this.numFP = [];
        }
        if (source['numFN']) {
            _this.numFN = source.numFN.map(function (x) { return new FhirInteger({ value: x }); });
        }
        else {
            _this.numFN = [];
        }
        if (source['precision']) {
            _this.precision = source.precision.map(function (x) { return new FhirDecimal({ value: x }); });
        }
        else {
            _this.precision = [];
        }
        if (source['sensitivity']) {
            _this.sensitivity = source.sensitivity.map(function (x) { return new FhirDecimal({ value: x }); });
        }
        else {
            _this.sensitivity = [];
        }
        if (source['fMeasure']) {
            _this.fMeasure = source.fMeasure.map(function (x) { return new FhirDecimal({ value: x }); });
        }
        else {
            _this.fMeasure = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceQualityRoc.prototype.doModelValidation = function () {
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["score"]) {
            this.score.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["numTP"]) {
            this.numTP.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["numFP"]) {
            this.numFP.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["numFN"]) {
            this.numFN.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["precision"]) {
            this.precision.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["sensitivity"]) {
            this.sensitivity.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["fMeasure"]) {
            this.fMeasure.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceQualityRoc._fts_dataType = 'MolecularSequenceQualityRoc';
    return MolecularSequenceQualityRoc;
}(BackboneElement));
/**
 * An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
 */
var MolecularSequenceQuality = /** @class */ (function (_super) {
    __extends(MolecularSequenceQuality, _super);
    /**
     * Default constructor for MolecularSequenceQuality - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceQuality(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = source.type;
        }
        else {
            _this.type = null;
        }
        if (source['standardSequence']) {
            _this.standardSequence = new CodeableConcept(source.standardSequence);
        }
        if (source['start']) {
            _this.start = new FhirInteger({ value: source.start });
        }
        if (source['end']) {
            _this.end = new FhirInteger({ value: source.end });
        }
        if (source['score']) {
            _this.score = new Quantity(source.score);
        }
        if (source['method']) {
            _this.method = new CodeableConcept(source.method);
        }
        if (source['truthTP']) {
            _this.truthTP = new FhirDecimal({ value: source.truthTP });
        }
        if (source['queryTP']) {
            _this.queryTP = new FhirDecimal({ value: source.queryTP });
        }
        if (source['truthFN']) {
            _this.truthFN = new FhirDecimal({ value: source.truthFN });
        }
        if (source['queryFP']) {
            _this.queryFP = new FhirDecimal({ value: source.queryFP });
        }
        if (source['gtFP']) {
            _this.gtFP = new FhirDecimal({ value: source.gtFP });
        }
        if (source['precision']) {
            _this.precision = new FhirDecimal({ value: source.precision });
        }
        if (source['recall']) {
            _this.recall = new FhirDecimal({ value: source.recall });
        }
        if (source['fScore']) {
            _this.fScore = new FhirDecimal({ value: source.fScore });
        }
        if (source['roc']) {
            _this.roc = new MolecularSequenceQualityRoc(source.roc);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (MolecularSequence.quality.type)
     */
    MolecularSequenceQuality.typeRequiredCoding = function () {
        return QualityTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceQuality.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:QualityTypeCodeType fhir: MolecularSequence.quality.type:code', }));
        }
        if (this["standardSequence"]) {
            (_a = outcome.issue).push.apply(_a, this.standardSequence.doModelValidation().issue);
        }
        if (this["start"]) {
            (_b = outcome.issue).push.apply(_b, this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            (_c = outcome.issue).push.apply(_c, this.end.doModelValidation().issue);
        }
        if (this["score"]) {
            (_d = outcome.issue).push.apply(_d, this.score.doModelValidation().issue);
        }
        if (this["method"]) {
            (_e = outcome.issue).push.apply(_e, this.method.doModelValidation().issue);
        }
        if (this["truthTP"]) {
            (_f = outcome.issue).push.apply(_f, this.truthTP.doModelValidation().issue);
        }
        if (this["queryTP"]) {
            (_g = outcome.issue).push.apply(_g, this.queryTP.doModelValidation().issue);
        }
        if (this["truthFN"]) {
            (_h = outcome.issue).push.apply(_h, this.truthFN.doModelValidation().issue);
        }
        if (this["queryFP"]) {
            (_j = outcome.issue).push.apply(_j, this.queryFP.doModelValidation().issue);
        }
        if (this["gtFP"]) {
            (_k = outcome.issue).push.apply(_k, this.gtFP.doModelValidation().issue);
        }
        if (this["precision"]) {
            (_l = outcome.issue).push.apply(_l, this.precision.doModelValidation().issue);
        }
        if (this["recall"]) {
            (_m = outcome.issue).push.apply(_m, this.recall.doModelValidation().issue);
        }
        if (this["fScore"]) {
            (_o = outcome.issue).push.apply(_o, this.fScore.doModelValidation().issue);
        }
        if (this["roc"]) {
            (_p = outcome.issue).push.apply(_p, this.roc.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceQuality._fts_dataType = 'MolecularSequenceQuality';
    return MolecularSequenceQuality;
}(BackboneElement));
/**
 * Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
 */
var MolecularSequenceRepository = /** @class */ (function (_super) {
    __extends(MolecularSequenceRepository, _super);
    /**
     * Default constructor for MolecularSequenceRepository - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceRepository(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = source.type;
        }
        else {
            _this.type = null;
        }
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        if (source['datasetId']) {
            _this.datasetId = new FhirString({ value: source.datasetId });
        }
        if (source['variantsetId']) {
            _this.variantsetId = new FhirString({ value: source.variantsetId });
        }
        if (source['readsetId']) {
            _this.readsetId = new FhirString({ value: source.readsetId });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (MolecularSequence.repository.type)
     */
    MolecularSequenceRepository.typeRequiredCoding = function () {
        return RepositoryTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceRepository.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:RepositoryTypeCodeType fhir: MolecularSequence.repository.type:code', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (this["name"]) {
            (_b = outcome.issue).push.apply(_b, this.name.doModelValidation().issue);
        }
        if (this["datasetId"]) {
            (_c = outcome.issue).push.apply(_c, this.datasetId.doModelValidation().issue);
        }
        if (this["variantsetId"]) {
            (_d = outcome.issue).push.apply(_d, this.variantsetId.doModelValidation().issue);
        }
        if (this["readsetId"]) {
            (_e = outcome.issue).push.apply(_e, this.readsetId.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceRepository._fts_dataType = 'MolecularSequenceRepository';
    return MolecularSequenceRepository;
}(BackboneElement));
/**
 * Structural variant outer.
 */
var MolecularSequenceStructureVariantOuter = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariantOuter, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariantOuter - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceStructureVariantOuter(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['start']) {
            _this.start = new FhirInteger({ value: source.start });
        }
        if (source['end']) {
            _this.end = new FhirInteger({ value: source.end });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceStructureVariantOuter.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["start"]) {
            (_a = outcome.issue).push.apply(_a, this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            (_b = outcome.issue).push.apply(_b, this.end.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceStructureVariantOuter._fts_dataType = 'MolecularSequenceStructureVariantOuter';
    return MolecularSequenceStructureVariantOuter;
}(BackboneElement));
/**
 * Structural variant inner.
 */
var MolecularSequenceStructureVariantInner = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariantInner, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariantInner - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceStructureVariantInner(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['start']) {
            _this.start = new FhirInteger({ value: source.start });
        }
        if (source['end']) {
            _this.end = new FhirInteger({ value: source.end });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceStructureVariantInner.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["start"]) {
            (_a = outcome.issue).push.apply(_a, this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            (_b = outcome.issue).push.apply(_b, this.end.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceStructureVariantInner._fts_dataType = 'MolecularSequenceStructureVariantInner';
    return MolecularSequenceStructureVariantInner;
}(BackboneElement));
/**
 * Information about chromosome structure variation.
 */
var MolecularSequenceStructureVariant = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariant, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariant - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequenceStructureVariant(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['variantType']) {
            _this.variantType = new CodeableConcept(source.variantType);
        }
        if (source['exact']) {
            _this.exact = new FhirBoolean({ value: source.exact });
        }
        if (source['length']) {
            _this.length = new FhirInteger({ value: source.length });
        }
        if (source['outer']) {
            _this.outer = new MolecularSequenceStructureVariantOuter(source.outer);
        }
        if (source['inner']) {
            _this.inner = new MolecularSequenceStructureVariantInner(source.inner);
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequenceStructureVariant.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["variantType"]) {
            (_a = outcome.issue).push.apply(_a, this.variantType.doModelValidation().issue);
        }
        if (this["exact"]) {
            (_b = outcome.issue).push.apply(_b, this.exact.doModelValidation().issue);
        }
        if (this["length"]) {
            (_c = outcome.issue).push.apply(_c, this.length.doModelValidation().issue);
        }
        if (this["outer"]) {
            (_d = outcome.issue).push.apply(_d, this.outer.doModelValidation().issue);
        }
        if (this["inner"]) {
            (_e = outcome.issue).push.apply(_e, this.inner.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequenceStructureVariant._fts_dataType = 'MolecularSequenceStructureVariant';
    return MolecularSequenceStructureVariant;
}(BackboneElement));
/**
 * Raw data describing a biological sequence.
 */
var MolecularSequence = /** @class */ (function (_super) {
    __extends(MolecularSequence, _super);
    /**
     * Default constructor for MolecularSequence - initializes any required elements to null if a value is not provided.
     */
    function MolecularSequence(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'MolecularSequence';
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['type']) {
            _this.type = source.type;
        }
        if (source['coordinateSystem']) {
            _this.coordinateSystem = new FhirInteger({ value: source.coordinateSystem });
        }
        else {
            _this.coordinateSystem = null;
        }
        if (source['patient']) {
            _this.patient = new Reference(source.patient);
        }
        if (source['specimen']) {
            _this.specimen = new Reference(source.specimen);
        }
        if (source['device']) {
            _this.device = new Reference(source.device);
        }
        if (source['performer']) {
            _this.performer = new Reference(source.performer);
        }
        if (source['quantity']) {
            _this.quantity = new Quantity(source.quantity);
        }
        if (source['referenceSeq']) {
            _this.referenceSeq = new MolecularSequenceReferenceSeq(source.referenceSeq);
        }
        if (source['variant']) {
            _this.variant = source.variant.map(function (x) { return new MolecularSequenceVariant(x); });
        }
        else {
            _this.variant = [];
        }
        if (source['observedSeq']) {
            _this.observedSeq = new FhirString({ value: source.observedSeq });
        }
        if (source['quality']) {
            _this.quality = source.quality.map(function (x) { return new MolecularSequenceQuality(x); });
        }
        else {
            _this.quality = [];
        }
        if (source['readCoverage']) {
            _this.readCoverage = new FhirInteger({ value: source.readCoverage });
        }
        if (source['repository']) {
            _this.repository = source.repository.map(function (x) { return new MolecularSequenceRepository(x); });
        }
        else {
            _this.repository = [];
        }
        if (source['pointer']) {
            _this.pointer = source.pointer.map(function (x) { return new Reference(x); });
        }
        else {
            _this.pointer = [];
        }
        if (source['structureVariant']) {
            _this.structureVariant = source.structureVariant.map(function (x) { return new MolecularSequenceStructureVariant(x); });
        }
        else {
            _this.structureVariant = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (MolecularSequence.type)
     */
    MolecularSequence.typeRequiredCoding = function () {
        return SequenceTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    MolecularSequence.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"MolecularSequence" fhir: MolecularSequence.resourceType:"MolecularSequence"', }));
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['coordinateSystem']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property coordinateSystem:fhir.FhirInteger fhir: MolecularSequence.coordinateSystem:integer', }));
        }
        if (this["coordinateSystem"]) {
            (_a = outcome.issue).push.apply(_a, this.coordinateSystem.doModelValidation().issue);
        }
        if (this["patient"]) {
            (_b = outcome.issue).push.apply(_b, this.patient.doModelValidation().issue);
        }
        if (this["specimen"]) {
            (_c = outcome.issue).push.apply(_c, this.specimen.doModelValidation().issue);
        }
        if (this["device"]) {
            (_d = outcome.issue).push.apply(_d, this.device.doModelValidation().issue);
        }
        if (this["performer"]) {
            (_e = outcome.issue).push.apply(_e, this.performer.doModelValidation().issue);
        }
        if (this["quantity"]) {
            (_f = outcome.issue).push.apply(_f, this.quantity.doModelValidation().issue);
        }
        if (this["referenceSeq"]) {
            (_g = outcome.issue).push.apply(_g, this.referenceSeq.doModelValidation().issue);
        }
        if (this["variant"]) {
            this.variant.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["observedSeq"]) {
            (_h = outcome.issue).push.apply(_h, this.observedSeq.doModelValidation().issue);
        }
        if (this["quality"]) {
            this.quality.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["readCoverage"]) {
            (_j = outcome.issue).push.apply(_j, this.readCoverage.doModelValidation().issue);
        }
        if (this["repository"]) {
            this.repository.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["pointer"]) {
            this.pointer.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["structureVariant"]) {
            this.structureVariant.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    MolecularSequence._fts_dataType = 'MolecularSequence';
    return MolecularSequence;
}(DomainResource));

export { MolecularSequence, MolecularSequenceQuality, MolecularSequenceQualityRoc, MolecularSequenceReferenceSeq, MolecularSequenceRepository, MolecularSequenceStructureVariant, MolecularSequenceStructureVariantInner, MolecularSequenceStructureVariantOuter, MolecularSequenceVariant };
//# sourceMappingURL=MolecularSequence.js.map
