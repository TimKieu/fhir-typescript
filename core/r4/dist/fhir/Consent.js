/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { SecurityRoleTypeCodings } from '../fhirValueSets/SecurityRoleTypeCodings.js';
import { ConsentDataMeaningCodings } from '../fhirValueSets/ConsentDataMeaningCodings.js';
import { ConsentProvisionTypeCodings } from '../fhirValueSets/ConsentProvisionTypeCodings.js';
import { SecurityLabelsCodings } from '../fhirValueSets/SecurityLabelsCodings.js';
import { V3PurposeOfUseCodings } from '../fhirValueSets/V3PurposeOfUseCodings.js';
import { ConsentContentClassCodings } from '../fhirValueSets/ConsentContentClassCodings.js';
import { ConsentStateCodesCodings } from '../fhirValueSets/ConsentStateCodesCodings.js';
import { ConsentScopeCodings } from '../fhirValueSets/ConsentScopeCodings.js';
import { ConsentCategoryCodings } from '../fhirValueSets/ConsentCategoryCodings.js';
import { ConsentPolicyCodings } from '../fhirValueSets/ConsentPolicyCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { BackboneElement } from './BackboneElement.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { DomainResource } from './DomainResource.js';
import { FhirUri } from './FhirUri.js';
import { FhirBoolean } from './FhirBoolean.js';
import { Reference } from './Reference.js';
import { FhirDateTime } from './FhirDateTime.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Period } from './Period.js';
import { Coding } from './Coding.js';
import { Identifier } from './Identifier.js';
import { Attachment } from './Attachment.js';

// <auto-generated/>
/**
 * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
var ConsentPolicy = /** @class */ (function (_super) {
    __extends(ConsentPolicy, _super);
    /**
     * Default constructor for ConsentPolicy - initializes any required elements to null if a value is not provided.
     */
    function ConsentPolicy(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['authority']) {
            _this.authority = new FhirUri({ value: source.authority });
        }
        if (source['uri']) {
            _this.uri = new FhirUri({ value: source.uri });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConsentPolicy.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["authority"]) {
            (_a = outcome.issue).push.apply(_a, this.authority.doModelValidation().issue);
        }
        if (this["uri"]) {
            (_b = outcome.issue).push.apply(_b, this.uri.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConsentPolicy._fts_dataType = 'ConsentPolicy';
    return ConsentPolicy;
}(BackboneElement));
/**
 * Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
 */
var ConsentVerification = /** @class */ (function (_super) {
    __extends(ConsentVerification, _super);
    /**
     * Default constructor for ConsentVerification - initializes any required elements to null if a value is not provided.
     */
    function ConsentVerification(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['verified']) {
            _this.verified = new FhirBoolean({ value: source.verified });
        }
        else {
            _this.verified = null;
        }
        if (source['verifiedWith']) {
            _this.verifiedWith = new Reference(source.verifiedWith);
        }
        if (source['verificationDate']) {
            _this.verificationDate = new FhirDateTime({ value: source.verificationDate });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConsentVerification.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['verified']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property verified:fhir.FhirBoolean fhir: Consent.verification.verified:boolean', }));
        }
        if (this["verified"]) {
            (_a = outcome.issue).push.apply(_a, this.verified.doModelValidation().issue);
        }
        if (this["verifiedWith"]) {
            (_b = outcome.issue).push.apply(_b, this.verifiedWith.doModelValidation().issue);
        }
        if (this["verificationDate"]) {
            (_c = outcome.issue).push.apply(_c, this.verificationDate.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConsentVerification._fts_dataType = 'ConsentVerification';
    return ConsentVerification;
}(BackboneElement));
/**
 * Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
var ConsentProvisionActor = /** @class */ (function (_super) {
    __extends(ConsentProvisionActor, _super);
    /**
     * Default constructor for ConsentProvisionActor - initializes any required elements to null if a value is not provided.
     */
    function ConsentProvisionActor(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['role']) {
            _this.role = new CodeableConcept(source.role);
        }
        else {
            _this.role = null;
        }
        if (source['reference']) {
            _this.reference = new Reference(source.reference);
        }
        else {
            _this.reference = null;
        }
        return _this;
    }
    /**
     * Extensible-bound Value Set for role (Consent.provision.actor.role)
     */
    ConsentProvisionActor.roleExtensibleCoding = function () {
        return SecurityRoleTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConsentProvisionActor.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['role']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property role:fhir.CodeableConcept fhir: Consent.provision.actor.role:CodeableConcept', }));
        }
        if (this["role"]) {
            (_a = outcome.issue).push.apply(_a, this.role.doModelValidation().issue);
        }
        if (!this['reference']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property reference:fhir.Reference fhir: Consent.provision.actor.reference:Reference', }));
        }
        if (this["reference"]) {
            (_b = outcome.issue).push.apply(_b, this.reference.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConsentProvisionActor._fts_dataType = 'ConsentProvisionActor';
    return ConsentProvisionActor;
}(BackboneElement));
/**
 * The resources controlled by this rule if specific resources are referenced.
 */
var ConsentProvisionData = /** @class */ (function (_super) {
    __extends(ConsentProvisionData, _super);
    /**
     * Default constructor for ConsentProvisionData - initializes any required elements to null if a value is not provided.
     */
    function ConsentProvisionData(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['meaning']) {
            _this.meaning = source.meaning;
        }
        else {
            _this.meaning = null;
        }
        if (source['reference']) {
            _this.reference = new Reference(source.reference);
        }
        else {
            _this.reference = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for meaning (Consent.provision.data.meaning)
     */
    ConsentProvisionData.meaningRequiredCoding = function () {
        return ConsentDataMeaningCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConsentProvisionData.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['meaning']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property meaning:ConsentDataMeaningCodeType fhir: Consent.provision.data.meaning:code', }));
        }
        if (!this['reference']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property reference:fhir.Reference fhir: Consent.provision.data.reference:Reference', }));
        }
        if (this["reference"]) {
            (_a = outcome.issue).push.apply(_a, this.reference.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConsentProvisionData._fts_dataType = 'ConsentProvisionData';
    return ConsentProvisionData;
}(BackboneElement));
/**
 * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
 */
var ConsentProvision = /** @class */ (function (_super) {
    __extends(ConsentProvision$1, _super);
    /**
     * Default constructor for ConsentProvision - initializes any required elements to null if a value is not provided.
     */
    function ConsentProvision$1(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = source.type;
        }
        if (source['period']) {
            _this.period = new Period(source.period);
        }
        if (source['actor']) {
            _this.actor = source.actor.map(function (x) { return new ConsentProvisionActor(x); });
        }
        else {
            _this.actor = [];
        }
        if (source['action']) {
            _this.action = source.action.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.action = [];
        }
        if (source['securityLabel']) {
            _this.securityLabel = source.securityLabel.map(function (x) { return new Coding(x); });
        }
        else {
            _this.securityLabel = [];
        }
        if (source['purpose']) {
            _this.purpose = source.purpose.map(function (x) { return new Coding(x); });
        }
        else {
            _this.purpose = [];
        }
        if (source['class']) {
            _this.class = source.class.map(function (x) { return new Coding(x); });
        }
        else {
            _this.class = [];
        }
        if (source['code']) {
            _this.code = source.code.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.code = [];
        }
        if (source['dataPeriod']) {
            _this.dataPeriod = new Period(source.dataPeriod);
        }
        if (source['data']) {
            _this.data = source.data.map(function (x) { return new ConsentProvisionData(x); });
        }
        else {
            _this.data = [];
        }
        if (source['provision']) {
            _this.provision = source.provision.map(function (x) { return new ConsentProvision(x); });
        }
        else {
            _this.provision = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (Consent.provision.type)
     */
    ConsentProvision$1.typeRequiredCoding = function () {
        return ConsentProvisionTypeCodings;
    };
    /**
     * Extensible-bound Value Set for securityLabel (Consent.provision.securityLabel)
     */
    ConsentProvision$1.securityLabelExtensibleCoding = function () {
        return SecurityLabelsCodings;
    };
    /**
     * Extensible-bound Value Set for purpose (Consent.provision.purpose)
     */
    ConsentProvision$1.purposeExtensibleCoding = function () {
        return V3PurposeOfUseCodings;
    };
    /**
     * Extensible-bound Value Set for class (Consent.provision.class)
     */
    ConsentProvision$1.classExtensibleCoding = function () {
        return ConsentContentClassCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConsentProvision$1.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["period"]) {
            (_a = outcome.issue).push.apply(_a, this.period.doModelValidation().issue);
        }
        if (this["actor"]) {
            this.actor.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["action"]) {
            this.action.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["securityLabel"]) {
            this.securityLabel.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["purpose"]) {
            this.purpose.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["class"]) {
            this.class.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["code"]) {
            this.code.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["dataPeriod"]) {
            (_b = outcome.issue).push.apply(_b, this.dataPeriod.doModelValidation().issue);
        }
        if (this["data"]) {
            this.data.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["provision"]) {
            this.provision.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConsentProvision$1._fts_dataType = 'ConsentProvision';
    return ConsentProvision$1;
}(BackboneElement));
/**
 * A record of a healthcare consumer’s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
 */
var Consent = /** @class */ (function (_super) {
    __extends(Consent, _super);
    /**
     * Default constructor for Consent - initializes any required elements to null if a value is not provided.
     */
    function Consent(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'Consent';
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['scope']) {
            _this.scope = new CodeableConcept(source.scope);
        }
        else {
            _this.scope = null;
        }
        if (source['category']) {
            _this.category = source.category.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.category = [];
        }
        if (source['patient']) {
            _this.patient = new Reference(source.patient);
        }
        if (source['dateTime']) {
            _this.dateTime = new FhirDateTime({ value: source.dateTime });
        }
        if (source['performer']) {
            _this.performer = source.performer.map(function (x) { return new Reference(x); });
        }
        else {
            _this.performer = [];
        }
        if (source['organization']) {
            _this.organization = source.organization.map(function (x) { return new Reference(x); });
        }
        else {
            _this.organization = [];
        }
        if (source['source']) {
            _this.source = source.source;
        }
        else if (source['sourceAttachment']) {
            _this.source = new Attachment(source.sourceAttachment);
        }
        else if (source['sourceReference']) {
            _this.source = new Reference(source.sourceReference);
        }
        if (source['policy']) {
            _this.policy = source.policy.map(function (x) { return new ConsentPolicy(x); });
        }
        else {
            _this.policy = [];
        }
        if (source['policyRule']) {
            _this.policyRule = new CodeableConcept(source.policyRule);
        }
        if (source['verification']) {
            _this.verification = source.verification.map(function (x) { return new ConsentVerification(x); });
        }
        else {
            _this.verification = [];
        }
        if (source['provision']) {
            _this.provision = new ConsentProvision(source.provision);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (Consent.status)
     */
    Consent.statusRequiredCoding = function () {
        return ConsentStateCodesCodings;
    };
    /**
     * Extensible-bound Value Set for scope (Consent.scope)
     */
    Consent.scopeExtensibleCoding = function () {
        return ConsentScopeCodings;
    };
    /**
     * Extensible-bound Value Set for category (Consent.category)
     */
    Consent.categoryExtensibleCoding = function () {
        return ConsentCategoryCodings;
    };
    /**
     * Extensible-bound Value Set for policyRule (Consent.policyRule)
     */
    Consent.policyRuleExtensibleCoding = function () {
        return ConsentPolicyCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    Consent.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"Consent" fhir: Consent.resourceType:"Consent"', }));
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:ConsentStateCodesCodeType fhir: Consent.status:code', }));
        }
        if (!this['scope']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property scope:fhir.CodeableConcept fhir: Consent.scope:CodeableConcept', }));
        }
        if (this["scope"]) {
            (_a = outcome.issue).push.apply(_a, this.scope.doModelValidation().issue);
        }
        if (!this['category']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept', }));
        }
        else if (!Array.isArray(this.category)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept', }));
        }
        else if (this.category.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept', }));
        }
        if (this["category"]) {
            this.category.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["patient"]) {
            (_b = outcome.issue).push.apply(_b, this.patient.doModelValidation().issue);
        }
        if (this["dateTime"]) {
            (_c = outcome.issue).push.apply(_c, this.dateTime.doModelValidation().issue);
        }
        if (this["performer"]) {
            this.performer.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["organization"]) {
            this.organization.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["policy"]) {
            this.policy.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["policyRule"]) {
            (_d = outcome.issue).push.apply(_d, this.policyRule.doModelValidation().issue);
        }
        if (this["verification"]) {
            this.verification.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["provision"]) {
            (_e = outcome.issue).push.apply(_e, this.provision.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    Consent._fts_dataType = 'Consent';
    /**
     * Internal flag to properly serialize choice-type element Consent.source[x]
     */
    Consent._fts_sourceIsChoice = true;
    return Consent;
}(DomainResource));

export { Consent, ConsentPolicy, ConsentProvision, ConsentProvisionActor, ConsentProvisionData, ConsentVerification };
//# sourceMappingURL=Consent.js.map
