/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { VisionBaseCodesCodings } from '../fhirValueSets/VisionBaseCodesCodings.js';
import { VisionEyeCodesCodings } from '../fhirValueSets/VisionEyeCodesCodings.js';
import { FmStatusCodings } from '../fhirValueSets/FmStatusCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirDecimal } from './FhirDecimal.js';
import { CodeableConcept } from './CodeableConcept.js';
import { FhirInteger } from './FhirInteger.js';
import { Quantity } from './Quantity.js';
import { FhirString } from './FhirString.js';
import { Annotation } from './Annotation.js';
import { Identifier } from './Identifier.js';
import { FhirDateTime } from './FhirDateTime.js';
import { Reference } from './Reference.js';

// <auto-generated/>
/**
 * Allows for adjustment on two axis.
 */
var VisionPrescriptionLensSpecificationPrism = /** @class */ (function (_super) {
    __extends(VisionPrescriptionLensSpecificationPrism, _super);
    /**
     * Default constructor for VisionPrescriptionLensSpecificationPrism - initializes any required elements to null if a value is not provided.
     */
    function VisionPrescriptionLensSpecificationPrism(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['amount']) {
            _this.amount = new FhirDecimal({ value: source.amount });
        }
        else {
            _this.amount = null;
        }
        if (source['base']) {
            _this.base = source.base;
        }
        else {
            _this.base = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for base (VisionPrescription.lensSpecification.prism.base)
     */
    VisionPrescriptionLensSpecificationPrism.baseRequiredCoding = function () {
        return VisionBaseCodesCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    VisionPrescriptionLensSpecificationPrism.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['amount']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property amount:fhir.FhirDecimal fhir: VisionPrescription.lensSpecification.prism.amount:decimal', }));
        }
        if (this["amount"]) {
            (_a = outcome.issue).push.apply(_a, this.amount.doModelValidation().issue);
        }
        if (!this['base']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property base:VisionBaseCodesCodeType fhir: VisionPrescription.lensSpecification.prism.base:code', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    VisionPrescriptionLensSpecificationPrism._fts_dataType = 'VisionPrescriptionLensSpecificationPrism';
    return VisionPrescriptionLensSpecificationPrism;
}(BackboneElement));
/**
 * Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
 */
var VisionPrescriptionLensSpecification = /** @class */ (function (_super) {
    __extends(VisionPrescriptionLensSpecification, _super);
    /**
     * Default constructor for VisionPrescriptionLensSpecification - initializes any required elements to null if a value is not provided.
     */
    function VisionPrescriptionLensSpecification(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['product']) {
            _this.product = new CodeableConcept(source.product);
        }
        else {
            _this.product = null;
        }
        if (source['eye']) {
            _this.eye = source.eye;
        }
        else {
            _this.eye = null;
        }
        if (source['sphere']) {
            _this.sphere = new FhirDecimal({ value: source.sphere });
        }
        if (source['cylinder']) {
            _this.cylinder = new FhirDecimal({ value: source.cylinder });
        }
        if (source['axis']) {
            _this.axis = new FhirInteger({ value: source.axis });
        }
        if (source['prism']) {
            _this.prism = source.prism.map(function (x) { return new VisionPrescriptionLensSpecificationPrism(x); });
        }
        else {
            _this.prism = [];
        }
        if (source['add']) {
            _this.add = new FhirDecimal({ value: source.add });
        }
        if (source['power']) {
            _this.power = new FhirDecimal({ value: source.power });
        }
        if (source['backCurve']) {
            _this.backCurve = new FhirDecimal({ value: source.backCurve });
        }
        if (source['diameter']) {
            _this.diameter = new FhirDecimal({ value: source.diameter });
        }
        if (source['duration']) {
            _this.duration = new Quantity(source.duration);
        }
        if (source['color']) {
            _this.color = new FhirString({ value: source.color });
        }
        if (source['brand']) {
            _this.brand = new FhirString({ value: source.brand });
        }
        if (source['note']) {
            _this.note = source.note.map(function (x) { return new Annotation(x); });
        }
        else {
            _this.note = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for eye (VisionPrescription.lensSpecification.eye)
     */
    VisionPrescriptionLensSpecification.eyeRequiredCoding = function () {
        return VisionEyeCodesCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    VisionPrescriptionLensSpecification.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['product']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property product:fhir.CodeableConcept fhir: VisionPrescription.lensSpecification.product:CodeableConcept', }));
        }
        if (this["product"]) {
            (_a = outcome.issue).push.apply(_a, this.product.doModelValidation().issue);
        }
        if (!this['eye']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property eye:VisionEyeCodesCodeType fhir: VisionPrescription.lensSpecification.eye:code', }));
        }
        if (this["sphere"]) {
            (_b = outcome.issue).push.apply(_b, this.sphere.doModelValidation().issue);
        }
        if (this["cylinder"]) {
            (_c = outcome.issue).push.apply(_c, this.cylinder.doModelValidation().issue);
        }
        if (this["axis"]) {
            (_d = outcome.issue).push.apply(_d, this.axis.doModelValidation().issue);
        }
        if (this["prism"]) {
            this.prism.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["add"]) {
            (_e = outcome.issue).push.apply(_e, this.add.doModelValidation().issue);
        }
        if (this["power"]) {
            (_f = outcome.issue).push.apply(_f, this.power.doModelValidation().issue);
        }
        if (this["backCurve"]) {
            (_g = outcome.issue).push.apply(_g, this.backCurve.doModelValidation().issue);
        }
        if (this["diameter"]) {
            (_h = outcome.issue).push.apply(_h, this.diameter.doModelValidation().issue);
        }
        if (this["duration"]) {
            (_j = outcome.issue).push.apply(_j, this.duration.doModelValidation().issue);
        }
        if (this["color"]) {
            (_k = outcome.issue).push.apply(_k, this.color.doModelValidation().issue);
        }
        if (this["brand"]) {
            (_l = outcome.issue).push.apply(_l, this.brand.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    VisionPrescriptionLensSpecification._fts_dataType = 'VisionPrescriptionLensSpecification';
    return VisionPrescriptionLensSpecification;
}(BackboneElement));
/**
 * An authorization for the provision of glasses and/or contact lenses to a patient.
 */
var VisionPrescription = /** @class */ (function (_super) {
    __extends(VisionPrescription, _super);
    /**
     * Default constructor for VisionPrescription - initializes any required elements to null if a value is not provided.
     */
    function VisionPrescription(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'VisionPrescription';
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['created']) {
            _this.created = new FhirDateTime({ value: source.created });
        }
        else {
            _this.created = null;
        }
        if (source['patient']) {
            _this.patient = new Reference(source.patient);
        }
        else {
            _this.patient = null;
        }
        if (source['encounter']) {
            _this.encounter = new Reference(source.encounter);
        }
        if (source['dateWritten']) {
            _this.dateWritten = new FhirDateTime({ value: source.dateWritten });
        }
        else {
            _this.dateWritten = null;
        }
        if (source['prescriber']) {
            _this.prescriber = new Reference(source.prescriber);
        }
        else {
            _this.prescriber = null;
        }
        if (source['lensSpecification']) {
            _this.lensSpecification = source.lensSpecification.map(function (x) { return new VisionPrescriptionLensSpecification(x); });
        }
        else {
            _this.lensSpecification = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (VisionPrescription.status)
     */
    VisionPrescription.statusRequiredCoding = function () {
        return FmStatusCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    VisionPrescription.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"VisionPrescription" fhir: VisionPrescription.resourceType:"VisionPrescription"', }));
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:FmStatusCodeType fhir: VisionPrescription.status:code', }));
        }
        if (!this['created']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property created:fhir.FhirDateTime fhir: VisionPrescription.created:dateTime', }));
        }
        if (this["created"]) {
            (_a = outcome.issue).push.apply(_a, this.created.doModelValidation().issue);
        }
        if (!this['patient']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property patient:fhir.Reference fhir: VisionPrescription.patient:Reference', }));
        }
        if (this["patient"]) {
            (_b = outcome.issue).push.apply(_b, this.patient.doModelValidation().issue);
        }
        if (this["encounter"]) {
            (_c = outcome.issue).push.apply(_c, this.encounter.doModelValidation().issue);
        }
        if (!this['dateWritten']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property dateWritten:fhir.FhirDateTime fhir: VisionPrescription.dateWritten:dateTime', }));
        }
        if (this["dateWritten"]) {
            (_d = outcome.issue).push.apply(_d, this.dateWritten.doModelValidation().issue);
        }
        if (!this['prescriber']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property prescriber:fhir.Reference fhir: VisionPrescription.prescriber:Reference', }));
        }
        if (this["prescriber"]) {
            (_e = outcome.issue).push.apply(_e, this.prescriber.doModelValidation().issue);
        }
        if (!this['lensSpecification']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification', }));
        }
        else if (!Array.isArray(this.lensSpecification)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification', }));
        }
        else if (this.lensSpecification.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification', }));
        }
        if (this["lensSpecification"]) {
            this.lensSpecification.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    VisionPrescription._fts_dataType = 'VisionPrescription';
    return VisionPrescription;
}(DomainResource));

export { VisionPrescription, VisionPrescriptionLensSpecification, VisionPrescriptionLensSpecificationPrism };
//# sourceMappingURL=VisionPrescription.js.map
