/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { CompositionAttestationModeCodings } from '../fhirValueSets/CompositionAttestationModeCodings.js';
import { DocumentRelationshipTypeCodings } from '../fhirValueSets/DocumentRelationshipTypeCodings.js';
import { ListModeCodings } from '../fhirValueSets/ListModeCodings.js';
import { ListOrderCodings } from '../fhirValueSets/ListOrderCodings.js';
import { ListEmptyReasonCodings } from '../fhirValueSets/ListEmptyReasonCodings.js';
import { CompositionStatusCodings } from '../fhirValueSets/CompositionStatusCodings.js';
import { DocTypecodesCodings } from '../fhirValueSets/DocTypecodesCodings.js';
import { V3ConfidentialityClassificationCodings } from '../fhirValueSets/V3ConfidentialityClassificationCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirDateTime } from './FhirDateTime.js';
import { Reference } from './Reference.js';
import { Identifier } from './Identifier.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Period } from './Period.js';
import { FhirString } from './FhirString.js';
import { Narrative } from './Narrative.js';
import { FhirCode } from './FhirCode.js';

// <auto-generated/>
/**
 * Only list each attester once.
 */
var CompositionAttester = /** @class */ (function (_super) {
    __extends(CompositionAttester, _super);
    /**
     * Default constructor for CompositionAttester - initializes any required elements to null if a value is not provided.
     */
    function CompositionAttester(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['mode']) {
            _this.mode = source.mode;
        }
        else {
            _this.mode = null;
        }
        if (source['time']) {
            _this.time = new FhirDateTime({ value: source.time });
        }
        if (source['party']) {
            _this.party = new Reference(source.party);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for mode (Composition.attester.mode)
     */
    CompositionAttester.modeRequiredCoding = function () {
        return CompositionAttestationModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    CompositionAttester.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['mode']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property mode:CompositionAttestationModeCodeType fhir: Composition.attester.mode:code', }));
        }
        if (this["time"]) {
            (_a = outcome.issue).push.apply(_a, this.time.doModelValidation().issue);
        }
        if (this["party"]) {
            (_b = outcome.issue).push.apply(_b, this.party.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    CompositionAttester._fts_dataType = 'CompositionAttester';
    return CompositionAttester;
}(BackboneElement));
/**
 * A document is a version specific composition.
 */
var CompositionRelatesTo = /** @class */ (function (_super) {
    __extends(CompositionRelatesTo, _super);
    /**
     * Default constructor for CompositionRelatesTo - initializes any required elements to null if a value is not provided.
     */
    function CompositionRelatesTo(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = source.code;
        }
        else {
            _this.code = null;
        }
        if (source['target']) {
            _this.target = source.target;
        }
        else if (source['targetIdentifier']) {
            _this.target = new Identifier(source.targetIdentifier);
        }
        else if (source['targetReference']) {
            _this.target = new Reference(source.targetReference);
        }
        else {
            _this.target = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for code (Composition.relatesTo.code)
     */
    CompositionRelatesTo.codeRequiredCoding = function () {
        return DocumentRelationshipTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    CompositionRelatesTo.prototype.doModelValidation = function () {
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['code']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property code:DocumentRelationshipTypeCodeType fhir: Composition.relatesTo.code:code', }));
        }
        if (!this['target']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property target: fhir: Composition.relatesTo.target[x]:', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    CompositionRelatesTo._fts_dataType = 'CompositionRelatesTo';
    /**
     * Internal flag to properly serialize choice-type element Composition.relatesTo.target[x]
     */
    CompositionRelatesTo._fts_targetIsChoice = true;
    return CompositionRelatesTo;
}(BackboneElement));
/**
 * The event needs to be consistent with the type element, though can provide further information if desired.
 */
var CompositionEvent = /** @class */ (function (_super) {
    __extends(CompositionEvent, _super);
    /**
     * Default constructor for CompositionEvent - initializes any required elements to null if a value is not provided.
     */
    function CompositionEvent(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = source.code.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.code = [];
        }
        if (source['period']) {
            _this.period = new Period(source.period);
        }
        if (source['detail']) {
            _this.detail = source.detail.map(function (x) { return new Reference(x); });
        }
        else {
            _this.detail = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    CompositionEvent.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["code"]) {
            this.code.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["period"]) {
            (_a = outcome.issue).push.apply(_a, this.period.doModelValidation().issue);
        }
        if (this["detail"]) {
            this.detail.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    CompositionEvent._fts_dataType = 'CompositionEvent';
    return CompositionEvent;
}(BackboneElement));
/**
 * The root of the sections that make up the composition.
 */
var CompositionSection = /** @class */ (function (_super) {
    __extends(CompositionSection$1, _super);
    /**
     * Default constructor for CompositionSection - initializes any required elements to null if a value is not provided.
     */
    function CompositionSection$1(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        if (source['code']) {
            _this.code = new CodeableConcept(source.code);
        }
        if (source['author']) {
            _this.author = source.author.map(function (x) { return new Reference(x); });
        }
        else {
            _this.author = [];
        }
        if (source['focus']) {
            _this.focus = new Reference(source.focus);
        }
        if (source['text']) {
            _this.text = new Narrative(source.text);
        }
        if (source['mode']) {
            _this.mode = source.mode;
        }
        if (source['orderedBy']) {
            _this.orderedBy = new CodeableConcept(source.orderedBy);
        }
        if (source['entry']) {
            _this.entry = source.entry.map(function (x) { return new Reference(x); });
        }
        else {
            _this.entry = [];
        }
        if (source['emptyReason']) {
            _this.emptyReason = new CodeableConcept(source.emptyReason);
        }
        if (source['section']) {
            _this.section = source.section.map(function (x) { return new CompositionSection(x); });
        }
        else {
            _this.section = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for mode (Composition.section.mode)
     */
    CompositionSection$1.modeRequiredCoding = function () {
        return ListModeCodings;
    };
    /**
     * Preferred-bound Value Set for orderedBy (Composition.section.orderedBy)
     */
    CompositionSection$1.orderedByPreferredCoding = function () {
        return ListOrderCodings;
    };
    /**
     * Preferred-bound Value Set for emptyReason (Composition.section.emptyReason)
     */
    CompositionSection$1.emptyReasonPreferredCoding = function () {
        return ListEmptyReasonCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    CompositionSection$1.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["title"]) {
            (_a = outcome.issue).push.apply(_a, this.title.doModelValidation().issue);
        }
        if (this["code"]) {
            (_b = outcome.issue).push.apply(_b, this.code.doModelValidation().issue);
        }
        if (this["author"]) {
            this.author.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["focus"]) {
            (_c = outcome.issue).push.apply(_c, this.focus.doModelValidation().issue);
        }
        if (this["text"]) {
            (_d = outcome.issue).push.apply(_d, this.text.doModelValidation().issue);
        }
        if (this["orderedBy"]) {
            (_e = outcome.issue).push.apply(_e, this.orderedBy.doModelValidation().issue);
        }
        if (this["entry"]) {
            this.entry.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["emptyReason"]) {
            (_f = outcome.issue).push.apply(_f, this.emptyReason.doModelValidation().issue);
        }
        if (this["section"]) {
            this.section.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    CompositionSection$1._fts_dataType = 'CompositionSection';
    return CompositionSection$1;
}(BackboneElement));
/**
 * A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.).
 */
var Composition = /** @class */ (function (_super) {
    __extends(Composition, _super);
    /**
     * Default constructor for Composition - initializes any required elements to null if a value is not provided.
     */
    function Composition(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'Composition';
        if (source['identifier']) {
            _this.identifier = new Identifier(source.identifier);
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['type']) {
            _this.type = new CodeableConcept(source.type);
        }
        else {
            _this.type = null;
        }
        if (source['category']) {
            _this.category = source.category.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.category = [];
        }
        if (source['subject']) {
            _this.subject = new Reference(source.subject);
        }
        if (source['encounter']) {
            _this.encounter = new Reference(source.encounter);
        }
        if (source['date']) {
            _this.date = new FhirDateTime({ value: source.date });
        }
        else {
            _this.date = null;
        }
        if (source['author']) {
            _this.author = source.author.map(function (x) { return new Reference(x); });
        }
        else {
            _this.author = [];
        }
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        else {
            _this.title = null;
        }
        if (source['confidentiality']) {
            _this.confidentiality = new FhirCode({ value: source.confidentiality });
        }
        if (source['attester']) {
            _this.attester = source.attester.map(function (x) { return new CompositionAttester(x); });
        }
        else {
            _this.attester = [];
        }
        if (source['custodian']) {
            _this.custodian = new Reference(source.custodian);
        }
        if (source['relatesTo']) {
            _this.relatesTo = source.relatesTo.map(function (x) { return new CompositionRelatesTo(x); });
        }
        else {
            _this.relatesTo = [];
        }
        if (source['event']) {
            _this.event = source.event.map(function (x) { return new CompositionEvent(x); });
        }
        else {
            _this.event = [];
        }
        if (source['section']) {
            _this.section = source.section.map(function (x) { return new CompositionSection(x); });
        }
        else {
            _this.section = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (Composition.status)
     */
    Composition.statusRequiredCoding = function () {
        return CompositionStatusCodings;
    };
    /**
     * Preferred-bound Value Set for type (Composition.type)
     */
    Composition.typePreferredCoding = function () {
        return DocTypecodesCodings;
    };
    /**
     * Required-bound Value Set for confidentiality (Composition.confidentiality)
     */
    Composition.confidentialityRequiredCoding = function () {
        return V3ConfidentialityClassificationCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    Composition.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"Composition" fhir: Composition.resourceType:"Composition"', }));
        }
        if (this["identifier"]) {
            (_a = outcome.issue).push.apply(_a, this.identifier.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:CompositionStatusCodeType fhir: Composition.status:code', }));
        }
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:fhir.CodeableConcept fhir: Composition.type:CodeableConcept', }));
        }
        if (this["type"]) {
            (_b = outcome.issue).push.apply(_b, this.type.doModelValidation().issue);
        }
        if (this["category"]) {
            this.category.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["subject"]) {
            (_c = outcome.issue).push.apply(_c, this.subject.doModelValidation().issue);
        }
        if (this["encounter"]) {
            (_d = outcome.issue).push.apply(_d, this.encounter.doModelValidation().issue);
        }
        if (!this['date']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property date:fhir.FhirDateTime fhir: Composition.date:dateTime', }));
        }
        if (this["date"]) {
            (_e = outcome.issue).push.apply(_e, this.date.doModelValidation().issue);
        }
        if (!this['author']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property author:fhir.Reference[] fhir: Composition.author:Reference', }));
        }
        else if (!Array.isArray(this.author)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property author:fhir.Reference[] fhir: Composition.author:Reference', }));
        }
        else if (this.author.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property author:fhir.Reference[] fhir: Composition.author:Reference', }));
        }
        if (this["author"]) {
            this.author.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['title']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property title:fhir.FhirString fhir: Composition.title:string', }));
        }
        if (this["title"]) {
            (_f = outcome.issue).push.apply(_f, this.title.doModelValidation().issue);
        }
        if (this["confidentiality"]) {
            (_g = outcome.issue).push.apply(_g, this.confidentiality.doModelValidation().issue);
        }
        if (this["attester"]) {
            this.attester.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["custodian"]) {
            (_h = outcome.issue).push.apply(_h, this.custodian.doModelValidation().issue);
        }
        if (this["relatesTo"]) {
            this.relatesTo.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["event"]) {
            this.event.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["section"]) {
            this.section.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    Composition._fts_dataType = 'Composition';
    return Composition;
}(DomainResource));

export { Composition, CompositionAttester, CompositionEvent, CompositionRelatesTo, CompositionSection };
//# sourceMappingURL=Composition.js.map
