/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { PublicationStatusCodings } from '../fhirValueSets/PublicationStatusCodings.js';
import { CapabilityStatementKindCodings } from '../fhirValueSets/CapabilityStatementKindCodings.js';
import { CodeSearchSupportCodings } from '../fhirValueSets/CodeSearchSupportCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirString } from './FhirString.js';
import { FhirUrl } from './FhirUrl.js';
import { FhirCode } from './FhirCode.js';
import { FhirBoolean } from './FhirBoolean.js';
import { FhirCanonical } from './FhirCanonical.js';
import { FhirMarkdown } from './FhirMarkdown.js';
import { FhirUri } from './FhirUri.js';
import { FhirDateTime } from './FhirDateTime.js';
import { ContactDetail } from './ContactDetail.js';
import { UsageContext } from './UsageContext.js';
import { CodeableConcept } from './CodeableConcept.js';

// <auto-generated/>
/**
 * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
 */
var TerminologyCapabilitiesSoftware = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesSoftware, _super);
    /**
     * Default constructor for TerminologyCapabilitiesSoftware - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesSoftware(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesSoftware.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirString fhir: TerminologyCapabilities.software.name:string', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (this["version"]) {
            (_b = outcome.issue).push.apply(_b, this.version.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesSoftware._fts_dataType = 'TerminologyCapabilitiesSoftware';
    return TerminologyCapabilitiesSoftware;
}(BackboneElement));
/**
 * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
var TerminologyCapabilitiesImplementation = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesImplementation, _super);
    /**
     * Default constructor for TerminologyCapabilitiesImplementation - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesImplementation(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['description']) {
            _this.description = new FhirString({ value: source.description });
        }
        else {
            _this.description = null;
        }
        if (source['url']) {
            _this.url = new FhirUrl({ value: source.url });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesImplementation.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['description']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property description:fhir.FhirString fhir: TerminologyCapabilities.implementation.description:string', }));
        }
        if (this["description"]) {
            (_a = outcome.issue).push.apply(_a, this.description.doModelValidation().issue);
        }
        if (this["url"]) {
            (_b = outcome.issue).push.apply(_b, this.url.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesImplementation._fts_dataType = 'TerminologyCapabilitiesImplementation';
    return TerminologyCapabilitiesImplementation;
}(BackboneElement));
/**
 * Filter Properties supported.
 */
var TerminologyCapabilitiesCodeSystemVersionFilter = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesCodeSystemVersionFilter, _super);
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystemVersionFilter - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesCodeSystemVersionFilter(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = new FhirCode({ value: source.code });
        }
        else {
            _this.code = null;
        }
        if (source['op']) {
            _this.op = source.op.map(function (x) { return new FhirCode({ value: x }); });
        }
        else {
            _this.op = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesCodeSystemVersionFilter.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['code']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property code:fhir.FhirCode fhir: TerminologyCapabilities.codeSystem.version.filter.code:code', }));
        }
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (!this['op']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property op:fhir.FhirCode[] fhir: TerminologyCapabilities.codeSystem.version.filter.op:code', }));
        }
        else if (!Array.isArray(this.op)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property op:fhir.FhirCode[] fhir: TerminologyCapabilities.codeSystem.version.filter.op:code', }));
        }
        else if (this.op.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property op:fhir.FhirCode[] fhir: TerminologyCapabilities.codeSystem.version.filter.op:code', }));
        }
        if (this["op"]) {
            this.op.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesCodeSystemVersionFilter._fts_dataType = 'TerminologyCapabilitiesCodeSystemVersionFilter';
    return TerminologyCapabilitiesCodeSystemVersionFilter;
}(BackboneElement));
/**
 * Language translations might not be available for all codes.
 */
var TerminologyCapabilitiesCodeSystemVersion = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesCodeSystemVersion, _super);
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystemVersion - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesCodeSystemVersion(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = new FhirString({ value: source.code });
        }
        if (source['isDefault']) {
            _this.isDefault = new FhirBoolean({ value: source.isDefault });
        }
        if (source['compositional']) {
            _this.compositional = new FhirBoolean({ value: source.compositional });
        }
        if (source['language']) {
            _this.language = source.language.map(function (x) { return new FhirCode({ value: x }); });
        }
        else {
            _this.language = [];
        }
        if (source['filter']) {
            _this.filter = source.filter.map(function (x) { return new TerminologyCapabilitiesCodeSystemVersionFilter(x); });
        }
        else {
            _this.filter = [];
        }
        if (source['property']) {
            _this.property = source.property.map(function (x) { return new FhirCode({ value: x }); });
        }
        else {
            _this.property = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesCodeSystemVersion.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["isDefault"]) {
            (_b = outcome.issue).push.apply(_b, this.isDefault.doModelValidation().issue);
        }
        if (this["compositional"]) {
            (_c = outcome.issue).push.apply(_c, this.compositional.doModelValidation().issue);
        }
        if (this["language"]) {
            this.language.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["filter"]) {
            this.filter.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["property"]) {
            this.property.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesCodeSystemVersion._fts_dataType = 'TerminologyCapabilitiesCodeSystemVersion';
    return TerminologyCapabilitiesCodeSystemVersion;
}(BackboneElement));
/**
 * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
 */
var TerminologyCapabilitiesCodeSystem = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesCodeSystem, _super);
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystem - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesCodeSystem(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['uri']) {
            _this.uri = new FhirCanonical({ value: source.uri });
        }
        if (source['version']) {
            _this.version = source.version.map(function (x) { return new TerminologyCapabilitiesCodeSystemVersion(x); });
        }
        else {
            _this.version = [];
        }
        if (source['subsumption']) {
            _this.subsumption = new FhirBoolean({ value: source.subsumption });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesCodeSystem.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["uri"]) {
            (_a = outcome.issue).push.apply(_a, this.uri.doModelValidation().issue);
        }
        if (this["version"]) {
            this.version.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["subsumption"]) {
            (_b = outcome.issue).push.apply(_b, this.subsumption.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesCodeSystem._fts_dataType = 'TerminologyCapabilitiesCodeSystem';
    return TerminologyCapabilitiesCodeSystem;
}(BackboneElement));
/**
 * Supported expansion parameter.
 */
var TerminologyCapabilitiesExpansionParameter = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesExpansionParameter, _super);
    /**
     * Default constructor for TerminologyCapabilitiesExpansionParameter - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesExpansionParameter(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirCode({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['documentation']) {
            _this.documentation = new FhirString({ value: source.documentation });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesExpansionParameter.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirCode fhir: TerminologyCapabilities.expansion.parameter.name:code', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (this["documentation"]) {
            (_b = outcome.issue).push.apply(_b, this.documentation.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesExpansionParameter._fts_dataType = 'TerminologyCapabilitiesExpansionParameter';
    return TerminologyCapabilitiesExpansionParameter;
}(BackboneElement));
/**
 * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
 */
var TerminologyCapabilitiesExpansion = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesExpansion, _super);
    /**
     * Default constructor for TerminologyCapabilitiesExpansion - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesExpansion(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['hierarchical']) {
            _this.hierarchical = new FhirBoolean({ value: source.hierarchical });
        }
        if (source['paging']) {
            _this.paging = new FhirBoolean({ value: source.paging });
        }
        if (source['incomplete']) {
            _this.incomplete = new FhirBoolean({ value: source.incomplete });
        }
        if (source['parameter']) {
            _this.parameter = source.parameter.map(function (x) { return new TerminologyCapabilitiesExpansionParameter(x); });
        }
        else {
            _this.parameter = [];
        }
        if (source['textFilter']) {
            _this.textFilter = new FhirMarkdown({ value: source.textFilter });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesExpansion.prototype.doModelValidation = function () {
        var _a, _b, _c, _d;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["hierarchical"]) {
            (_a = outcome.issue).push.apply(_a, this.hierarchical.doModelValidation().issue);
        }
        if (this["paging"]) {
            (_b = outcome.issue).push.apply(_b, this.paging.doModelValidation().issue);
        }
        if (this["incomplete"]) {
            (_c = outcome.issue).push.apply(_c, this.incomplete.doModelValidation().issue);
        }
        if (this["parameter"]) {
            this.parameter.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["textFilter"]) {
            (_d = outcome.issue).push.apply(_d, this.textFilter.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesExpansion._fts_dataType = 'TerminologyCapabilitiesExpansion';
    return TerminologyCapabilitiesExpansion;
}(BackboneElement));
/**
 * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
 */
var TerminologyCapabilitiesValidateCode = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesValidateCode, _super);
    /**
     * Default constructor for TerminologyCapabilitiesValidateCode - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesValidateCode(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['translations']) {
            _this.translations = new FhirBoolean({ value: source.translations });
        }
        else {
            _this.translations = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesValidateCode.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['translations']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property translations:fhir.FhirBoolean fhir: TerminologyCapabilities.validateCode.translations:boolean', }));
        }
        if (this["translations"]) {
            (_a = outcome.issue).push.apply(_a, this.translations.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesValidateCode._fts_dataType = 'TerminologyCapabilitiesValidateCode';
    return TerminologyCapabilitiesValidateCode;
}(BackboneElement));
/**
 * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
 */
var TerminologyCapabilitiesTranslation = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesTranslation, _super);
    /**
     * Default constructor for TerminologyCapabilitiesTranslation - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesTranslation(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['needsMap']) {
            _this.needsMap = new FhirBoolean({ value: source.needsMap });
        }
        else {
            _this.needsMap = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesTranslation.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['needsMap']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property needsMap:fhir.FhirBoolean fhir: TerminologyCapabilities.translation.needsMap:boolean', }));
        }
        if (this["needsMap"]) {
            (_a = outcome.issue).push.apply(_a, this.needsMap.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesTranslation._fts_dataType = 'TerminologyCapabilitiesTranslation';
    return TerminologyCapabilitiesTranslation;
}(BackboneElement));
/**
 * Whether the $closure operation is supported.
 */
var TerminologyCapabilitiesClosure = /** @class */ (function (_super) {
    __extends(TerminologyCapabilitiesClosure, _super);
    /**
     * Default constructor for TerminologyCapabilitiesClosure - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilitiesClosure(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['translation']) {
            _this.translation = new FhirBoolean({ value: source.translation });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilitiesClosure.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["translation"]) {
            (_a = outcome.issue).push.apply(_a, this.translation.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilitiesClosure._fts_dataType = 'TerminologyCapabilitiesClosure';
    return TerminologyCapabilitiesClosure;
}(BackboneElement));
/**
 * A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
var TerminologyCapabilities = /** @class */ (function (_super) {
    __extends(TerminologyCapabilities, _super);
    /**
     * Default constructor for TerminologyCapabilities - initializes any required elements to null if a value is not provided.
     */
    function TerminologyCapabilities(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'TerminologyCapabilities';
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['experimental']) {
            _this.experimental = new FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            _this.date = new FhirDateTime({ value: source.date });
        }
        else {
            _this.date = null;
        }
        if (source['publisher']) {
            _this.publisher = new FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            _this.contact = source.contact.map(function (x) { return new ContactDetail(x); });
        }
        else {
            _this.contact = [];
        }
        if (source['description']) {
            _this.description = new FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            _this.useContext = source.useContext.map(function (x) { return new UsageContext(x); });
        }
        else {
            _this.useContext = [];
        }
        if (source['jurisdiction']) {
            _this.jurisdiction = source.jurisdiction.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.jurisdiction = [];
        }
        if (source['purpose']) {
            _this.purpose = new FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            _this.copyright = new FhirMarkdown({ value: source.copyright });
        }
        if (source['kind']) {
            _this.kind = source.kind;
        }
        else {
            _this.kind = null;
        }
        if (source['software']) {
            _this.software = new TerminologyCapabilitiesSoftware(source.software);
        }
        if (source['implementation']) {
            _this.implementation = new TerminologyCapabilitiesImplementation(source.implementation);
        }
        if (source['lockedDate']) {
            _this.lockedDate = new FhirBoolean({ value: source.lockedDate });
        }
        if (source['codeSystem']) {
            _this.codeSystem = source.codeSystem.map(function (x) { return new TerminologyCapabilitiesCodeSystem(x); });
        }
        else {
            _this.codeSystem = [];
        }
        if (source['expansion']) {
            _this.expansion = new TerminologyCapabilitiesExpansion(source.expansion);
        }
        if (source['codeSearch']) {
            _this.codeSearch = source.codeSearch;
        }
        if (source['validateCode']) {
            _this.validateCode = new TerminologyCapabilitiesValidateCode(source.validateCode);
        }
        if (source['translation']) {
            _this.translation = new TerminologyCapabilitiesTranslation(source.translation);
        }
        if (source['closure']) {
            _this.closure = new TerminologyCapabilitiesClosure(source.closure);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (TerminologyCapabilities.status)
     */
    TerminologyCapabilities.statusRequiredCoding = function () {
        return PublicationStatusCodings;
    };
    /**
     * Required-bound Value Set for kind (TerminologyCapabilities.kind)
     */
    TerminologyCapabilities.kindRequiredCoding = function () {
        return CapabilityStatementKindCodings;
    };
    /**
     * Required-bound Value Set for codeSearch (TerminologyCapabilities.codeSearch)
     */
    TerminologyCapabilities.codeSearchRequiredCoding = function () {
        return CodeSearchSupportCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TerminologyCapabilities.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"TerminologyCapabilities" fhir: TerminologyCapabilities.resourceType:"TerminologyCapabilities"', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (this["version"]) {
            (_b = outcome.issue).push.apply(_b, this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            (_c = outcome.issue).push.apply(_c, this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            (_d = outcome.issue).push.apply(_d, this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:PublicationStatusCodeType fhir: TerminologyCapabilities.status:code', }));
        }
        if (this["experimental"]) {
            (_e = outcome.issue).push.apply(_e, this.experimental.doModelValidation().issue);
        }
        if (!this['date']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property date:fhir.FhirDateTime fhir: TerminologyCapabilities.date:dateTime', }));
        }
        if (this["date"]) {
            (_f = outcome.issue).push.apply(_f, this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            (_g = outcome.issue).push.apply(_g, this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["description"]) {
            (_h = outcome.issue).push.apply(_h, this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["purpose"]) {
            (_j = outcome.issue).push.apply(_j, this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            (_k = outcome.issue).push.apply(_k, this.copyright.doModelValidation().issue);
        }
        if (!this['kind']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property kind:CapabilityStatementKindCodeType fhir: TerminologyCapabilities.kind:code', }));
        }
        if (this["software"]) {
            (_l = outcome.issue).push.apply(_l, this.software.doModelValidation().issue);
        }
        if (this["implementation"]) {
            (_m = outcome.issue).push.apply(_m, this.implementation.doModelValidation().issue);
        }
        if (this["lockedDate"]) {
            (_o = outcome.issue).push.apply(_o, this.lockedDate.doModelValidation().issue);
        }
        if (this["codeSystem"]) {
            this.codeSystem.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["expansion"]) {
            (_p = outcome.issue).push.apply(_p, this.expansion.doModelValidation().issue);
        }
        if (this["validateCode"]) {
            (_q = outcome.issue).push.apply(_q, this.validateCode.doModelValidation().issue);
        }
        if (this["translation"]) {
            (_r = outcome.issue).push.apply(_r, this.translation.doModelValidation().issue);
        }
        if (this["closure"]) {
            (_s = outcome.issue).push.apply(_s, this.closure.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TerminologyCapabilities._fts_dataType = 'TerminologyCapabilities';
    return TerminologyCapabilities;
}(DomainResource));

export { TerminologyCapabilities, TerminologyCapabilitiesClosure, TerminologyCapabilitiesCodeSystem, TerminologyCapabilitiesCodeSystemVersion, TerminologyCapabilitiesCodeSystemVersionFilter, TerminologyCapabilitiesExpansion, TerminologyCapabilitiesExpansionParameter, TerminologyCapabilitiesImplementation, TerminologyCapabilitiesSoftware, TerminologyCapabilitiesTranslation, TerminologyCapabilitiesValidateCode };
//# sourceMappingURL=TerminologyCapabilities.js.map
