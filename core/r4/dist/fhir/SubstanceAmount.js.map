{"version":3,"file":"SubstanceAmount.js","sources":["../../src/fhir/SubstanceAmount.ts"],"sourcesContent":["// <auto-generated/>\r\n// Contents of: hl7.fhir.r4.core version: 4.0.1\r\n// Minimum TypeScript Version: 3.7\r\n// FHIR ComplexType: SubstanceAmount\r\n\r\nimport * as fhir from '../fhir.js';\r\n\r\n// @ts-ignore\r\nimport { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';\r\n// @ts-ignore\r\nimport { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';\r\n/**\r\n * Valid arguments for the SubstanceAmountReferenceRange type.\r\n */\r\nexport interface SubstanceAmountReferenceRangeArgs extends fhir.FhirElementArgs {\r\n  /**\r\n   * Lower limit possible or expected.\r\n   */\r\n  lowLimit?: fhir.QuantityArgs|undefined;\r\n  /**\r\n   * Upper limit possible or expected.\r\n   */\r\n  highLimit?: fhir.QuantityArgs|undefined;\r\n}\r\n\r\n/**\r\n * Reference range of possible or expected values.\r\n */\r\nexport class SubstanceAmountReferenceRange extends fhir.FhirElement {\r\n  /**\r\n   * Mapping of this datatype to a FHIR equivalent\r\n   */\r\n  public static readonly _fts_dataType:string = 'SubstanceAmountReferenceRange';\r\n  /**\r\n   * Lower limit possible or expected.\r\n   */\r\n  public lowLimit?: fhir.Quantity|undefined;\r\n  /**\r\n   * Upper limit possible or expected.\r\n   */\r\n  public highLimit?: fhir.Quantity|undefined;\r\n  /**\r\n   * Default constructor for SubstanceAmountReferenceRange - initializes any required elements to null if a value is not provided.\r\n   */\r\n  constructor(source:Partial<SubstanceAmountReferenceRangeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {\r\n    super(source, options);\r\n    if (source['lowLimit']) { this.lowLimit = new fhir.Quantity(source.lowLimit); }\r\n    if (source['highLimit']) { this.highLimit = new fhir.Quantity(source.highLimit); }\r\n  }\r\n  /**\r\n   * Function to perform basic model validation (e.g., check if required elements are present).\r\n   */\r\n  public override doModelValidation():fhir.OperationOutcome {\r\n    var outcome:fhir.OperationOutcome = super.doModelValidation();\r\n    if (this[\"lowLimit\"]) { outcome.issue!.push(...this.lowLimit.doModelValidation().issue!); }\r\n    if (this[\"highLimit\"]) { outcome.issue!.push(...this.highLimit.doModelValidation().issue!); }\r\n    return outcome;\r\n  }\r\n}\r\n/**\r\n * Valid arguments for the SubstanceAmount type.\r\n */\r\nexport interface SubstanceAmountArgs extends fhir.BackboneElementArgs {\r\n  /**\r\n   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.\r\n   */\r\n  amount?: fhir.Quantity|fhir.Range|fhir.FhirString|undefined;\r\n  /**\r\n   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.\r\n   */\r\n  amountQuantity?: fhir.QuantityArgs|undefined;\r\n  /**\r\n   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.\r\n   */\r\n  amountRange?: fhir.RangeArgs|undefined;\r\n  /**\r\n   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.\r\n   */\r\n  amountString?: fhir.FhirString|string|undefined;\r\n  /**\r\n   * Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements.\r\n   */\r\n  amountType?: fhir.CodeableConceptArgs|undefined;\r\n  /**\r\n   * A textual comment on a numeric value.\r\n   */\r\n  amountText?: fhir.FhirString|string|undefined;\r\n  /**\r\n   * Reference range of possible or expected values.\r\n   */\r\n  referenceRange?: fhir.SubstanceAmountReferenceRangeArgs|undefined;\r\n}\r\n\r\n/**\r\n * Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.\r\n */\r\nexport class SubstanceAmount extends fhir.BackboneElement {\r\n  /**\r\n   * Mapping of this datatype to a FHIR equivalent\r\n   */\r\n  public static readonly _fts_dataType:string = 'SubstanceAmount';\r\n  /**\r\n   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.\r\n   */\r\n  public amount?: (fhir.Quantity|fhir.Range|fhir.FhirString)|undefined;\r\n  /**\r\n   * Internal flag to properly serialize choice-type element SubstanceAmount.amount[x]\r\n   */\r\n  protected static readonly _fts_amountIsChoice:true = true;\r\n  /**\r\n   * Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements.\r\n   */\r\n  public amountType?: fhir.CodeableConcept|undefined;\r\n  /**\r\n   * A textual comment on a numeric value.\r\n   */\r\n  public amountText?: fhir.FhirString|undefined;\r\n  /**\r\n   * Reference range of possible or expected values.\r\n   */\r\n  public referenceRange?: fhir.SubstanceAmountReferenceRange|undefined;\r\n  /**\r\n   * Default constructor for SubstanceAmount - initializes any required elements to null if a value is not provided.\r\n   */\r\n  constructor(source:Partial<SubstanceAmountArgs> = {}, options:fhir.FhirConstructorOptions = {}) {\r\n    super(source, options);\r\n    if (source['amount']) { this.amount = source.amount; }\r\n    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }\r\n    else if (source['amountRange']) { this.amount = new fhir.Range(source.amountRange); }\r\n    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }\r\n    if (source['amountType']) { this.amountType = new fhir.CodeableConcept(source.amountType); }\r\n    if (source['amountText']) { this.amountText = new fhir.FhirString({value: source.amountText}); }\r\n    if (source['referenceRange']) { this.referenceRange = new fhir.SubstanceAmountReferenceRange(source.referenceRange); }\r\n  }\r\n  /**\r\n   * Function to perform basic model validation (e.g., check if required elements are present).\r\n   */\r\n  public override doModelValidation():fhir.OperationOutcome {\r\n    var outcome:fhir.OperationOutcome = super.doModelValidation();\r\n    if (this[\"amountType\"]) { outcome.issue!.push(...this.amountType.doModelValidation().issue!); }\r\n    if (this[\"amountText\"]) { outcome.issue!.push(...this.amountText.doModelValidation().issue!); }\r\n    if (this[\"referenceRange\"]) { outcome.issue!.push(...this.referenceRange.doModelValidation().issue!); }\r\n    return outcome;\r\n  }\r\n}\r\n"],"names":["fhir.Quantity","fhir.FhirElement","fhir.Range","fhir.FhirString","fhir.CodeableConcept","fhir.SubstanceAmountReferenceRange","fhir.BackboneElement"],"mappings":"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"}