/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { QuestionnaireEnableOperatorCodings } from '../fhirValueSets/QuestionnaireEnableOperatorCodings.js';
import { ItemTypeCodings } from '../fhirValueSets/ItemTypeCodings.js';
import { QuestionnaireEnableBehaviorCodings } from '../fhirValueSets/QuestionnaireEnableBehaviorCodings.js';
import { PublicationStatusCodings } from '../fhirValueSets/PublicationStatusCodings.js';
import { ResourceTypesCodings } from '../fhirValueSets/ResourceTypesCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirString } from './FhirString.js';
import { FhirBoolean } from './FhirBoolean.js';
import { FhirDecimal } from './FhirDecimal.js';
import { FhirInteger } from './FhirInteger.js';
import { FhirDate } from './FhirDate.js';
import { FhirDateTime } from './FhirDateTime.js';
import { FhirTime } from './FhirTime.js';
import { Coding } from './Coding.js';
import { Quantity } from './Quantity.js';
import { Reference } from './Reference.js';
import { FhirUri } from './FhirUri.js';
import { Attachment } from './Attachment.js';
import { FhirCanonical } from './FhirCanonical.js';
import { Identifier } from './Identifier.js';
import { FhirCode } from './FhirCode.js';
import { ContactDetail } from './ContactDetail.js';
import { FhirMarkdown } from './FhirMarkdown.js';
import { UsageContext } from './UsageContext.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Period } from './Period.js';

// <auto-generated/>
/**
 * If multiple repetitions of this extension are present, the item should be enabled when the condition for *any* of the repetitions is true.  I.e. treat "enableWhen"s as being joined by an "or" clause.  This element is a modifier because if enableWhen is present for an item, "required" is ignored unless one of the enableWhen conditions is met. When an item is disabled, all of its descendants are disabled, regardless of what their own enableWhen logic might evaluate to.
 */
var QuestionnaireItemEnableWhen = /** @class */ (function (_super) {
    __extends(QuestionnaireItemEnableWhen, _super);
    /**
     * Default constructor for QuestionnaireItemEnableWhen - initializes any required elements to null if a value is not provided.
     */
    function QuestionnaireItemEnableWhen(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['question']) {
            _this.question = new FhirString({ value: source.question });
        }
        else {
            _this.question = null;
        }
        if (source['operator']) {
            _this.operator = source.operator;
        }
        else {
            _this.operator = null;
        }
        if (source['answer']) {
            _this.answer = source.answer;
        }
        else if (source['answerBoolean']) {
            _this.answer = new FhirBoolean({ value: source.answerBoolean });
        }
        else if (source['answerDecimal']) {
            _this.answer = new FhirDecimal({ value: source.answerDecimal });
        }
        else if (source['answerInteger']) {
            _this.answer = new FhirInteger({ value: source.answerInteger });
        }
        else if (source['answerDate']) {
            _this.answer = new FhirDate({ value: source.answerDate });
        }
        else if (source['answerDateTime']) {
            _this.answer = new FhirDateTime({ value: source.answerDateTime });
        }
        else if (source['answerTime']) {
            _this.answer = new FhirTime({ value: source.answerTime });
        }
        else if (source['answerString']) {
            _this.answer = new FhirString({ value: source.answerString });
        }
        else if (source['answerCoding']) {
            _this.answer = new Coding(source.answerCoding);
        }
        else if (source['answerQuantity']) {
            _this.answer = new Quantity(source.answerQuantity);
        }
        else if (source['answerReference']) {
            _this.answer = new Reference(source.answerReference);
        }
        else {
            _this.answer = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for operator (Questionnaire.item.enableWhen.operator)
     */
    QuestionnaireItemEnableWhen.operatorRequiredCoding = function () {
        return QuestionnaireEnableOperatorCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    QuestionnaireItemEnableWhen.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['question']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property question:fhir.FhirString fhir: Questionnaire.item.enableWhen.question:string', }));
        }
        if (this["question"]) {
            (_a = outcome.issue).push.apply(_a, this.question.doModelValidation().issue);
        }
        if (!this['operator']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property operator:QuestionnaireEnableOperatorCodeType fhir: Questionnaire.item.enableWhen.operator:code', }));
        }
        if (!this['answer']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property answer: fhir: Questionnaire.item.enableWhen.answer[x]:', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    QuestionnaireItemEnableWhen._fts_dataType = 'QuestionnaireItemEnableWhen';
    /**
     * Internal flag to properly serialize choice-type element Questionnaire.item.enableWhen.answer[x]
     */
    QuestionnaireItemEnableWhen._fts_answerIsChoice = true;
    return QuestionnaireItemEnableWhen;
}(BackboneElement));
/**
 * This element can be used when the value set machinery of answerValueSet is deemed too cumbersome or when there's a need to capture possible answers that are not codes.
 */
var QuestionnaireItemAnswerOption = /** @class */ (function (_super) {
    __extends(QuestionnaireItemAnswerOption, _super);
    /**
     * Default constructor for QuestionnaireItemAnswerOption - initializes any required elements to null if a value is not provided.
     */
    function QuestionnaireItemAnswerOption(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['value']) {
            _this.value = source.value;
        }
        else if (source['valueInteger']) {
            _this.value = new FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueDate']) {
            _this.value = new FhirDate({ value: source.valueDate });
        }
        else if (source['valueTime']) {
            _this.value = new FhirTime({ value: source.valueTime });
        }
        else if (source['valueString']) {
            _this.value = new FhirString({ value: source.valueString });
        }
        else if (source['valueCoding']) {
            _this.value = new Coding(source.valueCoding);
        }
        else if (source['valueReference']) {
            _this.value = new Reference(source.valueReference);
        }
        else {
            _this.value = null;
        }
        if (source['initialSelected']) {
            _this.initialSelected = new FhirBoolean({ value: source.initialSelected });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    QuestionnaireItemAnswerOption.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value: fhir: Questionnaire.item.answerOption.value[x]:', }));
        }
        if (this["initialSelected"]) {
            (_a = outcome.issue).push.apply(_a, this.initialSelected.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    QuestionnaireItemAnswerOption._fts_dataType = 'QuestionnaireItemAnswerOption';
    /**
     * Internal flag to properly serialize choice-type element Questionnaire.item.answerOption.value[x]
     */
    QuestionnaireItemAnswerOption._fts_valueIsChoice = true;
    return QuestionnaireItemAnswerOption;
}(BackboneElement));
/**
 * The user is allowed to change the value and override the default (unless marked as read-only). If the user doesn't change the value, then this initial value will be persisted when the QuestionnaireResponse is initially created.  Note that initial values can influence results.  The data type of initial[x] must agree with the item.type, and only repeating items can have more then one initial value.
 */
var QuestionnaireItemInitial = /** @class */ (function (_super) {
    __extends(QuestionnaireItemInitial, _super);
    /**
     * Default constructor for QuestionnaireItemInitial - initializes any required elements to null if a value is not provided.
     */
    function QuestionnaireItemInitial(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['value']) {
            _this.value = source.value;
        }
        else if (source['valueBoolean']) {
            _this.value = new FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueDecimal']) {
            _this.value = new FhirDecimal({ value: source.valueDecimal });
        }
        else if (source['valueInteger']) {
            _this.value = new FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueDate']) {
            _this.value = new FhirDate({ value: source.valueDate });
        }
        else if (source['valueDateTime']) {
            _this.value = new FhirDateTime({ value: source.valueDateTime });
        }
        else if (source['valueTime']) {
            _this.value = new FhirTime({ value: source.valueTime });
        }
        else if (source['valueString']) {
            _this.value = new FhirString({ value: source.valueString });
        }
        else if (source['valueUri']) {
            _this.value = new FhirUri({ value: source.valueUri });
        }
        else if (source['valueAttachment']) {
            _this.value = new Attachment(source.valueAttachment);
        }
        else if (source['valueCoding']) {
            _this.value = new Coding(source.valueCoding);
        }
        else if (source['valueQuantity']) {
            _this.value = new Quantity(source.valueQuantity);
        }
        else if (source['valueReference']) {
            _this.value = new Reference(source.valueReference);
        }
        else {
            _this.value = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    QuestionnaireItemInitial.prototype.doModelValidation = function () {
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value: fhir: Questionnaire.item.initial.value[x]:', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    QuestionnaireItemInitial._fts_dataType = 'QuestionnaireItemInitial';
    /**
     * Internal flag to properly serialize choice-type element Questionnaire.item.initial.value[x]
     */
    QuestionnaireItemInitial._fts_valueIsChoice = true;
    return QuestionnaireItemInitial;
}(BackboneElement));
/**
 * The content of the questionnaire is constructed from an ordered, hierarchical collection of items.
 */
var QuestionnaireItem = /** @class */ (function (_super) {
    __extends(QuestionnaireItem$1, _super);
    /**
     * Default constructor for QuestionnaireItem - initializes any required elements to null if a value is not provided.
     */
    function QuestionnaireItem$1(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['linkId']) {
            _this.linkId = new FhirString({ value: source.linkId });
        }
        else {
            _this.linkId = null;
        }
        if (source['definition']) {
            _this.definition = new FhirUri({ value: source.definition });
        }
        if (source['code']) {
            _this.code = source.code.map(function (x) { return new Coding(x); });
        }
        else {
            _this.code = [];
        }
        if (source['prefix']) {
            _this.prefix = new FhirString({ value: source.prefix });
        }
        if (source['text']) {
            _this.text = new FhirString({ value: source.text });
        }
        if (source['type']) {
            _this.type = source.type;
        }
        else {
            _this.type = null;
        }
        if (source['enableWhen']) {
            _this.enableWhen = source.enableWhen.map(function (x) { return new QuestionnaireItemEnableWhen(x); });
        }
        else {
            _this.enableWhen = [];
        }
        if (source['enableBehavior']) {
            _this.enableBehavior = source.enableBehavior;
        }
        if (source['required']) {
            _this.required = new FhirBoolean({ value: source.required });
        }
        if (source['repeats']) {
            _this.repeats = new FhirBoolean({ value: source.repeats });
        }
        if (source['readOnly']) {
            _this.readOnly = new FhirBoolean({ value: source.readOnly });
        }
        if (source['maxLength']) {
            _this.maxLength = new FhirInteger({ value: source.maxLength });
        }
        if (source['answerValueSet']) {
            _this.answerValueSet = new FhirCanonical({ value: source.answerValueSet });
        }
        if (source['answerOption']) {
            _this.answerOption = source.answerOption.map(function (x) { return new QuestionnaireItemAnswerOption(x); });
        }
        else {
            _this.answerOption = [];
        }
        if (source['initial']) {
            _this.initial = source.initial.map(function (x) { return new QuestionnaireItemInitial(x); });
        }
        else {
            _this.initial = [];
        }
        if (source['item']) {
            _this.item = source.item.map(function (x) { return new QuestionnaireItem(x); });
        }
        else {
            _this.item = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (Questionnaire.item.type)
     */
    QuestionnaireItem$1.typeRequiredCoding = function () {
        return ItemTypeCodings;
    };
    /**
     * Required-bound Value Set for enableBehavior (Questionnaire.item.enableBehavior)
     */
    QuestionnaireItem$1.enableBehaviorRequiredCoding = function () {
        return QuestionnaireEnableBehaviorCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    QuestionnaireItem$1.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['linkId']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property linkId:fhir.FhirString fhir: Questionnaire.item.linkId:string', }));
        }
        if (this["linkId"]) {
            (_a = outcome.issue).push.apply(_a, this.linkId.doModelValidation().issue);
        }
        if (this["definition"]) {
            (_b = outcome.issue).push.apply(_b, this.definition.doModelValidation().issue);
        }
        if (this["code"]) {
            this.code.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["prefix"]) {
            (_c = outcome.issue).push.apply(_c, this.prefix.doModelValidation().issue);
        }
        if (this["text"]) {
            (_d = outcome.issue).push.apply(_d, this.text.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:ItemTypeCodeType fhir: Questionnaire.item.type:code', }));
        }
        if (this["enableWhen"]) {
            this.enableWhen.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["required"]) {
            (_e = outcome.issue).push.apply(_e, this.required.doModelValidation().issue);
        }
        if (this["repeats"]) {
            (_f = outcome.issue).push.apply(_f, this.repeats.doModelValidation().issue);
        }
        if (this["readOnly"]) {
            (_g = outcome.issue).push.apply(_g, this.readOnly.doModelValidation().issue);
        }
        if (this["maxLength"]) {
            (_h = outcome.issue).push.apply(_h, this.maxLength.doModelValidation().issue);
        }
        if (this["answerValueSet"]) {
            (_j = outcome.issue).push.apply(_j, this.answerValueSet.doModelValidation().issue);
        }
        if (this["answerOption"]) {
            this.answerOption.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["initial"]) {
            this.initial.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["item"]) {
            this.item.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    QuestionnaireItem$1._fts_dataType = 'QuestionnaireItem';
    return QuestionnaireItem$1;
}(BackboneElement));
/**
 * A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
 */
var Questionnaire = /** @class */ (function (_super) {
    __extends(Questionnaire, _super);
    /**
     * Default constructor for Questionnaire - initializes any required elements to null if a value is not provided.
     */
    function Questionnaire(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'Questionnaire';
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        if (source['derivedFrom']) {
            _this.derivedFrom = source.derivedFrom.map(function (x) { return new FhirCanonical({ value: x }); });
        }
        else {
            _this.derivedFrom = [];
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['experimental']) {
            _this.experimental = new FhirBoolean({ value: source.experimental });
        }
        if (source['subjectType']) {
            _this.subjectType = source.subjectType.map(function (x) { return new FhirCode({ value: x }); });
        }
        else {
            _this.subjectType = [];
        }
        if (source['date']) {
            _this.date = new FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            _this.publisher = new FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            _this.contact = source.contact.map(function (x) { return new ContactDetail(x); });
        }
        else {
            _this.contact = [];
        }
        if (source['description']) {
            _this.description = new FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            _this.useContext = source.useContext.map(function (x) { return new UsageContext(x); });
        }
        else {
            _this.useContext = [];
        }
        if (source['jurisdiction']) {
            _this.jurisdiction = source.jurisdiction.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.jurisdiction = [];
        }
        if (source['purpose']) {
            _this.purpose = new FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            _this.copyright = new FhirMarkdown({ value: source.copyright });
        }
        if (source['approvalDate']) {
            _this.approvalDate = new FhirDate({ value: source.approvalDate });
        }
        if (source['lastReviewDate']) {
            _this.lastReviewDate = new FhirDate({ value: source.lastReviewDate });
        }
        if (source['effectivePeriod']) {
            _this.effectivePeriod = new Period(source.effectivePeriod);
        }
        if (source['code']) {
            _this.code = source.code.map(function (x) { return new Coding(x); });
        }
        else {
            _this.code = [];
        }
        if (source['item']) {
            _this.item = source.item.map(function (x) { return new QuestionnaireItem(x); });
        }
        else {
            _this.item = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (Questionnaire.status)
     */
    Questionnaire.statusRequiredCoding = function () {
        return PublicationStatusCodings;
    };
    /**
     * Required-bound Value Set for subjectType (Questionnaire.subjectType)
     */
    Questionnaire.subjectTypeRequiredCoding = function () {
        return ResourceTypesCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    Questionnaire.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"Questionnaire" fhir: Questionnaire.resourceType:"Questionnaire"', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["version"]) {
            (_b = outcome.issue).push.apply(_b, this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            (_c = outcome.issue).push.apply(_c, this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            (_d = outcome.issue).push.apply(_d, this.title.doModelValidation().issue);
        }
        if (this["derivedFrom"]) {
            this.derivedFrom.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:PublicationStatusCodeType fhir: Questionnaire.status:code', }));
        }
        if (this["experimental"]) {
            (_e = outcome.issue).push.apply(_e, this.experimental.doModelValidation().issue);
        }
        if (this["subjectType"]) {
            this.subjectType.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["date"]) {
            (_f = outcome.issue).push.apply(_f, this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            (_g = outcome.issue).push.apply(_g, this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["description"]) {
            (_h = outcome.issue).push.apply(_h, this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["purpose"]) {
            (_j = outcome.issue).push.apply(_j, this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            (_k = outcome.issue).push.apply(_k, this.copyright.doModelValidation().issue);
        }
        if (this["approvalDate"]) {
            (_l = outcome.issue).push.apply(_l, this.approvalDate.doModelValidation().issue);
        }
        if (this["lastReviewDate"]) {
            (_m = outcome.issue).push.apply(_m, this.lastReviewDate.doModelValidation().issue);
        }
        if (this["effectivePeriod"]) {
            (_o = outcome.issue).push.apply(_o, this.effectivePeriod.doModelValidation().issue);
        }
        if (this["code"]) {
            this.code.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["item"]) {
            this.item.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    Questionnaire._fts_dataType = 'Questionnaire';
    return Questionnaire;
}(DomainResource));

export { Questionnaire, QuestionnaireItem, QuestionnaireItemAnswerOption, QuestionnaireItemEnableWhen, QuestionnaireItemInitial };
//# sourceMappingURL=Questionnaire.js.map
