/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { UnitsOfTimeCodings } from '../fhirValueSets/UnitsOfTimeCodings.js';
import { DaysOfWeekCodings } from '../fhirValueSets/DaysOfWeekCodings.js';
import { EventTimingCodings } from '../fhirValueSets/EventTimingCodings.js';
import { TimingAbbreviationCodings } from '../fhirValueSets/TimingAbbreviationCodings.js';
import { FhirElement } from './FhirElement.js';
import { BackboneElement } from './BackboneElement.js';
import { Duration } from './Duration.js';
import { Range } from './Range.js';
import { Period } from './Period.js';
import { FhirPositiveInt } from './FhirPositiveInt.js';
import { FhirDecimal } from './FhirDecimal.js';
import { FhirTime } from './FhirTime.js';
import { FhirCode } from './FhirCode.js';
import { FhirUnsignedInt } from './FhirUnsignedInt.js';
import { FhirDateTime } from './FhirDateTime.js';
import { CodeableConcept } from './CodeableConcept.js';

// <auto-generated/>
/**
 * A set of rules that describe when the event is scheduled.
 */
var TimingRepeat = /** @class */ (function (_super) {
    __extends(TimingRepeat, _super);
    /**
     * Default constructor for TimingRepeat - initializes any required elements to null if a value is not provided.
     */
    function TimingRepeat(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['bounds']) {
            _this.bounds = source.bounds;
        }
        else if (source['boundsDuration']) {
            _this.bounds = new Duration(source.boundsDuration);
        }
        else if (source['boundsRange']) {
            _this.bounds = new Range(source.boundsRange);
        }
        else if (source['boundsPeriod']) {
            _this.bounds = new Period(source.boundsPeriod);
        }
        if (source['count']) {
            _this.count = new FhirPositiveInt({ value: source.count });
        }
        if (source['countMax']) {
            _this.countMax = new FhirPositiveInt({ value: source.countMax });
        }
        if (source['duration']) {
            _this.duration = new FhirDecimal({ value: source.duration });
        }
        if (source['durationMax']) {
            _this.durationMax = new FhirDecimal({ value: source.durationMax });
        }
        if (source['durationUnit']) {
            _this.durationUnit = source.durationUnit;
        }
        if (source['frequency']) {
            _this.frequency = new FhirPositiveInt({ value: source.frequency });
        }
        if (source['frequencyMax']) {
            _this.frequencyMax = new FhirPositiveInt({ value: source.frequencyMax });
        }
        if (source['period']) {
            _this.period = new FhirDecimal({ value: source.period });
        }
        if (source['periodMax']) {
            _this.periodMax = new FhirDecimal({ value: source.periodMax });
        }
        if (source['periodUnit']) {
            _this.periodUnit = source.periodUnit;
        }
        if (source['dayOfWeek']) {
            _this.dayOfWeek = source.dayOfWeek.map(function (x) { return x; });
        }
        else {
            _this.dayOfWeek = [];
        }
        if (source['timeOfDay']) {
            _this.timeOfDay = source.timeOfDay.map(function (x) { return new FhirTime({ value: x }); });
        }
        else {
            _this.timeOfDay = [];
        }
        if (source['when']) {
            _this.when = source.when.map(function (x) { return new FhirCode({ value: x }); });
        }
        else {
            _this.when = [];
        }
        if (source['offset']) {
            _this.offset = new FhirUnsignedInt({ value: source.offset });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for durationUnit (Timing.repeat.durationUnit)
     */
    TimingRepeat.durationUnitRequiredCoding = function () {
        return UnitsOfTimeCodings;
    };
    /**
     * Required-bound Value Set for periodUnit (Timing.repeat.periodUnit)
     */
    TimingRepeat.periodUnitRequiredCoding = function () {
        return UnitsOfTimeCodings;
    };
    /**
     * Required-bound Value Set for dayOfWeek (Timing.repeat.dayOfWeek)
     */
    TimingRepeat.dayOfWeekRequiredCoding = function () {
        return DaysOfWeekCodings;
    };
    /**
     * Required-bound Value Set for when (Timing.repeat.when)
     */
    TimingRepeat.whenRequiredCoding = function () {
        return EventTimingCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    TimingRepeat.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["count"]) {
            (_a = outcome.issue).push.apply(_a, this.count.doModelValidation().issue);
        }
        if (this["countMax"]) {
            (_b = outcome.issue).push.apply(_b, this.countMax.doModelValidation().issue);
        }
        if (this["duration"]) {
            (_c = outcome.issue).push.apply(_c, this.duration.doModelValidation().issue);
        }
        if (this["durationMax"]) {
            (_d = outcome.issue).push.apply(_d, this.durationMax.doModelValidation().issue);
        }
        if (this["frequency"]) {
            (_e = outcome.issue).push.apply(_e, this.frequency.doModelValidation().issue);
        }
        if (this["frequencyMax"]) {
            (_f = outcome.issue).push.apply(_f, this.frequencyMax.doModelValidation().issue);
        }
        if (this["period"]) {
            (_g = outcome.issue).push.apply(_g, this.period.doModelValidation().issue);
        }
        if (this["periodMax"]) {
            (_h = outcome.issue).push.apply(_h, this.periodMax.doModelValidation().issue);
        }
        if (this["timeOfDay"]) {
            this.timeOfDay.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["when"]) {
            this.when.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["offset"]) {
            (_j = outcome.issue).push.apply(_j, this.offset.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    TimingRepeat._fts_dataType = 'TimingRepeat';
    /**
     * Internal flag to properly serialize choice-type element Timing.repeat.bounds[x]
     */
    TimingRepeat._fts_boundsIsChoice = true;
    return TimingRepeat;
}(FhirElement));
/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 */
var Timing = /** @class */ (function (_super) {
    __extends(Timing, _super);
    /**
     * Default constructor for Timing - initializes any required elements to null if a value is not provided.
     */
    function Timing(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['event']) {
            _this.event = source.event.map(function (x) { return new FhirDateTime({ value: x }); });
        }
        else {
            _this.event = [];
        }
        if (source['repeat']) {
            _this.repeat = new TimingRepeat(source.repeat);
        }
        if (source['code']) {
            _this.code = new CodeableConcept(source.code);
        }
        return _this;
    }
    /**
     * Preferred-bound Value Set for code (Timing.code)
     */
    Timing.codePreferredCoding = function () {
        return TimingAbbreviationCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    Timing.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["event"]) {
            this.event.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["repeat"]) {
            (_a = outcome.issue).push.apply(_a, this.repeat.doModelValidation().issue);
        }
        if (this["code"]) {
            (_b = outcome.issue).push.apply(_b, this.code.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    Timing._fts_dataType = 'Timing';
    return Timing;
}(BackboneElement));

export { Timing, TimingRepeat };
//# sourceMappingURL=Timing.js.map
