/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { UcumUnitsCodings } from '../fhirValueSets/UcumUnitsCodings.js';
import { ObservationRangeCategoryCodings } from '../fhirValueSets/ObservationRangeCategoryCodings.js';
import { ReferencerangeMeaningCodings } from '../fhirValueSets/ReferencerangeMeaningCodings.js';
import { AdministrativeGenderCodings } from '../fhirValueSets/AdministrativeGenderCodings.js';
import { PermittedDataTypeCodings } from '../fhirValueSets/PermittedDataTypeCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { BackboneElement } from './BackboneElement.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { DomainResource } from './DomainResource.js';
import { CodeableConcept } from './CodeableConcept.js';
import { FhirDecimal } from './FhirDecimal.js';
import { FhirInteger } from './FhirInteger.js';
import { Range } from './Range.js';
import { FhirString } from './FhirString.js';
import { Identifier } from './Identifier.js';
import { FhirBoolean } from './FhirBoolean.js';
import { Reference } from './Reference.js';

// <auto-generated/>
/**
 * Characteristics for quantitative results of this observation.
 */
var ObservationDefinitionQuantitativeDetails = /** @class */ (function (_super) {
    __extends(ObservationDefinitionQuantitativeDetails, _super);
    /**
     * Default constructor for ObservationDefinitionQuantitativeDetails - initializes any required elements to null if a value is not provided.
     */
    function ObservationDefinitionQuantitativeDetails(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['customaryUnit']) {
            _this.customaryUnit = new CodeableConcept(source.customaryUnit);
        }
        if (source['unit']) {
            _this.unit = new CodeableConcept(source.unit);
        }
        if (source['conversionFactor']) {
            _this.conversionFactor = new FhirDecimal({ value: source.conversionFactor });
        }
        if (source['decimalPrecision']) {
            _this.decimalPrecision = new FhirInteger({ value: source.decimalPrecision });
        }
        return _this;
    }
    /**
     * Extensible-bound Value Set for customaryUnit (ObservationDefinition.quantitativeDetails.customaryUnit)
     */
    ObservationDefinitionQuantitativeDetails.customaryUnitExtensibleCoding = function () {
        return UcumUnitsCodings;
    };
    /**
     * Extensible-bound Value Set for unit (ObservationDefinition.quantitativeDetails.unit)
     */
    ObservationDefinitionQuantitativeDetails.unitExtensibleCoding = function () {
        return UcumUnitsCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ObservationDefinitionQuantitativeDetails.prototype.doModelValidation = function () {
        var _a, _b, _c, _d;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["customaryUnit"]) {
            (_a = outcome.issue).push.apply(_a, this.customaryUnit.doModelValidation().issue);
        }
        if (this["unit"]) {
            (_b = outcome.issue).push.apply(_b, this.unit.doModelValidation().issue);
        }
        if (this["conversionFactor"]) {
            (_c = outcome.issue).push.apply(_c, this.conversionFactor.doModelValidation().issue);
        }
        if (this["decimalPrecision"]) {
            (_d = outcome.issue).push.apply(_d, this.decimalPrecision.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ObservationDefinitionQuantitativeDetails._fts_dataType = 'ObservationDefinitionQuantitativeDetails';
    return ObservationDefinitionQuantitativeDetails;
}(BackboneElement));
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
var ObservationDefinitionQualifiedInterval = /** @class */ (function (_super) {
    __extends(ObservationDefinitionQualifiedInterval, _super);
    /**
     * Default constructor for ObservationDefinitionQualifiedInterval - initializes any required elements to null if a value is not provided.
     */
    function ObservationDefinitionQualifiedInterval(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['category']) {
            _this.category = source.category;
        }
        if (source['range']) {
            _this.range = new Range(source.range);
        }
        if (source['context']) {
            _this.context = new CodeableConcept(source.context);
        }
        if (source['appliesTo']) {
            _this.appliesTo = source.appliesTo.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.appliesTo = [];
        }
        if (source['gender']) {
            _this.gender = source.gender;
        }
        if (source['age']) {
            _this.age = new Range(source.age);
        }
        if (source['gestationalAge']) {
            _this.gestationalAge = new Range(source.gestationalAge);
        }
        if (source['condition']) {
            _this.condition = new FhirString({ value: source.condition });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for category (ObservationDefinition.qualifiedInterval.category)
     */
    ObservationDefinitionQualifiedInterval.categoryRequiredCoding = function () {
        return ObservationRangeCategoryCodings;
    };
    /**
     * Extensible-bound Value Set for context (ObservationDefinition.qualifiedInterval.context)
     */
    ObservationDefinitionQualifiedInterval.contextExtensibleCoding = function () {
        return ReferencerangeMeaningCodings;
    };
    /**
     * Required-bound Value Set for gender (ObservationDefinition.qualifiedInterval.gender)
     */
    ObservationDefinitionQualifiedInterval.genderRequiredCoding = function () {
        return AdministrativeGenderCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ObservationDefinitionQualifiedInterval.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["range"]) {
            (_a = outcome.issue).push.apply(_a, this.range.doModelValidation().issue);
        }
        if (this["context"]) {
            (_b = outcome.issue).push.apply(_b, this.context.doModelValidation().issue);
        }
        if (this["appliesTo"]) {
            this.appliesTo.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["age"]) {
            (_c = outcome.issue).push.apply(_c, this.age.doModelValidation().issue);
        }
        if (this["gestationalAge"]) {
            (_d = outcome.issue).push.apply(_d, this.gestationalAge.doModelValidation().issue);
        }
        if (this["condition"]) {
            (_e = outcome.issue).push.apply(_e, this.condition.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ObservationDefinitionQualifiedInterval._fts_dataType = 'ObservationDefinitionQualifiedInterval';
    return ObservationDefinitionQualifiedInterval;
}(BackboneElement));
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
var ObservationDefinition = /** @class */ (function (_super) {
    __extends(ObservationDefinition, _super);
    /**
     * Default constructor for ObservationDefinition - initializes any required elements to null if a value is not provided.
     */
    function ObservationDefinition(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'ObservationDefinition';
        if (source['category']) {
            _this.category = source.category.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.category = [];
        }
        if (source['code']) {
            _this.code = new CodeableConcept(source.code);
        }
        else {
            _this.code = null;
        }
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['permittedDataType']) {
            _this.permittedDataType = source.permittedDataType.map(function (x) { return x; });
        }
        else {
            _this.permittedDataType = [];
        }
        if (source['multipleResultsAllowed']) {
            _this.multipleResultsAllowed = new FhirBoolean({ value: source.multipleResultsAllowed });
        }
        if (source['method']) {
            _this.method = new CodeableConcept(source.method);
        }
        if (source['preferredReportName']) {
            _this.preferredReportName = new FhirString({ value: source.preferredReportName });
        }
        if (source['quantitativeDetails']) {
            _this.quantitativeDetails = new ObservationDefinitionQuantitativeDetails(source.quantitativeDetails);
        }
        if (source['qualifiedInterval']) {
            _this.qualifiedInterval = source.qualifiedInterval.map(function (x) { return new ObservationDefinitionQualifiedInterval(x); });
        }
        else {
            _this.qualifiedInterval = [];
        }
        if (source['validCodedValueSet']) {
            _this.validCodedValueSet = new Reference(source.validCodedValueSet);
        }
        if (source['normalCodedValueSet']) {
            _this.normalCodedValueSet = new Reference(source.normalCodedValueSet);
        }
        if (source['abnormalCodedValueSet']) {
            _this.abnormalCodedValueSet = new Reference(source.abnormalCodedValueSet);
        }
        if (source['criticalCodedValueSet']) {
            _this.criticalCodedValueSet = new Reference(source.criticalCodedValueSet);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for permittedDataType (ObservationDefinition.permittedDataType)
     */
    ObservationDefinition.permittedDataTypeRequiredCoding = function () {
        return PermittedDataTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ObservationDefinition.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"ObservationDefinition" fhir: ObservationDefinition.resourceType:"ObservationDefinition"', }));
        }
        if (this["category"]) {
            this.category.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['code']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property code:fhir.CodeableConcept fhir: ObservationDefinition.code:CodeableConcept', }));
        }
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["multipleResultsAllowed"]) {
            (_b = outcome.issue).push.apply(_b, this.multipleResultsAllowed.doModelValidation().issue);
        }
        if (this["method"]) {
            (_c = outcome.issue).push.apply(_c, this.method.doModelValidation().issue);
        }
        if (this["preferredReportName"]) {
            (_d = outcome.issue).push.apply(_d, this.preferredReportName.doModelValidation().issue);
        }
        if (this["quantitativeDetails"]) {
            (_e = outcome.issue).push.apply(_e, this.quantitativeDetails.doModelValidation().issue);
        }
        if (this["qualifiedInterval"]) {
            this.qualifiedInterval.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["validCodedValueSet"]) {
            (_f = outcome.issue).push.apply(_f, this.validCodedValueSet.doModelValidation().issue);
        }
        if (this["normalCodedValueSet"]) {
            (_g = outcome.issue).push.apply(_g, this.normalCodedValueSet.doModelValidation().issue);
        }
        if (this["abnormalCodedValueSet"]) {
            (_h = outcome.issue).push.apply(_h, this.abnormalCodedValueSet.doModelValidation().issue);
        }
        if (this["criticalCodedValueSet"]) {
            (_j = outcome.issue).push.apply(_j, this.criticalCodedValueSet.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ObservationDefinition._fts_dataType = 'ObservationDefinition';
    return ObservationDefinition;
}(DomainResource));

export { ObservationDefinition, ObservationDefinitionQualifiedInterval, ObservationDefinitionQuantitativeDetails };
//# sourceMappingURL=ObservationDefinition.js.map
