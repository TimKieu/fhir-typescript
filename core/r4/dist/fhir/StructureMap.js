/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { MapModelModeCodings } from '../fhirValueSets/MapModelModeCodings.js';
import { MapInputModeCodings } from '../fhirValueSets/MapInputModeCodings.js';
import { MapSourceListModeCodings } from '../fhirValueSets/MapSourceListModeCodings.js';
import { MapContextTypeCodings } from '../fhirValueSets/MapContextTypeCodings.js';
import { MapTargetListModeCodings } from '../fhirValueSets/MapTargetListModeCodings.js';
import { MapTransformCodings } from '../fhirValueSets/MapTransformCodings.js';
import { MapGroupTypeModeCodings } from '../fhirValueSets/MapGroupTypeModeCodings.js';
import { PublicationStatusCodings } from '../fhirValueSets/PublicationStatusCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirCanonical } from './FhirCanonical.js';
import { FhirString } from './FhirString.js';
import { FhirId } from './FhirId.js';
import { FhirInteger } from './FhirInteger.js';
import { FhirBase64Binary } from './FhirBase64Binary.js';
import { FhirBoolean } from './FhirBoolean.js';
import { FhirCode } from './FhirCode.js';
import { FhirDate } from './FhirDate.js';
import { FhirDateTime } from './FhirDateTime.js';
import { FhirDecimal } from './FhirDecimal.js';
import { FhirInstant } from './FhirInstant.js';
import { FhirMarkdown } from './FhirMarkdown.js';
import { FhirOid } from './FhirOid.js';
import { FhirPositiveInt } from './FhirPositiveInt.js';
import { FhirTime } from './FhirTime.js';
import { FhirUnsignedInt } from './FhirUnsignedInt.js';
import { FhirUri } from './FhirUri.js';
import { FhirUrl } from './FhirUrl.js';
import { FhirUuid } from './FhirUuid.js';
import { Address } from './Address.js';
import { Age } from './Age.js';
import { Annotation } from './Annotation.js';
import { Attachment } from './Attachment.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Coding } from './Coding.js';
import { ContactPoint } from './ContactPoint.js';
import { Count } from './Count.js';
import { Distance } from './Distance.js';
import { Duration } from './Duration.js';
import { HumanName } from './HumanName.js';
import { Identifier } from './Identifier.js';
import { Money } from './Money.js';
import { Period } from './Period.js';
import { Quantity } from './Quantity.js';
import { Range } from './Range.js';
import { Ratio } from './Ratio.js';
import { Reference } from './Reference.js';
import { SampledData } from './SampledData.js';
import { Signature } from './Signature.js';
import { Timing } from './Timing.js';
import { ContactDetail } from './ContactDetail.js';
import { Contributor } from './Contributor.js';
import { DataRequirement } from './DataRequirement.js';
import { Expression } from './Expression.js';
import { ParameterDefinition } from './ParameterDefinition.js';
import { RelatedArtifact } from './RelatedArtifact.js';
import { TriggerDefinition } from './TriggerDefinition.js';
import { UsageContext } from './UsageContext.js';
import { Dosage } from './Dosage.js';
import { Meta } from './Meta.js';

// <auto-generated/>
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
var StructureMapStructure = /** @class */ (function (_super) {
    __extends(StructureMapStructure, _super);
    /**
     * Default constructor for StructureMapStructure - initializes any required elements to null if a value is not provided.
     */
    function StructureMapStructure(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['url']) {
            _this.url = new FhirCanonical({ value: source.url });
        }
        else {
            _this.url = null;
        }
        if (source['mode']) {
            _this.mode = source.mode;
        }
        else {
            _this.mode = null;
        }
        if (source['alias']) {
            _this.alias = new FhirString({ value: source.alias });
        }
        if (source['documentation']) {
            _this.documentation = new FhirString({ value: source.documentation });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for mode (StructureMap.structure.mode)
     */
    StructureMapStructure.modeRequiredCoding = function () {
        return MapModelModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapStructure.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['url']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property url:fhir.FhirCanonical fhir: StructureMap.structure.url:canonical', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (!this['mode']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property mode:MapModelModeCodeType fhir: StructureMap.structure.mode:code', }));
        }
        if (this["alias"]) {
            (_b = outcome.issue).push.apply(_b, this.alias.doModelValidation().issue);
        }
        if (this["documentation"]) {
            (_c = outcome.issue).push.apply(_c, this.documentation.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapStructure._fts_dataType = 'StructureMapStructure';
    return StructureMapStructure;
}(BackboneElement));
/**
 * If no inputs are named, then the entry mappings are type based.
 */
var StructureMapGroupInput = /** @class */ (function (_super) {
    __extends(StructureMapGroupInput, _super);
    /**
     * Default constructor for StructureMapGroupInput - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupInput(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirId({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['type']) {
            _this.type = new FhirString({ value: source.type });
        }
        if (source['mode']) {
            _this.mode = source.mode;
        }
        else {
            _this.mode = null;
        }
        if (source['documentation']) {
            _this.documentation = new FhirString({ value: source.documentation });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for mode (StructureMap.group.input.mode)
     */
    StructureMapGroupInput.modeRequiredCoding = function () {
        return MapInputModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupInput.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirId fhir: StructureMap.group.input.name:id', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (this["type"]) {
            (_b = outcome.issue).push.apply(_b, this.type.doModelValidation().issue);
        }
        if (!this['mode']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property mode:MapInputModeCodeType fhir: StructureMap.group.input.mode:code', }));
        }
        if (this["documentation"]) {
            (_c = outcome.issue).push.apply(_c, this.documentation.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupInput._fts_dataType = 'StructureMapGroupInput';
    return StructureMapGroupInput;
}(BackboneElement));
/**
 * Source inputs to the mapping.
 */
var StructureMapGroupRuleSource = /** @class */ (function (_super) {
    __extends(StructureMapGroupRuleSource, _super);
    /**
     * Default constructor for StructureMapGroupRuleSource - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupRuleSource(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['context']) {
            _this.context = new FhirId({ value: source.context });
        }
        else {
            _this.context = null;
        }
        if (source['min']) {
            _this.min = new FhirInteger({ value: source.min });
        }
        if (source['max']) {
            _this.max = new FhirString({ value: source.max });
        }
        if (source['type']) {
            _this.type = new FhirString({ value: source.type });
        }
        if (source['defaultValue']) {
            _this.defaultValue = source.defaultValue;
        }
        else if (source['defaultValueBase64Binary']) {
            _this.defaultValue = new FhirBase64Binary({ value: source.defaultValueBase64Binary });
        }
        else if (source['defaultValueBoolean']) {
            _this.defaultValue = new FhirBoolean({ value: source.defaultValueBoolean });
        }
        else if (source['defaultValueCanonical']) {
            _this.defaultValue = new FhirCanonical({ value: source.defaultValueCanonical });
        }
        else if (source['defaultValueCode']) {
            _this.defaultValue = new FhirCode({ value: source.defaultValueCode });
        }
        else if (source['defaultValueDate']) {
            _this.defaultValue = new FhirDate({ value: source.defaultValueDate });
        }
        else if (source['defaultValueDateTime']) {
            _this.defaultValue = new FhirDateTime({ value: source.defaultValueDateTime });
        }
        else if (source['defaultValueDecimal']) {
            _this.defaultValue = new FhirDecimal({ value: source.defaultValueDecimal });
        }
        else if (source['defaultValueId']) {
            _this.defaultValue = new FhirId({ value: source.defaultValueId });
        }
        else if (source['defaultValueInstant']) {
            _this.defaultValue = new FhirInstant({ value: source.defaultValueInstant });
        }
        else if (source['defaultValueInteger']) {
            _this.defaultValue = new FhirInteger({ value: source.defaultValueInteger });
        }
        else if (source['defaultValueMarkdown']) {
            _this.defaultValue = new FhirMarkdown({ value: source.defaultValueMarkdown });
        }
        else if (source['defaultValueOid']) {
            _this.defaultValue = new FhirOid({ value: source.defaultValueOid });
        }
        else if (source['defaultValuePositiveInt']) {
            _this.defaultValue = new FhirPositiveInt({ value: source.defaultValuePositiveInt });
        }
        else if (source['defaultValueString']) {
            _this.defaultValue = new FhirString({ value: source.defaultValueString });
        }
        else if (source['defaultValueTime']) {
            _this.defaultValue = new FhirTime({ value: source.defaultValueTime });
        }
        else if (source['defaultValueUnsignedInt']) {
            _this.defaultValue = new FhirUnsignedInt({ value: source.defaultValueUnsignedInt });
        }
        else if (source['defaultValueUri']) {
            _this.defaultValue = new FhirUri({ value: source.defaultValueUri });
        }
        else if (source['defaultValueUrl']) {
            _this.defaultValue = new FhirUrl({ value: source.defaultValueUrl });
        }
        else if (source['defaultValueUuid']) {
            _this.defaultValue = new FhirUuid({ value: source.defaultValueUuid });
        }
        else if (source['defaultValueAddress']) {
            _this.defaultValue = new Address(source.defaultValueAddress);
        }
        else if (source['defaultValueAge']) {
            _this.defaultValue = new Age(source.defaultValueAge);
        }
        else if (source['defaultValueAnnotation']) {
            _this.defaultValue = new Annotation(source.defaultValueAnnotation);
        }
        else if (source['defaultValueAttachment']) {
            _this.defaultValue = new Attachment(source.defaultValueAttachment);
        }
        else if (source['defaultValueCodeableConcept']) {
            _this.defaultValue = new CodeableConcept(source.defaultValueCodeableConcept);
        }
        else if (source['defaultValueCoding']) {
            _this.defaultValue = new Coding(source.defaultValueCoding);
        }
        else if (source['defaultValueContactPoint']) {
            _this.defaultValue = new ContactPoint(source.defaultValueContactPoint);
        }
        else if (source['defaultValueCount']) {
            _this.defaultValue = new Count(source.defaultValueCount);
        }
        else if (source['defaultValueDistance']) {
            _this.defaultValue = new Distance(source.defaultValueDistance);
        }
        else if (source['defaultValueDuration']) {
            _this.defaultValue = new Duration(source.defaultValueDuration);
        }
        else if (source['defaultValueHumanName']) {
            _this.defaultValue = new HumanName(source.defaultValueHumanName);
        }
        else if (source['defaultValueIdentifier']) {
            _this.defaultValue = new Identifier(source.defaultValueIdentifier);
        }
        else if (source['defaultValueMoney']) {
            _this.defaultValue = new Money(source.defaultValueMoney);
        }
        else if (source['defaultValuePeriod']) {
            _this.defaultValue = new Period(source.defaultValuePeriod);
        }
        else if (source['defaultValueQuantity']) {
            _this.defaultValue = new Quantity(source.defaultValueQuantity);
        }
        else if (source['defaultValueRange']) {
            _this.defaultValue = new Range(source.defaultValueRange);
        }
        else if (source['defaultValueRatio']) {
            _this.defaultValue = new Ratio(source.defaultValueRatio);
        }
        else if (source['defaultValueReference']) {
            _this.defaultValue = new Reference(source.defaultValueReference);
        }
        else if (source['defaultValueSampledData']) {
            _this.defaultValue = new SampledData(source.defaultValueSampledData);
        }
        else if (source['defaultValueSignature']) {
            _this.defaultValue = new Signature(source.defaultValueSignature);
        }
        else if (source['defaultValueTiming']) {
            _this.defaultValue = new Timing(source.defaultValueTiming);
        }
        else if (source['defaultValueContactDetail']) {
            _this.defaultValue = new ContactDetail(source.defaultValueContactDetail);
        }
        else if (source['defaultValueContributor']) {
            _this.defaultValue = new Contributor(source.defaultValueContributor);
        }
        else if (source['defaultValueDataRequirement']) {
            _this.defaultValue = new DataRequirement(source.defaultValueDataRequirement);
        }
        else if (source['defaultValueExpression']) {
            _this.defaultValue = new Expression(source.defaultValueExpression);
        }
        else if (source['defaultValueParameterDefinition']) {
            _this.defaultValue = new ParameterDefinition(source.defaultValueParameterDefinition);
        }
        else if (source['defaultValueRelatedArtifact']) {
            _this.defaultValue = new RelatedArtifact(source.defaultValueRelatedArtifact);
        }
        else if (source['defaultValueTriggerDefinition']) {
            _this.defaultValue = new TriggerDefinition(source.defaultValueTriggerDefinition);
        }
        else if (source['defaultValueUsageContext']) {
            _this.defaultValue = new UsageContext(source.defaultValueUsageContext);
        }
        else if (source['defaultValueDosage']) {
            _this.defaultValue = new Dosage(source.defaultValueDosage);
        }
        else if (source['defaultValueMeta']) {
            _this.defaultValue = new Meta(source.defaultValueMeta);
        }
        if (source['element']) {
            _this.element = new FhirString({ value: source.element });
        }
        if (source['listMode']) {
            _this.listMode = source.listMode;
        }
        if (source['variable']) {
            _this.variable = new FhirId({ value: source.variable });
        }
        if (source['condition']) {
            _this.condition = new FhirString({ value: source.condition });
        }
        if (source['check']) {
            _this.check = new FhirString({ value: source.check });
        }
        if (source['logMessage']) {
            _this.logMessage = new FhirString({ value: source.logMessage });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for listMode (StructureMap.group.rule.source.listMode)
     */
    StructureMapGroupRuleSource.listModeRequiredCoding = function () {
        return MapSourceListModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupRuleSource.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['context']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property context:fhir.FhirId fhir: StructureMap.group.rule.source.context:id', }));
        }
        if (this["context"]) {
            (_a = outcome.issue).push.apply(_a, this.context.doModelValidation().issue);
        }
        if (this["min"]) {
            (_b = outcome.issue).push.apply(_b, this.min.doModelValidation().issue);
        }
        if (this["max"]) {
            (_c = outcome.issue).push.apply(_c, this.max.doModelValidation().issue);
        }
        if (this["type"]) {
            (_d = outcome.issue).push.apply(_d, this.type.doModelValidation().issue);
        }
        if (this["element"]) {
            (_e = outcome.issue).push.apply(_e, this.element.doModelValidation().issue);
        }
        if (this["variable"]) {
            (_f = outcome.issue).push.apply(_f, this.variable.doModelValidation().issue);
        }
        if (this["condition"]) {
            (_g = outcome.issue).push.apply(_g, this.condition.doModelValidation().issue);
        }
        if (this["check"]) {
            (_h = outcome.issue).push.apply(_h, this.check.doModelValidation().issue);
        }
        if (this["logMessage"]) {
            (_j = outcome.issue).push.apply(_j, this.logMessage.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupRuleSource._fts_dataType = 'StructureMapGroupRuleSource';
    /**
     * Internal flag to properly serialize choice-type element StructureMap.group.rule.source.defaultValue[x]
     */
    StructureMapGroupRuleSource._fts_defaultValueIsChoice = true;
    return StructureMapGroupRuleSource;
}(BackboneElement));
/**
 * Parameters to the transform.
 */
var StructureMapGroupRuleTargetParameter = /** @class */ (function (_super) {
    __extends(StructureMapGroupRuleTargetParameter, _super);
    /**
     * Default constructor for StructureMapGroupRuleTargetParameter - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupRuleTargetParameter(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['value']) {
            _this.value = source.value;
        }
        else if (source['valueId']) {
            _this.value = new FhirId({ value: source.valueId });
        }
        else if (source['valueString']) {
            _this.value = new FhirString({ value: source.valueString });
        }
        else if (source['valueBoolean']) {
            _this.value = new FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueInteger']) {
            _this.value = new FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueDecimal']) {
            _this.value = new FhirDecimal({ value: source.valueDecimal });
        }
        else {
            _this.value = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupRuleTargetParameter.prototype.doModelValidation = function () {
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value: fhir: StructureMap.group.rule.target.parameter.value[x]:', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupRuleTargetParameter._fts_dataType = 'StructureMapGroupRuleTargetParameter';
    /**
     * Internal flag to properly serialize choice-type element StructureMap.group.rule.target.parameter.value[x]
     */
    StructureMapGroupRuleTargetParameter._fts_valueIsChoice = true;
    return StructureMapGroupRuleTargetParameter;
}(BackboneElement));
/**
 * Content to create because of this mapping rule.
 */
var StructureMapGroupRuleTarget = /** @class */ (function (_super) {
    __extends(StructureMapGroupRuleTarget, _super);
    /**
     * Default constructor for StructureMapGroupRuleTarget - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupRuleTarget(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['context']) {
            _this.context = new FhirId({ value: source.context });
        }
        if (source['contextType']) {
            _this.contextType = source.contextType;
        }
        if (source['element']) {
            _this.element = new FhirString({ value: source.element });
        }
        if (source['variable']) {
            _this.variable = new FhirId({ value: source.variable });
        }
        if (source['listMode']) {
            _this.listMode = source.listMode.map(function (x) { return x; });
        }
        else {
            _this.listMode = [];
        }
        if (source['listRuleId']) {
            _this.listRuleId = new FhirId({ value: source.listRuleId });
        }
        if (source['transform']) {
            _this.transform = source.transform;
        }
        if (source['parameter']) {
            _this.parameter = source.parameter.map(function (x) { return new StructureMapGroupRuleTargetParameter(x); });
        }
        else {
            _this.parameter = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for contextType (StructureMap.group.rule.target.contextType)
     */
    StructureMapGroupRuleTarget.contextTypeRequiredCoding = function () {
        return MapContextTypeCodings;
    };
    /**
     * Required-bound Value Set for listMode (StructureMap.group.rule.target.listMode)
     */
    StructureMapGroupRuleTarget.listModeRequiredCoding = function () {
        return MapTargetListModeCodings;
    };
    /**
     * Required-bound Value Set for transform (StructureMap.group.rule.target.transform)
     */
    StructureMapGroupRuleTarget.transformRequiredCoding = function () {
        return MapTransformCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupRuleTarget.prototype.doModelValidation = function () {
        var _a, _b, _c, _d;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["context"]) {
            (_a = outcome.issue).push.apply(_a, this.context.doModelValidation().issue);
        }
        if (this["element"]) {
            (_b = outcome.issue).push.apply(_b, this.element.doModelValidation().issue);
        }
        if (this["variable"]) {
            (_c = outcome.issue).push.apply(_c, this.variable.doModelValidation().issue);
        }
        if (this["listRuleId"]) {
            (_d = outcome.issue).push.apply(_d, this.listRuleId.doModelValidation().issue);
        }
        if (this["parameter"]) {
            this.parameter.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupRuleTarget._fts_dataType = 'StructureMapGroupRuleTarget';
    return StructureMapGroupRuleTarget;
}(BackboneElement));
/**
 * Which other rules to apply in the context of this rule.
 */
var StructureMapGroupRuleDependent = /** @class */ (function (_super) {
    __extends(StructureMapGroupRuleDependent, _super);
    /**
     * Default constructor for StructureMapGroupRuleDependent - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupRuleDependent(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirId({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['variable']) {
            _this.variable = source.variable.map(function (x) { return new FhirString({ value: x }); });
        }
        else {
            _this.variable = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupRuleDependent.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirId fhir: StructureMap.group.rule.dependent.name:id', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (!this['variable']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string', }));
        }
        else if (!Array.isArray(this.variable)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string', }));
        }
        else if (this.variable.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string', }));
        }
        if (this["variable"]) {
            this.variable.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupRuleDependent._fts_dataType = 'StructureMapGroupRuleDependent';
    return StructureMapGroupRuleDependent;
}(BackboneElement));
/**
 * Transform Rule from source to target.
 */
var StructureMapGroupRule = /** @class */ (function (_super) {
    __extends(StructureMapGroupRule$1, _super);
    /**
     * Default constructor for StructureMapGroupRule - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroupRule$1(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirId({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['source']) {
            _this.source = source.source.map(function (x) { return new StructureMapGroupRuleSource(x); });
        }
        else {
            _this.source = [];
        }
        if (source['target']) {
            _this.target = source.target.map(function (x) { return new StructureMapGroupRuleTarget(x); });
        }
        else {
            _this.target = [];
        }
        if (source['rule']) {
            _this.rule = source.rule.map(function (x) { return new StructureMapGroupRule(x); });
        }
        else {
            _this.rule = [];
        }
        if (source['dependent']) {
            _this.dependent = source.dependent.map(function (x) { return new StructureMapGroupRuleDependent(x); });
        }
        else {
            _this.dependent = [];
        }
        if (source['documentation']) {
            _this.documentation = new FhirString({ value: source.documentation });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroupRule$1.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirId fhir: StructureMap.group.rule.name:id', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (!this['source']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source', }));
        }
        else if (!Array.isArray(this.source)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source', }));
        }
        else if (this.source.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source', }));
        }
        if (this["source"]) {
            this.source.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["target"]) {
            this.target.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["rule"]) {
            this.rule.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["dependent"]) {
            this.dependent.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["documentation"]) {
            (_b = outcome.issue).push.apply(_b, this.documentation.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroupRule$1._fts_dataType = 'StructureMapGroupRule';
    return StructureMapGroupRule$1;
}(BackboneElement));
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
var StructureMapGroup = /** @class */ (function (_super) {
    __extends(StructureMapGroup, _super);
    /**
     * Default constructor for StructureMapGroup - initializes any required elements to null if a value is not provided.
     */
    function StructureMapGroup(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirId({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['extends']) {
            _this.extends = new FhirId({ value: source.extends });
        }
        if (source['typeMode']) {
            _this.typeMode = source.typeMode;
        }
        else {
            _this.typeMode = null;
        }
        if (source['documentation']) {
            _this.documentation = new FhirString({ value: source.documentation });
        }
        if (source['input']) {
            _this.input = source.input.map(function (x) { return new StructureMapGroupInput(x); });
        }
        else {
            _this.input = [];
        }
        if (source['rule']) {
            _this.rule = source.rule.map(function (x) { return new StructureMapGroupRule(x); });
        }
        else {
            _this.rule = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for typeMode (StructureMap.group.typeMode)
     */
    StructureMapGroup.typeModeRequiredCoding = function () {
        return MapGroupTypeModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMapGroup.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirId fhir: StructureMap.group.name:id', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (this["extends"]) {
            (_b = outcome.issue).push.apply(_b, this.extends.doModelValidation().issue);
        }
        if (!this['typeMode']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property typeMode:MapGroupTypeModeCodeType fhir: StructureMap.group.typeMode:code', }));
        }
        if (this["documentation"]) {
            (_c = outcome.issue).push.apply(_c, this.documentation.doModelValidation().issue);
        }
        if (!this['input']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input', }));
        }
        else if (!Array.isArray(this.input)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input', }));
        }
        else if (this.input.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input', }));
        }
        if (this["input"]) {
            this.input.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['rule']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule', }));
        }
        else if (!Array.isArray(this.rule)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule', }));
        }
        else if (this.rule.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule', }));
        }
        if (this["rule"]) {
            this.rule.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMapGroup._fts_dataType = 'StructureMapGroup';
    return StructureMapGroup;
}(BackboneElement));
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
var StructureMap = /** @class */ (function (_super) {
    __extends(StructureMap, _super);
    /**
     * Default constructor for StructureMap - initializes any required elements to null if a value is not provided.
     */
    function StructureMap(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'StructureMap';
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        else {
            _this.url = null;
        }
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['experimental']) {
            _this.experimental = new FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            _this.date = new FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            _this.publisher = new FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            _this.contact = source.contact.map(function (x) { return new ContactDetail(x); });
        }
        else {
            _this.contact = [];
        }
        if (source['description']) {
            _this.description = new FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            _this.useContext = source.useContext.map(function (x) { return new UsageContext(x); });
        }
        else {
            _this.useContext = [];
        }
        if (source['jurisdiction']) {
            _this.jurisdiction = source.jurisdiction.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.jurisdiction = [];
        }
        if (source['purpose']) {
            _this.purpose = new FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            _this.copyright = new FhirMarkdown({ value: source.copyright });
        }
        if (source['structure']) {
            _this.structure = source.structure.map(function (x) { return new StructureMapStructure(x); });
        }
        else {
            _this.structure = [];
        }
        if (source['import']) {
            _this.import = source.import.map(function (x) { return new FhirCanonical({ value: x }); });
        }
        else {
            _this.import = [];
        }
        if (source['group']) {
            _this.group = source.group.map(function (x) { return new StructureMapGroup(x); });
        }
        else {
            _this.group = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (StructureMap.status)
     */
    StructureMap.statusRequiredCoding = function () {
        return PublicationStatusCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    StructureMap.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"StructureMap" fhir: StructureMap.resourceType:"StructureMap"', }));
        }
        if (!this['url']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property url:fhir.FhirUri fhir: StructureMap.url:uri', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["version"]) {
            (_b = outcome.issue).push.apply(_b, this.version.doModelValidation().issue);
        }
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirString fhir: StructureMap.name:string', }));
        }
        if (this["name"]) {
            (_c = outcome.issue).push.apply(_c, this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            (_d = outcome.issue).push.apply(_d, this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:PublicationStatusCodeType fhir: StructureMap.status:code', }));
        }
        if (this["experimental"]) {
            (_e = outcome.issue).push.apply(_e, this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            (_f = outcome.issue).push.apply(_f, this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            (_g = outcome.issue).push.apply(_g, this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["description"]) {
            (_h = outcome.issue).push.apply(_h, this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["purpose"]) {
            (_j = outcome.issue).push.apply(_j, this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            (_k = outcome.issue).push.apply(_k, this.copyright.doModelValidation().issue);
        }
        if (this["structure"]) {
            this.structure.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["import"]) {
            this.import.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (!this['group']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group', }));
        }
        else if (!Array.isArray(this.group)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group', }));
        }
        else if (this.group.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group', }));
        }
        if (this["group"]) {
            this.group.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    StructureMap._fts_dataType = 'StructureMap';
    return StructureMap;
}(DomainResource));

export { StructureMap, StructureMapGroup, StructureMapGroupInput, StructureMapGroupRule, StructureMapGroupRuleDependent, StructureMapGroupRuleSource, StructureMapGroupRuleTarget, StructureMapGroupRuleTargetParameter, StructureMapStructure };
//# sourceMappingURL=StructureMap.js.map
