/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { ConceptMapEquivalenceCodings } from '../fhirValueSets/ConceptMapEquivalenceCodings.js';
import { ConceptmapUnmappedModeCodings } from '../fhirValueSets/ConceptmapUnmappedModeCodings.js';
import { PublicationStatusCodings } from '../fhirValueSets/PublicationStatusCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { BackboneElement } from './BackboneElement.js';
import { DomainResource } from './DomainResource.js';
import { FhirUri } from './FhirUri.js';
import { FhirCanonical } from './FhirCanonical.js';
import { FhirString } from './FhirString.js';
import { FhirCode } from './FhirCode.js';
import { Identifier } from './Identifier.js';
import { FhirBoolean } from './FhirBoolean.js';
import { FhirDateTime } from './FhirDateTime.js';
import { ContactDetail } from './ContactDetail.js';
import { FhirMarkdown } from './FhirMarkdown.js';
import { UsageContext } from './UsageContext.js';
import { CodeableConcept } from './CodeableConcept.js';

// <auto-generated/>
/**
 * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
 */
var ConceptMapGroupElementTargetDependsOn = /** @class */ (function (_super) {
    __extends(ConceptMapGroupElementTargetDependsOn, _super);
    /**
     * Default constructor for ConceptMapGroupElementTargetDependsOn - initializes any required elements to null if a value is not provided.
     */
    function ConceptMapGroupElementTargetDependsOn(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['property']) {
            _this.property = new FhirUri({ value: source.property });
        }
        else {
            _this.property = null;
        }
        if (source['system']) {
            _this.system = new FhirCanonical({ value: source.system });
        }
        if (source['value']) {
            _this.value = new FhirString({ value: source.value });
        }
        else {
            _this.value = null;
        }
        if (source['display']) {
            _this.display = new FhirString({ value: source.display });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMapGroupElementTargetDependsOn.prototype.doModelValidation = function () {
        var _a, _b, _c, _d;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['property']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property property:fhir.FhirUri fhir: ConceptMap.group.element.target.dependsOn.property:uri', }));
        }
        if (this["property"]) {
            (_a = outcome.issue).push.apply(_a, this.property.doModelValidation().issue);
        }
        if (this["system"]) {
            (_b = outcome.issue).push.apply(_b, this.system.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value:fhir.FhirString fhir: ConceptMap.group.element.target.dependsOn.value:string', }));
        }
        if (this["value"]) {
            (_c = outcome.issue).push.apply(_c, this.value.doModelValidation().issue);
        }
        if (this["display"]) {
            (_d = outcome.issue).push.apply(_d, this.display.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMapGroupElementTargetDependsOn._fts_dataType = 'ConceptMapGroupElementTargetDependsOn';
    return ConceptMapGroupElementTargetDependsOn;
}(BackboneElement));
/**
 * Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
 */
var ConceptMapGroupElementTarget = /** @class */ (function (_super) {
    __extends(ConceptMapGroupElementTarget, _super);
    /**
     * Default constructor for ConceptMapGroupElementTarget - initializes any required elements to null if a value is not provided.
     */
    function ConceptMapGroupElementTarget(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = new FhirCode({ value: source.code });
        }
        if (source['display']) {
            _this.display = new FhirString({ value: source.display });
        }
        if (source['equivalence']) {
            _this.equivalence = source.equivalence;
        }
        else {
            _this.equivalence = null;
        }
        if (source['comment']) {
            _this.comment = new FhirString({ value: source.comment });
        }
        if (source['dependsOn']) {
            _this.dependsOn = source.dependsOn.map(function (x) { return new ConceptMapGroupElementTargetDependsOn(x); });
        }
        else {
            _this.dependsOn = [];
        }
        if (source['product']) {
            _this.product = source.product.map(function (x) { return new ConceptMapGroupElementTargetDependsOn(x); });
        }
        else {
            _this.product = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for equivalence (ConceptMap.group.element.target.equivalence)
     */
    ConceptMapGroupElementTarget.equivalenceRequiredCoding = function () {
        return ConceptMapEquivalenceCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMapGroupElementTarget.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            (_b = outcome.issue).push.apply(_b, this.display.doModelValidation().issue);
        }
        if (!this['equivalence']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property equivalence:ConceptMapEquivalenceCodeType fhir: ConceptMap.group.element.target.equivalence:code', }));
        }
        if (this["comment"]) {
            (_c = outcome.issue).push.apply(_c, this.comment.doModelValidation().issue);
        }
        if (this["dependsOn"]) {
            this.dependsOn.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["product"]) {
            this.product.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMapGroupElementTarget._fts_dataType = 'ConceptMapGroupElementTarget';
    return ConceptMapGroupElementTarget;
}(BackboneElement));
/**
 * Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
 */
var ConceptMapGroupElement = /** @class */ (function (_super) {
    __extends(ConceptMapGroupElement, _super);
    /**
     * Default constructor for ConceptMapGroupElement - initializes any required elements to null if a value is not provided.
     */
    function ConceptMapGroupElement(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = new FhirCode({ value: source.code });
        }
        if (source['display']) {
            _this.display = new FhirString({ value: source.display });
        }
        if (source['target']) {
            _this.target = source.target.map(function (x) { return new ConceptMapGroupElementTarget(x); });
        }
        else {
            _this.target = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMapGroupElement.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            (_b = outcome.issue).push.apply(_b, this.display.doModelValidation().issue);
        }
        if (this["target"]) {
            this.target.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMapGroupElement._fts_dataType = 'ConceptMapGroupElement';
    return ConceptMapGroupElement;
}(BackboneElement));
/**
 * This only applies if the source code has a system value that matches the system defined for the group.
 */
var ConceptMapGroupUnmapped = /** @class */ (function (_super) {
    __extends(ConceptMapGroupUnmapped, _super);
    /**
     * Default constructor for ConceptMapGroupUnmapped - initializes any required elements to null if a value is not provided.
     */
    function ConceptMapGroupUnmapped(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['mode']) {
            _this.mode = source.mode;
        }
        else {
            _this.mode = null;
        }
        if (source['code']) {
            _this.code = new FhirCode({ value: source.code });
        }
        if (source['display']) {
            _this.display = new FhirString({ value: source.display });
        }
        if (source['url']) {
            _this.url = new FhirCanonical({ value: source.url });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for mode (ConceptMap.group.unmapped.mode)
     */
    ConceptMapGroupUnmapped.modeRequiredCoding = function () {
        return ConceptmapUnmappedModeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMapGroupUnmapped.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['mode']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property mode:ConceptmapUnmappedModeCodeType fhir: ConceptMap.group.unmapped.mode:code', }));
        }
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            (_b = outcome.issue).push.apply(_b, this.display.doModelValidation().issue);
        }
        if (this["url"]) {
            (_c = outcome.issue).push.apply(_c, this.url.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMapGroupUnmapped._fts_dataType = 'ConceptMapGroupUnmapped';
    return ConceptMapGroupUnmapped;
}(BackboneElement));
/**
 * A group of mappings that all have the same source and target system.
 */
var ConceptMapGroup = /** @class */ (function (_super) {
    __extends(ConceptMapGroup, _super);
    /**
     * Default constructor for ConceptMapGroup - initializes any required elements to null if a value is not provided.
     */
    function ConceptMapGroup(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['source']) {
            _this.source = new FhirUri({ value: source.source });
        }
        if (source['sourceVersion']) {
            _this.sourceVersion = new FhirString({ value: source.sourceVersion });
        }
        if (source['target']) {
            _this.target = new FhirUri({ value: source.target });
        }
        if (source['targetVersion']) {
            _this.targetVersion = new FhirString({ value: source.targetVersion });
        }
        if (source['element']) {
            _this.element = source.element.map(function (x) { return new ConceptMapGroupElement(x); });
        }
        else {
            _this.element = [];
        }
        if (source['unmapped']) {
            _this.unmapped = new ConceptMapGroupUnmapped(source.unmapped);
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMapGroup.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["source"]) {
            (_a = outcome.issue).push.apply(_a, this.source.doModelValidation().issue);
        }
        if (this["sourceVersion"]) {
            (_b = outcome.issue).push.apply(_b, this.sourceVersion.doModelValidation().issue);
        }
        if (this["target"]) {
            (_c = outcome.issue).push.apply(_c, this.target.doModelValidation().issue);
        }
        if (this["targetVersion"]) {
            (_d = outcome.issue).push.apply(_d, this.targetVersion.doModelValidation().issue);
        }
        if (!this['element']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element', }));
        }
        else if (!Array.isArray(this.element)) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue, diagnostics: 'Found scalar in array property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element', }));
        }
        else if (this.element.length === 0) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element', }));
        }
        if (this["element"]) {
            this.element.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["unmapped"]) {
            (_e = outcome.issue).push.apply(_e, this.unmapped.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMapGroup._fts_dataType = 'ConceptMapGroup';
    return ConceptMapGroup;
}(BackboneElement));
/**
 * A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
 */
var ConceptMap = /** @class */ (function (_super) {
    __extends(ConceptMap, _super);
    /**
     * Default constructor for ConceptMap - initializes any required elements to null if a value is not provided.
     */
    function ConceptMap(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'ConceptMap';
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            _this.identifier = new Identifier(source.identifier);
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        if (source['title']) {
            _this.title = new FhirString({ value: source.title });
        }
        if (source['status']) {
            _this.status = source.status;
        }
        else {
            _this.status = null;
        }
        if (source['experimental']) {
            _this.experimental = new FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            _this.date = new FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            _this.publisher = new FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            _this.contact = source.contact.map(function (x) { return new ContactDetail(x); });
        }
        else {
            _this.contact = [];
        }
        if (source['description']) {
            _this.description = new FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            _this.useContext = source.useContext.map(function (x) { return new UsageContext(x); });
        }
        else {
            _this.useContext = [];
        }
        if (source['jurisdiction']) {
            _this.jurisdiction = source.jurisdiction.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.jurisdiction = [];
        }
        if (source['purpose']) {
            _this.purpose = new FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            _this.copyright = new FhirMarkdown({ value: source.copyright });
        }
        if (source['source']) {
            _this.source = source.source;
        }
        else if (source['sourceUri']) {
            _this.source = new FhirUri({ value: source.sourceUri });
        }
        else if (source['sourceCanonical']) {
            _this.source = new FhirCanonical({ value: source.sourceCanonical });
        }
        if (source['target']) {
            _this.target = source.target;
        }
        else if (source['targetUri']) {
            _this.target = new FhirUri({ value: source.targetUri });
        }
        else if (source['targetCanonical']) {
            _this.target = new FhirCanonical({ value: source.targetCanonical });
        }
        if (source['group']) {
            _this.group = source.group.map(function (x) { return new ConceptMapGroup(x); });
        }
        else {
            _this.group = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (ConceptMap.status)
     */
    ConceptMap.statusRequiredCoding = function () {
        return PublicationStatusCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ConceptMap.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"ConceptMap" fhir: ConceptMap.resourceType:"ConceptMap"', }));
        }
        if (this["url"]) {
            (_a = outcome.issue).push.apply(_a, this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            (_b = outcome.issue).push.apply(_b, this.identifier.doModelValidation().issue);
        }
        if (this["version"]) {
            (_c = outcome.issue).push.apply(_c, this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            (_d = outcome.issue).push.apply(_d, this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            (_e = outcome.issue).push.apply(_e, this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property status:PublicationStatusCodeType fhir: ConceptMap.status:code', }));
        }
        if (this["experimental"]) {
            (_f = outcome.issue).push.apply(_f, this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            (_g = outcome.issue).push.apply(_g, this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            (_h = outcome.issue).push.apply(_h, this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["description"]) {
            (_j = outcome.issue).push.apply(_j, this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["purpose"]) {
            (_k = outcome.issue).push.apply(_k, this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            (_l = outcome.issue).push.apply(_l, this.copyright.doModelValidation().issue);
        }
        if (this["group"]) {
            this.group.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ConceptMap._fts_dataType = 'ConceptMap';
    /**
     * Internal flag to properly serialize choice-type element ConceptMap.source[x]
     */
    ConceptMap._fts_sourceIsChoice = true;
    /**
     * Internal flag to properly serialize choice-type element ConceptMap.target[x]
     */
    ConceptMap._fts_targetIsChoice = true;
    return ConceptMap;
}(DomainResource));

export { ConceptMap, ConceptMapGroup, ConceptMapGroupElement, ConceptMapGroupElementTarget, ConceptMapGroupElementTargetDependsOn, ConceptMapGroupUnmapped };
//# sourceMappingURL=ConceptMap.js.map
