/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { DiscriminatorTypeCodings } from '../fhirValueSets/DiscriminatorTypeCodings.js';
import { ResourceSlicingRulesCodings } from '../fhirValueSets/ResourceSlicingRulesCodings.js';
import { DefinedTypesCodings } from '../fhirValueSets/DefinedTypesCodings.js';
import { ResourceAggregationModeCodings } from '../fhirValueSets/ResourceAggregationModeCodings.js';
import { ReferenceVersionRulesCodings } from '../fhirValueSets/ReferenceVersionRulesCodings.js';
import { ConstraintSeverityCodings } from '../fhirValueSets/ConstraintSeverityCodings.js';
import { BindingStrengthCodings } from '../fhirValueSets/BindingStrengthCodings.js';
import { PropertyRepresentationCodings } from '../fhirValueSets/PropertyRepresentationCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { FhirElement } from './FhirElement.js';
import { BackboneElement } from './BackboneElement.js';
import { FhirString } from './FhirString.js';
import { FhirBoolean } from './FhirBoolean.js';
import { FhirUnsignedInt } from './FhirUnsignedInt.js';
import { FhirUri } from './FhirUri.js';
import { FhirCanonical } from './FhirCanonical.js';
import { FhirBase64Binary } from './FhirBase64Binary.js';
import { FhirCode } from './FhirCode.js';
import { FhirDate } from './FhirDate.js';
import { FhirDateTime } from './FhirDateTime.js';
import { FhirDecimal } from './FhirDecimal.js';
import { FhirId } from './FhirId.js';
import { FhirInstant } from './FhirInstant.js';
import { FhirInteger } from './FhirInteger.js';
import { FhirMarkdown } from './FhirMarkdown.js';
import { FhirOid } from './FhirOid.js';
import { FhirPositiveInt } from './FhirPositiveInt.js';
import { FhirTime } from './FhirTime.js';
import { FhirUrl } from './FhirUrl.js';
import { FhirUuid } from './FhirUuid.js';
import { Address } from './Address.js';
import { Age } from './Age.js';
import { Annotation } from './Annotation.js';
import { Attachment } from './Attachment.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Coding } from './Coding.js';
import { ContactPoint } from './ContactPoint.js';
import { Count } from './Count.js';
import { Distance } from './Distance.js';
import { Duration } from './Duration.js';
import { HumanName } from './HumanName.js';
import { Identifier } from './Identifier.js';
import { Money } from './Money.js';
import { Period } from './Period.js';
import { Quantity } from './Quantity.js';
import { Range } from './Range.js';
import { Ratio } from './Ratio.js';
import { Reference } from './Reference.js';
import { SampledData } from './SampledData.js';
import { Signature } from './Signature.js';
import { Timing } from './Timing.js';
import { ContactDetail } from './ContactDetail.js';
import { Contributor } from './Contributor.js';
import { DataRequirement } from './DataRequirement.js';
import { Expression } from './Expression.js';
import { ParameterDefinition } from './ParameterDefinition.js';
import { RelatedArtifact } from './RelatedArtifact.js';
import { TriggerDefinition } from './TriggerDefinition.js';
import { UsageContext } from './UsageContext.js';
import { Dosage } from './Dosage.js';
import { Meta } from './Meta.js';

// <auto-generated/>
/**
 * If there is no discriminator, the content is hard to process, so this should be avoided.
 */
var ElementDefinitionSlicingDiscriminator = /** @class */ (function (_super) {
    __extends(ElementDefinitionSlicingDiscriminator, _super);
    /**
     * Default constructor for ElementDefinitionSlicingDiscriminator - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionSlicingDiscriminator(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = source.type;
        }
        else {
            _this.type = null;
        }
        if (source['path']) {
            _this.path = new FhirString({ value: source.path });
        }
        else {
            _this.path = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (ElementDefinition.slicing.discriminator.type)
     */
    ElementDefinitionSlicingDiscriminator.typeRequiredCoding = function () {
        return DiscriminatorTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionSlicingDiscriminator.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:DiscriminatorTypeCodeType fhir: ElementDefinition.slicing.discriminator.type:code', }));
        }
        if (!this['path']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property path:fhir.FhirString fhir: ElementDefinition.slicing.discriminator.path:string', }));
        }
        if (this["path"]) {
            (_a = outcome.issue).push.apply(_a, this.path.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionSlicingDiscriminator._fts_dataType = 'ElementDefinitionSlicingDiscriminator';
    return ElementDefinitionSlicingDiscriminator;
}(FhirElement));
/**
 * The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
 */
var ElementDefinitionSlicing = /** @class */ (function (_super) {
    __extends(ElementDefinitionSlicing, _super);
    /**
     * Default constructor for ElementDefinitionSlicing - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionSlicing(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['discriminator']) {
            _this.discriminator = source.discriminator.map(function (x) { return new ElementDefinitionSlicingDiscriminator(x); });
        }
        else {
            _this.discriminator = [];
        }
        if (source['description']) {
            _this.description = new FhirString({ value: source.description });
        }
        if (source['ordered']) {
            _this.ordered = new FhirBoolean({ value: source.ordered });
        }
        if (source['rules']) {
            _this.rules = source.rules;
        }
        else {
            _this.rules = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for rules (ElementDefinition.slicing.rules)
     */
    ElementDefinitionSlicing.rulesRequiredCoding = function () {
        return ResourceSlicingRulesCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionSlicing.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["discriminator"]) {
            this.discriminator.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["description"]) {
            (_a = outcome.issue).push.apply(_a, this.description.doModelValidation().issue);
        }
        if (this["ordered"]) {
            (_b = outcome.issue).push.apply(_b, this.ordered.doModelValidation().issue);
        }
        if (!this['rules']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property rules:ResourceSlicingRulesCodeType fhir: ElementDefinition.slicing.rules:code', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionSlicing._fts_dataType = 'ElementDefinitionSlicing';
    return ElementDefinitionSlicing;
}(FhirElement));
/**
 * The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
 */
var ElementDefinitionBase = /** @class */ (function (_super) {
    __extends(ElementDefinitionBase, _super);
    /**
     * Default constructor for ElementDefinitionBase - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionBase(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['path']) {
            _this.path = new FhirString({ value: source.path });
        }
        else {
            _this.path = null;
        }
        if (source['min']) {
            _this.min = new FhirUnsignedInt({ value: source.min });
        }
        else {
            _this.min = null;
        }
        if (source['max']) {
            _this.max = new FhirString({ value: source.max });
        }
        else {
            _this.max = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionBase.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['path']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property path:fhir.FhirString fhir: ElementDefinition.base.path:string', }));
        }
        if (this["path"]) {
            (_a = outcome.issue).push.apply(_a, this.path.doModelValidation().issue);
        }
        if (!this['min']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property min:fhir.FhirUnsignedInt fhir: ElementDefinition.base.min:unsignedInt', }));
        }
        if (this["min"]) {
            (_b = outcome.issue).push.apply(_b, this.min.doModelValidation().issue);
        }
        if (!this['max']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property max:fhir.FhirString fhir: ElementDefinition.base.max:string', }));
        }
        if (this["max"]) {
            (_c = outcome.issue).push.apply(_c, this.max.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionBase._fts_dataType = 'ElementDefinitionBase';
    return ElementDefinitionBase;
}(FhirElement));
/**
 * The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
 */
var ElementDefinitionType = /** @class */ (function (_super) {
    __extends(ElementDefinitionType, _super);
    /**
     * Default constructor for ElementDefinitionType - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionType(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['code']) {
            _this.code = new FhirUri({ value: source.code });
        }
        else {
            _this.code = null;
        }
        if (source['profile']) {
            _this.profile = source.profile.map(function (x) { return new FhirCanonical({ value: x }); });
        }
        else {
            _this.profile = [];
        }
        if (source['targetProfile']) {
            _this.targetProfile = source.targetProfile.map(function (x) { return new FhirCanonical({ value: x }); });
        }
        else {
            _this.targetProfile = [];
        }
        if (source['aggregation']) {
            _this.aggregation = source.aggregation.map(function (x) { return x; });
        }
        else {
            _this.aggregation = [];
        }
        if (source['versioning']) {
            _this.versioning = source.versioning;
        }
        return _this;
    }
    /**
     * Extensible-bound Value Set for code (ElementDefinition.type.code)
     */
    ElementDefinitionType.codeExtensibleCoding = function () {
        return DefinedTypesCodings;
    };
    /**
     * Required-bound Value Set for aggregation (ElementDefinition.type.aggregation)
     */
    ElementDefinitionType.aggregationRequiredCoding = function () {
        return ResourceAggregationModeCodings;
    };
    /**
     * Required-bound Value Set for versioning (ElementDefinition.type.versioning)
     */
    ElementDefinitionType.versioningRequiredCoding = function () {
        return ReferenceVersionRulesCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionType.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['code']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property code:fhir.FhirUri fhir: ElementDefinition.type.code:uri', }));
        }
        if (this["code"]) {
            (_a = outcome.issue).push.apply(_a, this.code.doModelValidation().issue);
        }
        if (this["profile"]) {
            this.profile.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["targetProfile"]) {
            this.targetProfile.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionType._fts_dataType = 'ElementDefinitionType';
    return ElementDefinitionType;
}(FhirElement));
/**
 * Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
 */
var ElementDefinitionExample = /** @class */ (function (_super) {
    __extends(ElementDefinitionExample, _super);
    /**
     * Default constructor for ElementDefinitionExample - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionExample(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['label']) {
            _this.label = new FhirString({ value: source.label });
        }
        else {
            _this.label = null;
        }
        if (source['value']) {
            _this.value = source.value;
        }
        else if (source['valueBase64Binary']) {
            _this.value = new FhirBase64Binary({ value: source.valueBase64Binary });
        }
        else if (source['valueBoolean']) {
            _this.value = new FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueCanonical']) {
            _this.value = new FhirCanonical({ value: source.valueCanonical });
        }
        else if (source['valueCode']) {
            _this.value = new FhirCode({ value: source.valueCode });
        }
        else if (source['valueDate']) {
            _this.value = new FhirDate({ value: source.valueDate });
        }
        else if (source['valueDateTime']) {
            _this.value = new FhirDateTime({ value: source.valueDateTime });
        }
        else if (source['valueDecimal']) {
            _this.value = new FhirDecimal({ value: source.valueDecimal });
        }
        else if (source['valueId']) {
            _this.value = new FhirId({ value: source.valueId });
        }
        else if (source['valueInstant']) {
            _this.value = new FhirInstant({ value: source.valueInstant });
        }
        else if (source['valueInteger']) {
            _this.value = new FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueMarkdown']) {
            _this.value = new FhirMarkdown({ value: source.valueMarkdown });
        }
        else if (source['valueOid']) {
            _this.value = new FhirOid({ value: source.valueOid });
        }
        else if (source['valuePositiveInt']) {
            _this.value = new FhirPositiveInt({ value: source.valuePositiveInt });
        }
        else if (source['valueString']) {
            _this.value = new FhirString({ value: source.valueString });
        }
        else if (source['valueTime']) {
            _this.value = new FhirTime({ value: source.valueTime });
        }
        else if (source['valueUnsignedInt']) {
            _this.value = new FhirUnsignedInt({ value: source.valueUnsignedInt });
        }
        else if (source['valueUri']) {
            _this.value = new FhirUri({ value: source.valueUri });
        }
        else if (source['valueUrl']) {
            _this.value = new FhirUrl({ value: source.valueUrl });
        }
        else if (source['valueUuid']) {
            _this.value = new FhirUuid({ value: source.valueUuid });
        }
        else if (source['valueAddress']) {
            _this.value = new Address(source.valueAddress);
        }
        else if (source['valueAge']) {
            _this.value = new Age(source.valueAge);
        }
        else if (source['valueAnnotation']) {
            _this.value = new Annotation(source.valueAnnotation);
        }
        else if (source['valueAttachment']) {
            _this.value = new Attachment(source.valueAttachment);
        }
        else if (source['valueCodeableConcept']) {
            _this.value = new CodeableConcept(source.valueCodeableConcept);
        }
        else if (source['valueCoding']) {
            _this.value = new Coding(source.valueCoding);
        }
        else if (source['valueContactPoint']) {
            _this.value = new ContactPoint(source.valueContactPoint);
        }
        else if (source['valueCount']) {
            _this.value = new Count(source.valueCount);
        }
        else if (source['valueDistance']) {
            _this.value = new Distance(source.valueDistance);
        }
        else if (source['valueDuration']) {
            _this.value = new Duration(source.valueDuration);
        }
        else if (source['valueHumanName']) {
            _this.value = new HumanName(source.valueHumanName);
        }
        else if (source['valueIdentifier']) {
            _this.value = new Identifier(source.valueIdentifier);
        }
        else if (source['valueMoney']) {
            _this.value = new Money(source.valueMoney);
        }
        else if (source['valuePeriod']) {
            _this.value = new Period(source.valuePeriod);
        }
        else if (source['valueQuantity']) {
            _this.value = new Quantity(source.valueQuantity);
        }
        else if (source['valueRange']) {
            _this.value = new Range(source.valueRange);
        }
        else if (source['valueRatio']) {
            _this.value = new Ratio(source.valueRatio);
        }
        else if (source['valueReference']) {
            _this.value = new Reference(source.valueReference);
        }
        else if (source['valueSampledData']) {
            _this.value = new SampledData(source.valueSampledData);
        }
        else if (source['valueSignature']) {
            _this.value = new Signature(source.valueSignature);
        }
        else if (source['valueTiming']) {
            _this.value = new Timing(source.valueTiming);
        }
        else if (source['valueContactDetail']) {
            _this.value = new ContactDetail(source.valueContactDetail);
        }
        else if (source['valueContributor']) {
            _this.value = new Contributor(source.valueContributor);
        }
        else if (source['valueDataRequirement']) {
            _this.value = new DataRequirement(source.valueDataRequirement);
        }
        else if (source['valueExpression']) {
            _this.value = new Expression(source.valueExpression);
        }
        else if (source['valueParameterDefinition']) {
            _this.value = new ParameterDefinition(source.valueParameterDefinition);
        }
        else if (source['valueRelatedArtifact']) {
            _this.value = new RelatedArtifact(source.valueRelatedArtifact);
        }
        else if (source['valueTriggerDefinition']) {
            _this.value = new TriggerDefinition(source.valueTriggerDefinition);
        }
        else if (source['valueUsageContext']) {
            _this.value = new UsageContext(source.valueUsageContext);
        }
        else if (source['valueDosage']) {
            _this.value = new Dosage(source.valueDosage);
        }
        else if (source['valueMeta']) {
            _this.value = new Meta(source.valueMeta);
        }
        else {
            _this.value = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionExample.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['label']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property label:fhir.FhirString fhir: ElementDefinition.example.label:string', }));
        }
        if (this["label"]) {
            (_a = outcome.issue).push.apply(_a, this.label.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value: fhir: ElementDefinition.example.value[x]:', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionExample._fts_dataType = 'ElementDefinitionExample';
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.example.value[x]
     */
    ElementDefinitionExample._fts_valueIsChoice = true;
    return ElementDefinitionExample;
}(FhirElement));
/**
 * Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
 */
var ElementDefinitionConstraint = /** @class */ (function (_super) {
    __extends(ElementDefinitionConstraint, _super);
    /**
     * Default constructor for ElementDefinitionConstraint - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionConstraint(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['key']) {
            _this.key = new FhirId({ value: source.key });
        }
        else {
            _this.key = null;
        }
        if (source['requirements']) {
            _this.requirements = new FhirString({ value: source.requirements });
        }
        if (source['severity']) {
            _this.severity = source.severity;
        }
        else {
            _this.severity = null;
        }
        if (source['human']) {
            _this.human = new FhirString({ value: source.human });
        }
        else {
            _this.human = null;
        }
        if (source['expression']) {
            _this.expression = new FhirString({ value: source.expression });
        }
        if (source['xpath']) {
            _this.xpath = new FhirString({ value: source.xpath });
        }
        if (source['source']) {
            _this.source = new FhirCanonical({ value: source.source });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for severity (ElementDefinition.constraint.severity)
     */
    ElementDefinitionConstraint.severityRequiredCoding = function () {
        return ConstraintSeverityCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionConstraint.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['key']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property key:fhir.FhirId fhir: ElementDefinition.constraint.key:id', }));
        }
        if (this["key"]) {
            (_a = outcome.issue).push.apply(_a, this.key.doModelValidation().issue);
        }
        if (this["requirements"]) {
            (_b = outcome.issue).push.apply(_b, this.requirements.doModelValidation().issue);
        }
        if (!this['severity']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property severity:ConstraintSeverityCodeType fhir: ElementDefinition.constraint.severity:code', }));
        }
        if (!this['human']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property human:fhir.FhirString fhir: ElementDefinition.constraint.human:string', }));
        }
        if (this["human"]) {
            (_c = outcome.issue).push.apply(_c, this.human.doModelValidation().issue);
        }
        if (this["expression"]) {
            (_d = outcome.issue).push.apply(_d, this.expression.doModelValidation().issue);
        }
        if (this["xpath"]) {
            (_e = outcome.issue).push.apply(_e, this.xpath.doModelValidation().issue);
        }
        if (this["source"]) {
            (_f = outcome.issue).push.apply(_f, this.source.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionConstraint._fts_dataType = 'ElementDefinitionConstraint';
    return ElementDefinitionConstraint;
}(FhirElement));
/**
 * For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
 */
var ElementDefinitionBinding = /** @class */ (function (_super) {
    __extends(ElementDefinitionBinding, _super);
    /**
     * Default constructor for ElementDefinitionBinding - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionBinding(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['strength']) {
            _this.strength = source.strength;
        }
        else {
            _this.strength = null;
        }
        if (source['description']) {
            _this.description = new FhirString({ value: source.description });
        }
        if (source['valueSet']) {
            _this.valueSet = new FhirCanonical({ value: source.valueSet });
        }
        return _this;
    }
    /**
     * Required-bound Value Set for strength (ElementDefinition.binding.strength)
     */
    ElementDefinitionBinding.strengthRequiredCoding = function () {
        return BindingStrengthCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionBinding.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['strength']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property strength:BindingStrengthCodeType fhir: ElementDefinition.binding.strength:code', }));
        }
        if (this["description"]) {
            (_a = outcome.issue).push.apply(_a, this.description.doModelValidation().issue);
        }
        if (this["valueSet"]) {
            (_b = outcome.issue).push.apply(_b, this.valueSet.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionBinding._fts_dataType = 'ElementDefinitionBinding';
    return ElementDefinitionBinding;
}(FhirElement));
/**
 * Mappings are not necessarily specific enough for safe translation.
 */
var ElementDefinitionMapping = /** @class */ (function (_super) {
    __extends(ElementDefinitionMapping, _super);
    /**
     * Default constructor for ElementDefinitionMapping - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinitionMapping(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['identity']) {
            _this.identity = new FhirId({ value: source.identity });
        }
        else {
            _this.identity = null;
        }
        if (source['language']) {
            _this.language = new FhirCode({ value: source.language });
        }
        if (source['map']) {
            _this.map = new FhirString({ value: source.map });
        }
        else {
            _this.map = null;
        }
        if (source['comment']) {
            _this.comment = new FhirString({ value: source.comment });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinitionMapping.prototype.doModelValidation = function () {
        var _a, _b, _c, _d;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['identity']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property identity:fhir.FhirId fhir: ElementDefinition.mapping.identity:id', }));
        }
        if (this["identity"]) {
            (_a = outcome.issue).push.apply(_a, this.identity.doModelValidation().issue);
        }
        if (this["language"]) {
            (_b = outcome.issue).push.apply(_b, this.language.doModelValidation().issue);
        }
        if (!this['map']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property map:fhir.FhirString fhir: ElementDefinition.mapping.map:string', }));
        }
        if (this["map"]) {
            (_c = outcome.issue).push.apply(_c, this.map.doModelValidation().issue);
        }
        if (this["comment"]) {
            (_d = outcome.issue).push.apply(_d, this.comment.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinitionMapping._fts_dataType = 'ElementDefinitionMapping';
    return ElementDefinitionMapping;
}(FhirElement));
/**
 * Captures constraints on each element within the resource, profile, or extension.
 */
var ElementDefinition = /** @class */ (function (_super) {
    __extends(ElementDefinition, _super);
    /**
     * Default constructor for ElementDefinition - initializes any required elements to null if a value is not provided.
     */
    function ElementDefinition(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['path']) {
            _this.path = new FhirString({ value: source.path });
        }
        else {
            _this.path = null;
        }
        if (source['representation']) {
            _this.representation = source.representation.map(function (x) { return x; });
        }
        else {
            _this.representation = [];
        }
        if (source['sliceName']) {
            _this.sliceName = new FhirString({ value: source.sliceName });
        }
        if (source['sliceIsConstraining']) {
            _this.sliceIsConstraining = new FhirBoolean({ value: source.sliceIsConstraining });
        }
        if (source['label']) {
            _this.label = new FhirString({ value: source.label });
        }
        if (source['code']) {
            _this.code = source.code.map(function (x) { return new Coding(x); });
        }
        else {
            _this.code = [];
        }
        if (source['slicing']) {
            _this.slicing = new ElementDefinitionSlicing(source.slicing);
        }
        if (source['short']) {
            _this.short = new FhirString({ value: source.short });
        }
        if (source['definition']) {
            _this.definition = new FhirMarkdown({ value: source.definition });
        }
        if (source['comment']) {
            _this.comment = new FhirMarkdown({ value: source.comment });
        }
        if (source['requirements']) {
            _this.requirements = new FhirMarkdown({ value: source.requirements });
        }
        if (source['alias']) {
            _this.alias = source.alias.map(function (x) { return new FhirString({ value: x }); });
        }
        else {
            _this.alias = [];
        }
        if (source['min']) {
            _this.min = new FhirUnsignedInt({ value: source.min });
        }
        if (source['max']) {
            _this.max = new FhirString({ value: source.max });
        }
        if (source['base']) {
            _this.base = new ElementDefinitionBase(source.base);
        }
        if (source['contentReference']) {
            _this.contentReference = new FhirUri({ value: source.contentReference });
        }
        if (source['type']) {
            _this.type = source.type.map(function (x) { return new ElementDefinitionType(x); });
        }
        else {
            _this.type = [];
        }
        if (source['defaultValue']) {
            _this.defaultValue = source.defaultValue;
        }
        else if (source['defaultValueBase64Binary']) {
            _this.defaultValue = new FhirBase64Binary({ value: source.defaultValueBase64Binary });
        }
        else if (source['defaultValueBoolean']) {
            _this.defaultValue = new FhirBoolean({ value: source.defaultValueBoolean });
        }
        else if (source['defaultValueCanonical']) {
            _this.defaultValue = new FhirCanonical({ value: source.defaultValueCanonical });
        }
        else if (source['defaultValueCode']) {
            _this.defaultValue = new FhirCode({ value: source.defaultValueCode });
        }
        else if (source['defaultValueDate']) {
            _this.defaultValue = new FhirDate({ value: source.defaultValueDate });
        }
        else if (source['defaultValueDateTime']) {
            _this.defaultValue = new FhirDateTime({ value: source.defaultValueDateTime });
        }
        else if (source['defaultValueDecimal']) {
            _this.defaultValue = new FhirDecimal({ value: source.defaultValueDecimal });
        }
        else if (source['defaultValueId']) {
            _this.defaultValue = new FhirId({ value: source.defaultValueId });
        }
        else if (source['defaultValueInstant']) {
            _this.defaultValue = new FhirInstant({ value: source.defaultValueInstant });
        }
        else if (source['defaultValueInteger']) {
            _this.defaultValue = new FhirInteger({ value: source.defaultValueInteger });
        }
        else if (source['defaultValueMarkdown']) {
            _this.defaultValue = new FhirMarkdown({ value: source.defaultValueMarkdown });
        }
        else if (source['defaultValueOid']) {
            _this.defaultValue = new FhirOid({ value: source.defaultValueOid });
        }
        else if (source['defaultValuePositiveInt']) {
            _this.defaultValue = new FhirPositiveInt({ value: source.defaultValuePositiveInt });
        }
        else if (source['defaultValueString']) {
            _this.defaultValue = new FhirString({ value: source.defaultValueString });
        }
        else if (source['defaultValueTime']) {
            _this.defaultValue = new FhirTime({ value: source.defaultValueTime });
        }
        else if (source['defaultValueUnsignedInt']) {
            _this.defaultValue = new FhirUnsignedInt({ value: source.defaultValueUnsignedInt });
        }
        else if (source['defaultValueUri']) {
            _this.defaultValue = new FhirUri({ value: source.defaultValueUri });
        }
        else if (source['defaultValueUrl']) {
            _this.defaultValue = new FhirUrl({ value: source.defaultValueUrl });
        }
        else if (source['defaultValueUuid']) {
            _this.defaultValue = new FhirUuid({ value: source.defaultValueUuid });
        }
        else if (source['defaultValueAddress']) {
            _this.defaultValue = new Address(source.defaultValueAddress);
        }
        else if (source['defaultValueAge']) {
            _this.defaultValue = new Age(source.defaultValueAge);
        }
        else if (source['defaultValueAnnotation']) {
            _this.defaultValue = new Annotation(source.defaultValueAnnotation);
        }
        else if (source['defaultValueAttachment']) {
            _this.defaultValue = new Attachment(source.defaultValueAttachment);
        }
        else if (source['defaultValueCodeableConcept']) {
            _this.defaultValue = new CodeableConcept(source.defaultValueCodeableConcept);
        }
        else if (source['defaultValueCoding']) {
            _this.defaultValue = new Coding(source.defaultValueCoding);
        }
        else if (source['defaultValueContactPoint']) {
            _this.defaultValue = new ContactPoint(source.defaultValueContactPoint);
        }
        else if (source['defaultValueCount']) {
            _this.defaultValue = new Count(source.defaultValueCount);
        }
        else if (source['defaultValueDistance']) {
            _this.defaultValue = new Distance(source.defaultValueDistance);
        }
        else if (source['defaultValueDuration']) {
            _this.defaultValue = new Duration(source.defaultValueDuration);
        }
        else if (source['defaultValueHumanName']) {
            _this.defaultValue = new HumanName(source.defaultValueHumanName);
        }
        else if (source['defaultValueIdentifier']) {
            _this.defaultValue = new Identifier(source.defaultValueIdentifier);
        }
        else if (source['defaultValueMoney']) {
            _this.defaultValue = new Money(source.defaultValueMoney);
        }
        else if (source['defaultValuePeriod']) {
            _this.defaultValue = new Period(source.defaultValuePeriod);
        }
        else if (source['defaultValueQuantity']) {
            _this.defaultValue = new Quantity(source.defaultValueQuantity);
        }
        else if (source['defaultValueRange']) {
            _this.defaultValue = new Range(source.defaultValueRange);
        }
        else if (source['defaultValueRatio']) {
            _this.defaultValue = new Ratio(source.defaultValueRatio);
        }
        else if (source['defaultValueReference']) {
            _this.defaultValue = new Reference(source.defaultValueReference);
        }
        else if (source['defaultValueSampledData']) {
            _this.defaultValue = new SampledData(source.defaultValueSampledData);
        }
        else if (source['defaultValueSignature']) {
            _this.defaultValue = new Signature(source.defaultValueSignature);
        }
        else if (source['defaultValueTiming']) {
            _this.defaultValue = new Timing(source.defaultValueTiming);
        }
        else if (source['defaultValueContactDetail']) {
            _this.defaultValue = new ContactDetail(source.defaultValueContactDetail);
        }
        else if (source['defaultValueContributor']) {
            _this.defaultValue = new Contributor(source.defaultValueContributor);
        }
        else if (source['defaultValueDataRequirement']) {
            _this.defaultValue = new DataRequirement(source.defaultValueDataRequirement);
        }
        else if (source['defaultValueExpression']) {
            _this.defaultValue = new Expression(source.defaultValueExpression);
        }
        else if (source['defaultValueParameterDefinition']) {
            _this.defaultValue = new ParameterDefinition(source.defaultValueParameterDefinition);
        }
        else if (source['defaultValueRelatedArtifact']) {
            _this.defaultValue = new RelatedArtifact(source.defaultValueRelatedArtifact);
        }
        else if (source['defaultValueTriggerDefinition']) {
            _this.defaultValue = new TriggerDefinition(source.defaultValueTriggerDefinition);
        }
        else if (source['defaultValueUsageContext']) {
            _this.defaultValue = new UsageContext(source.defaultValueUsageContext);
        }
        else if (source['defaultValueDosage']) {
            _this.defaultValue = new Dosage(source.defaultValueDosage);
        }
        else if (source['defaultValueMeta']) {
            _this.defaultValue = new Meta(source.defaultValueMeta);
        }
        if (source['meaningWhenMissing']) {
            _this.meaningWhenMissing = new FhirMarkdown({ value: source.meaningWhenMissing });
        }
        if (source['orderMeaning']) {
            _this.orderMeaning = new FhirString({ value: source.orderMeaning });
        }
        if (source['fixed']) {
            _this.fixed = source.fixed;
        }
        else if (source['fixedBase64Binary']) {
            _this.fixed = new FhirBase64Binary({ value: source.fixedBase64Binary });
        }
        else if (source['fixedBoolean']) {
            _this.fixed = new FhirBoolean({ value: source.fixedBoolean });
        }
        else if (source['fixedCanonical']) {
            _this.fixed = new FhirCanonical({ value: source.fixedCanonical });
        }
        else if (source['fixedCode']) {
            _this.fixed = new FhirCode({ value: source.fixedCode });
        }
        else if (source['fixedDate']) {
            _this.fixed = new FhirDate({ value: source.fixedDate });
        }
        else if (source['fixedDateTime']) {
            _this.fixed = new FhirDateTime({ value: source.fixedDateTime });
        }
        else if (source['fixedDecimal']) {
            _this.fixed = new FhirDecimal({ value: source.fixedDecimal });
        }
        else if (source['fixedId']) {
            _this.fixed = new FhirId({ value: source.fixedId });
        }
        else if (source['fixedInstant']) {
            _this.fixed = new FhirInstant({ value: source.fixedInstant });
        }
        else if (source['fixedInteger']) {
            _this.fixed = new FhirInteger({ value: source.fixedInteger });
        }
        else if (source['fixedMarkdown']) {
            _this.fixed = new FhirMarkdown({ value: source.fixedMarkdown });
        }
        else if (source['fixedOid']) {
            _this.fixed = new FhirOid({ value: source.fixedOid });
        }
        else if (source['fixedPositiveInt']) {
            _this.fixed = new FhirPositiveInt({ value: source.fixedPositiveInt });
        }
        else if (source['fixedString']) {
            _this.fixed = new FhirString({ value: source.fixedString });
        }
        else if (source['fixedTime']) {
            _this.fixed = new FhirTime({ value: source.fixedTime });
        }
        else if (source['fixedUnsignedInt']) {
            _this.fixed = new FhirUnsignedInt({ value: source.fixedUnsignedInt });
        }
        else if (source['fixedUri']) {
            _this.fixed = new FhirUri({ value: source.fixedUri });
        }
        else if (source['fixedUrl']) {
            _this.fixed = new FhirUrl({ value: source.fixedUrl });
        }
        else if (source['fixedUuid']) {
            _this.fixed = new FhirUuid({ value: source.fixedUuid });
        }
        else if (source['fixedAddress']) {
            _this.fixed = new Address(source.fixedAddress);
        }
        else if (source['fixedAge']) {
            _this.fixed = new Age(source.fixedAge);
        }
        else if (source['fixedAnnotation']) {
            _this.fixed = new Annotation(source.fixedAnnotation);
        }
        else if (source['fixedAttachment']) {
            _this.fixed = new Attachment(source.fixedAttachment);
        }
        else if (source['fixedCodeableConcept']) {
            _this.fixed = new CodeableConcept(source.fixedCodeableConcept);
        }
        else if (source['fixedCoding']) {
            _this.fixed = new Coding(source.fixedCoding);
        }
        else if (source['fixedContactPoint']) {
            _this.fixed = new ContactPoint(source.fixedContactPoint);
        }
        else if (source['fixedCount']) {
            _this.fixed = new Count(source.fixedCount);
        }
        else if (source['fixedDistance']) {
            _this.fixed = new Distance(source.fixedDistance);
        }
        else if (source['fixedDuration']) {
            _this.fixed = new Duration(source.fixedDuration);
        }
        else if (source['fixedHumanName']) {
            _this.fixed = new HumanName(source.fixedHumanName);
        }
        else if (source['fixedIdentifier']) {
            _this.fixed = new Identifier(source.fixedIdentifier);
        }
        else if (source['fixedMoney']) {
            _this.fixed = new Money(source.fixedMoney);
        }
        else if (source['fixedPeriod']) {
            _this.fixed = new Period(source.fixedPeriod);
        }
        else if (source['fixedQuantity']) {
            _this.fixed = new Quantity(source.fixedQuantity);
        }
        else if (source['fixedRange']) {
            _this.fixed = new Range(source.fixedRange);
        }
        else if (source['fixedRatio']) {
            _this.fixed = new Ratio(source.fixedRatio);
        }
        else if (source['fixedReference']) {
            _this.fixed = new Reference(source.fixedReference);
        }
        else if (source['fixedSampledData']) {
            _this.fixed = new SampledData(source.fixedSampledData);
        }
        else if (source['fixedSignature']) {
            _this.fixed = new Signature(source.fixedSignature);
        }
        else if (source['fixedTiming']) {
            _this.fixed = new Timing(source.fixedTiming);
        }
        else if (source['fixedContactDetail']) {
            _this.fixed = new ContactDetail(source.fixedContactDetail);
        }
        else if (source['fixedContributor']) {
            _this.fixed = new Contributor(source.fixedContributor);
        }
        else if (source['fixedDataRequirement']) {
            _this.fixed = new DataRequirement(source.fixedDataRequirement);
        }
        else if (source['fixedExpression']) {
            _this.fixed = new Expression(source.fixedExpression);
        }
        else if (source['fixedParameterDefinition']) {
            _this.fixed = new ParameterDefinition(source.fixedParameterDefinition);
        }
        else if (source['fixedRelatedArtifact']) {
            _this.fixed = new RelatedArtifact(source.fixedRelatedArtifact);
        }
        else if (source['fixedTriggerDefinition']) {
            _this.fixed = new TriggerDefinition(source.fixedTriggerDefinition);
        }
        else if (source['fixedUsageContext']) {
            _this.fixed = new UsageContext(source.fixedUsageContext);
        }
        else if (source['fixedDosage']) {
            _this.fixed = new Dosage(source.fixedDosage);
        }
        else if (source['fixedMeta']) {
            _this.fixed = new Meta(source.fixedMeta);
        }
        if (source['pattern']) {
            _this.pattern = source.pattern;
        }
        else if (source['patternBase64Binary']) {
            _this.pattern = new FhirBase64Binary({ value: source.patternBase64Binary });
        }
        else if (source['patternBoolean']) {
            _this.pattern = new FhirBoolean({ value: source.patternBoolean });
        }
        else if (source['patternCanonical']) {
            _this.pattern = new FhirCanonical({ value: source.patternCanonical });
        }
        else if (source['patternCode']) {
            _this.pattern = new FhirCode({ value: source.patternCode });
        }
        else if (source['patternDate']) {
            _this.pattern = new FhirDate({ value: source.patternDate });
        }
        else if (source['patternDateTime']) {
            _this.pattern = new FhirDateTime({ value: source.patternDateTime });
        }
        else if (source['patternDecimal']) {
            _this.pattern = new FhirDecimal({ value: source.patternDecimal });
        }
        else if (source['patternId']) {
            _this.pattern = new FhirId({ value: source.patternId });
        }
        else if (source['patternInstant']) {
            _this.pattern = new FhirInstant({ value: source.patternInstant });
        }
        else if (source['patternInteger']) {
            _this.pattern = new FhirInteger({ value: source.patternInteger });
        }
        else if (source['patternMarkdown']) {
            _this.pattern = new FhirMarkdown({ value: source.patternMarkdown });
        }
        else if (source['patternOid']) {
            _this.pattern = new FhirOid({ value: source.patternOid });
        }
        else if (source['patternPositiveInt']) {
            _this.pattern = new FhirPositiveInt({ value: source.patternPositiveInt });
        }
        else if (source['patternString']) {
            _this.pattern = new FhirString({ value: source.patternString });
        }
        else if (source['patternTime']) {
            _this.pattern = new FhirTime({ value: source.patternTime });
        }
        else if (source['patternUnsignedInt']) {
            _this.pattern = new FhirUnsignedInt({ value: source.patternUnsignedInt });
        }
        else if (source['patternUri']) {
            _this.pattern = new FhirUri({ value: source.patternUri });
        }
        else if (source['patternUrl']) {
            _this.pattern = new FhirUrl({ value: source.patternUrl });
        }
        else if (source['patternUuid']) {
            _this.pattern = new FhirUuid({ value: source.patternUuid });
        }
        else if (source['patternAddress']) {
            _this.pattern = new Address(source.patternAddress);
        }
        else if (source['patternAge']) {
            _this.pattern = new Age(source.patternAge);
        }
        else if (source['patternAnnotation']) {
            _this.pattern = new Annotation(source.patternAnnotation);
        }
        else if (source['patternAttachment']) {
            _this.pattern = new Attachment(source.patternAttachment);
        }
        else if (source['patternCodeableConcept']) {
            _this.pattern = new CodeableConcept(source.patternCodeableConcept);
        }
        else if (source['patternCoding']) {
            _this.pattern = new Coding(source.patternCoding);
        }
        else if (source['patternContactPoint']) {
            _this.pattern = new ContactPoint(source.patternContactPoint);
        }
        else if (source['patternCount']) {
            _this.pattern = new Count(source.patternCount);
        }
        else if (source['patternDistance']) {
            _this.pattern = new Distance(source.patternDistance);
        }
        else if (source['patternDuration']) {
            _this.pattern = new Duration(source.patternDuration);
        }
        else if (source['patternHumanName']) {
            _this.pattern = new HumanName(source.patternHumanName);
        }
        else if (source['patternIdentifier']) {
            _this.pattern = new Identifier(source.patternIdentifier);
        }
        else if (source['patternMoney']) {
            _this.pattern = new Money(source.patternMoney);
        }
        else if (source['patternPeriod']) {
            _this.pattern = new Period(source.patternPeriod);
        }
        else if (source['patternQuantity']) {
            _this.pattern = new Quantity(source.patternQuantity);
        }
        else if (source['patternRange']) {
            _this.pattern = new Range(source.patternRange);
        }
        else if (source['patternRatio']) {
            _this.pattern = new Ratio(source.patternRatio);
        }
        else if (source['patternReference']) {
            _this.pattern = new Reference(source.patternReference);
        }
        else if (source['patternSampledData']) {
            _this.pattern = new SampledData(source.patternSampledData);
        }
        else if (source['patternSignature']) {
            _this.pattern = new Signature(source.patternSignature);
        }
        else if (source['patternTiming']) {
            _this.pattern = new Timing(source.patternTiming);
        }
        else if (source['patternContactDetail']) {
            _this.pattern = new ContactDetail(source.patternContactDetail);
        }
        else if (source['patternContributor']) {
            _this.pattern = new Contributor(source.patternContributor);
        }
        else if (source['patternDataRequirement']) {
            _this.pattern = new DataRequirement(source.patternDataRequirement);
        }
        else if (source['patternExpression']) {
            _this.pattern = new Expression(source.patternExpression);
        }
        else if (source['patternParameterDefinition']) {
            _this.pattern = new ParameterDefinition(source.patternParameterDefinition);
        }
        else if (source['patternRelatedArtifact']) {
            _this.pattern = new RelatedArtifact(source.patternRelatedArtifact);
        }
        else if (source['patternTriggerDefinition']) {
            _this.pattern = new TriggerDefinition(source.patternTriggerDefinition);
        }
        else if (source['patternUsageContext']) {
            _this.pattern = new UsageContext(source.patternUsageContext);
        }
        else if (source['patternDosage']) {
            _this.pattern = new Dosage(source.patternDosage);
        }
        else if (source['patternMeta']) {
            _this.pattern = new Meta(source.patternMeta);
        }
        if (source['example']) {
            _this.example = source.example.map(function (x) { return new ElementDefinitionExample(x); });
        }
        else {
            _this.example = [];
        }
        if (source['minValue']) {
            _this.minValue = source.minValue;
        }
        else if (source['minValueDate']) {
            _this.minValue = new FhirDate({ value: source.minValueDate });
        }
        else if (source['minValueDateTime']) {
            _this.minValue = new FhirDateTime({ value: source.minValueDateTime });
        }
        else if (source['minValueInstant']) {
            _this.minValue = new FhirInstant({ value: source.minValueInstant });
        }
        else if (source['minValueTime']) {
            _this.minValue = new FhirTime({ value: source.minValueTime });
        }
        else if (source['minValueDecimal']) {
            _this.minValue = new FhirDecimal({ value: source.minValueDecimal });
        }
        else if (source['minValueInteger']) {
            _this.minValue = new FhirInteger({ value: source.minValueInteger });
        }
        else if (source['minValuePositiveInt']) {
            _this.minValue = new FhirPositiveInt({ value: source.minValuePositiveInt });
        }
        else if (source['minValueUnsignedInt']) {
            _this.minValue = new FhirUnsignedInt({ value: source.minValueUnsignedInt });
        }
        else if (source['minValueQuantity']) {
            _this.minValue = new Quantity(source.minValueQuantity);
        }
        if (source['maxValue']) {
            _this.maxValue = source.maxValue;
        }
        else if (source['maxValueDate']) {
            _this.maxValue = new FhirDate({ value: source.maxValueDate });
        }
        else if (source['maxValueDateTime']) {
            _this.maxValue = new FhirDateTime({ value: source.maxValueDateTime });
        }
        else if (source['maxValueInstant']) {
            _this.maxValue = new FhirInstant({ value: source.maxValueInstant });
        }
        else if (source['maxValueTime']) {
            _this.maxValue = new FhirTime({ value: source.maxValueTime });
        }
        else if (source['maxValueDecimal']) {
            _this.maxValue = new FhirDecimal({ value: source.maxValueDecimal });
        }
        else if (source['maxValueInteger']) {
            _this.maxValue = new FhirInteger({ value: source.maxValueInteger });
        }
        else if (source['maxValuePositiveInt']) {
            _this.maxValue = new FhirPositiveInt({ value: source.maxValuePositiveInt });
        }
        else if (source['maxValueUnsignedInt']) {
            _this.maxValue = new FhirUnsignedInt({ value: source.maxValueUnsignedInt });
        }
        else if (source['maxValueQuantity']) {
            _this.maxValue = new Quantity(source.maxValueQuantity);
        }
        if (source['maxLength']) {
            _this.maxLength = new FhirInteger({ value: source.maxLength });
        }
        if (source['condition']) {
            _this.condition = source.condition.map(function (x) { return new FhirId({ value: x }); });
        }
        else {
            _this.condition = [];
        }
        if (source['constraint']) {
            _this.constraint = source.constraint.map(function (x) { return new ElementDefinitionConstraint(x); });
        }
        else {
            _this.constraint = [];
        }
        if (source['mustSupport']) {
            _this.mustSupport = new FhirBoolean({ value: source.mustSupport });
        }
        if (source['isModifier']) {
            _this.isModifier = new FhirBoolean({ value: source.isModifier });
        }
        if (source['isModifierReason']) {
            _this.isModifierReason = new FhirString({ value: source.isModifierReason });
        }
        if (source['isSummary']) {
            _this.isSummary = new FhirBoolean({ value: source.isSummary });
        }
        if (source['binding']) {
            _this.binding = new ElementDefinitionBinding(source.binding);
        }
        if (source['mapping']) {
            _this.mapping = source.mapping.map(function (x) { return new ElementDefinitionMapping(x); });
        }
        else {
            _this.mapping = [];
        }
        return _this;
    }
    /**
     * Required-bound Value Set for representation (ElementDefinition.representation)
     */
    ElementDefinition.representationRequiredCoding = function () {
        return PropertyRepresentationCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    ElementDefinition.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['path']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property path:fhir.FhirString fhir: ElementDefinition.path:string', }));
        }
        if (this["path"]) {
            (_a = outcome.issue).push.apply(_a, this.path.doModelValidation().issue);
        }
        if (this["sliceName"]) {
            (_b = outcome.issue).push.apply(_b, this.sliceName.doModelValidation().issue);
        }
        if (this["sliceIsConstraining"]) {
            (_c = outcome.issue).push.apply(_c, this.sliceIsConstraining.doModelValidation().issue);
        }
        if (this["label"]) {
            (_d = outcome.issue).push.apply(_d, this.label.doModelValidation().issue);
        }
        if (this["code"]) {
            this.code.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["slicing"]) {
            (_e = outcome.issue).push.apply(_e, this.slicing.doModelValidation().issue);
        }
        if (this["short"]) {
            (_f = outcome.issue).push.apply(_f, this.short.doModelValidation().issue);
        }
        if (this["definition"]) {
            (_g = outcome.issue).push.apply(_g, this.definition.doModelValidation().issue);
        }
        if (this["comment"]) {
            (_h = outcome.issue).push.apply(_h, this.comment.doModelValidation().issue);
        }
        if (this["requirements"]) {
            (_j = outcome.issue).push.apply(_j, this.requirements.doModelValidation().issue);
        }
        if (this["alias"]) {
            this.alias.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["min"]) {
            (_k = outcome.issue).push.apply(_k, this.min.doModelValidation().issue);
        }
        if (this["max"]) {
            (_l = outcome.issue).push.apply(_l, this.max.doModelValidation().issue);
        }
        if (this["base"]) {
            (_m = outcome.issue).push.apply(_m, this.base.doModelValidation().issue);
        }
        if (this["contentReference"]) {
            (_o = outcome.issue).push.apply(_o, this.contentReference.doModelValidation().issue);
        }
        if (this["type"]) {
            this.type.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["meaningWhenMissing"]) {
            (_p = outcome.issue).push.apply(_p, this.meaningWhenMissing.doModelValidation().issue);
        }
        if (this["orderMeaning"]) {
            (_q = outcome.issue).push.apply(_q, this.orderMeaning.doModelValidation().issue);
        }
        if (this["example"]) {
            this.example.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["maxLength"]) {
            (_r = outcome.issue).push.apply(_r, this.maxLength.doModelValidation().issue);
        }
        if (this["condition"]) {
            this.condition.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["constraint"]) {
            this.constraint.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["mustSupport"]) {
            (_s = outcome.issue).push.apply(_s, this.mustSupport.doModelValidation().issue);
        }
        if (this["isModifier"]) {
            (_t = outcome.issue).push.apply(_t, this.isModifier.doModelValidation().issue);
        }
        if (this["isModifierReason"]) {
            (_u = outcome.issue).push.apply(_u, this.isModifierReason.doModelValidation().issue);
        }
        if (this["isSummary"]) {
            (_v = outcome.issue).push.apply(_v, this.isSummary.doModelValidation().issue);
        }
        if (this["binding"]) {
            (_w = outcome.issue).push.apply(_w, this.binding.doModelValidation().issue);
        }
        if (this["mapping"]) {
            this.mapping.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    ElementDefinition._fts_dataType = 'ElementDefinition';
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.defaultValue[x]
     */
    ElementDefinition._fts_defaultValueIsChoice = true;
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.fixed[x]
     */
    ElementDefinition._fts_fixedIsChoice = true;
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.pattern[x]
     */
    ElementDefinition._fts_patternIsChoice = true;
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.minValue[x]
     */
    ElementDefinition._fts_minValueIsChoice = true;
    /**
     * Internal flag to properly serialize choice-type element ElementDefinition.maxValue[x]
     */
    ElementDefinition._fts_maxValueIsChoice = true;
    return ElementDefinition;
}(BackboneElement));

export { ElementDefinition, ElementDefinitionBase, ElementDefinitionBinding, ElementDefinitionConstraint, ElementDefinitionExample, ElementDefinitionMapping, ElementDefinitionSlicing, ElementDefinitionSlicingDiscriminator, ElementDefinitionType };
//# sourceMappingURL=ElementDefinition.js.map
