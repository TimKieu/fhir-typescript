/*! @fhir-typescript/r4-core v0.0.11-beta.2 2022-05-18 */
'use strict';
import { __extends } from '../_virtual/_tslib.js';
import { UdiEntryTypeCodings } from '../fhirValueSets/UdiEntryTypeCodings.js';
import { DeviceNametypeCodings } from '../fhirValueSets/DeviceNametypeCodings.js';
import { DeviceStatusCodings } from '../fhirValueSets/DeviceStatusCodings.js';
import { DeviceStatusReasonCodings } from '../fhirValueSets/DeviceStatusReasonCodings.js';
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
import { BackboneElement } from './BackboneElement.js';
import { OperationOutcomeIssue } from './OperationOutcome.js';
import { DomainResource } from './DomainResource.js';
import { FhirString } from './FhirString.js';
import { FhirUri } from './FhirUri.js';
import { FhirBase64Binary } from './FhirBase64Binary.js';
import { CodeableConcept } from './CodeableConcept.js';
import { Identifier } from './Identifier.js';
import { Quantity } from './Quantity.js';
import { Reference } from './Reference.js';
import { FhirDateTime } from './FhirDateTime.js';
import { ContactPoint } from './ContactPoint.js';
import { Annotation } from './Annotation.js';

// <auto-generated/>
/**
 * UDI may identify an unique instance of a device, or it may only identify the type of the device.  See [UDI mappings](device-mappings.html#udi) for a complete mapping of UDI parts to Device.
 */
var DeviceUdiCarrier = /** @class */ (function (_super) {
    __extends(DeviceUdiCarrier, _super);
    /**
     * Default constructor for DeviceUdiCarrier - initializes any required elements to null if a value is not provided.
     */
    function DeviceUdiCarrier(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['deviceIdentifier']) {
            _this.deviceIdentifier = new FhirString({ value: source.deviceIdentifier });
        }
        if (source['issuer']) {
            _this.issuer = new FhirUri({ value: source.issuer });
        }
        if (source['jurisdiction']) {
            _this.jurisdiction = new FhirUri({ value: source.jurisdiction });
        }
        if (source['carrierAIDC']) {
            _this.carrierAIDC = new FhirBase64Binary({ value: source.carrierAIDC });
        }
        if (source['carrierHRF']) {
            _this.carrierHRF = new FhirString({ value: source.carrierHRF });
        }
        if (source['entryType']) {
            _this.entryType = source.entryType;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for entryType (Device.udiCarrier.entryType)
     */
    DeviceUdiCarrier.entryTypeRequiredCoding = function () {
        return UdiEntryTypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    DeviceUdiCarrier.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["deviceIdentifier"]) {
            (_a = outcome.issue).push.apply(_a, this.deviceIdentifier.doModelValidation().issue);
        }
        if (this["issuer"]) {
            (_b = outcome.issue).push.apply(_b, this.issuer.doModelValidation().issue);
        }
        if (this["jurisdiction"]) {
            (_c = outcome.issue).push.apply(_c, this.jurisdiction.doModelValidation().issue);
        }
        if (this["carrierAIDC"]) {
            (_d = outcome.issue).push.apply(_d, this.carrierAIDC.doModelValidation().issue);
        }
        if (this["carrierHRF"]) {
            (_e = outcome.issue).push.apply(_e, this.carrierHRF.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    DeviceUdiCarrier._fts_dataType = 'DeviceUdiCarrier';
    return DeviceUdiCarrier;
}(BackboneElement));
/**
 * This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
 */
var DeviceDeviceName = /** @class */ (function (_super) {
    __extends(DeviceDeviceName, _super);
    /**
     * Default constructor for DeviceDeviceName - initializes any required elements to null if a value is not provided.
     */
    function DeviceDeviceName(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['name']) {
            _this.name = new FhirString({ value: source.name });
        }
        else {
            _this.name = null;
        }
        if (source['type']) {
            _this.type = source.type;
        }
        else {
            _this.type = null;
        }
        return _this;
    }
    /**
     * Required-bound Value Set for type (Device.deviceName.type)
     */
    DeviceDeviceName.typeRequiredCoding = function () {
        return DeviceNametypeCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    DeviceDeviceName.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['name']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property name:fhir.FhirString fhir: Device.deviceName.name:string', }));
        }
        if (this["name"]) {
            (_a = outcome.issue).push.apply(_a, this.name.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:DeviceNametypeCodeType fhir: Device.deviceName.type:code', }));
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    DeviceDeviceName._fts_dataType = 'DeviceDeviceName';
    return DeviceDeviceName;
}(BackboneElement));
/**
 * The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
 */
var DeviceSpecialization = /** @class */ (function (_super) {
    __extends(DeviceSpecialization, _super);
    /**
     * Default constructor for DeviceSpecialization - initializes any required elements to null if a value is not provided.
     */
    function DeviceSpecialization(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['systemType']) {
            _this.systemType = new CodeableConcept(source.systemType);
        }
        else {
            _this.systemType = null;
        }
        if (source['version']) {
            _this.version = new FhirString({ value: source.version });
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    DeviceSpecialization.prototype.doModelValidation = function () {
        var _a, _b;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['systemType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property systemType:fhir.CodeableConcept fhir: Device.specialization.systemType:CodeableConcept', }));
        }
        if (this["systemType"]) {
            (_a = outcome.issue).push.apply(_a, this.systemType.doModelValidation().issue);
        }
        if (this["version"]) {
            (_b = outcome.issue).push.apply(_b, this.version.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    DeviceSpecialization._fts_dataType = 'DeviceSpecialization';
    return DeviceSpecialization;
}(BackboneElement));
/**
 * The actual design of the device or software version running on the device.
 */
var DeviceVersion = /** @class */ (function (_super) {
    __extends(DeviceVersion, _super);
    /**
     * Default constructor for DeviceVersion - initializes any required elements to null if a value is not provided.
     */
    function DeviceVersion(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = new CodeableConcept(source.type);
        }
        if (source['component']) {
            _this.component = new Identifier(source.component);
        }
        if (source['value']) {
            _this.value = new FhirString({ value: source.value });
        }
        else {
            _this.value = null;
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    DeviceVersion.prototype.doModelValidation = function () {
        var _a, _b, _c;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (this["type"]) {
            (_a = outcome.issue).push.apply(_a, this.type.doModelValidation().issue);
        }
        if (this["component"]) {
            (_b = outcome.issue).push.apply(_b, this.component.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property value:fhir.FhirString fhir: Device.version.value:string', }));
        }
        if (this["value"]) {
            (_c = outcome.issue).push.apply(_c, this.value.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    DeviceVersion._fts_dataType = 'DeviceVersion';
    return DeviceVersion;
}(BackboneElement));
/**
 * The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
 */
var DeviceProperty = /** @class */ (function (_super) {
    __extends(DeviceProperty, _super);
    /**
     * Default constructor for DeviceProperty - initializes any required elements to null if a value is not provided.
     */
    function DeviceProperty(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        if (source['type']) {
            _this.type = new CodeableConcept(source.type);
        }
        else {
            _this.type = null;
        }
        if (source['valueQuantity']) {
            _this.valueQuantity = source.valueQuantity.map(function (x) { return new Quantity(x); });
        }
        else {
            _this.valueQuantity = [];
        }
        if (source['valueCode']) {
            _this.valueCode = source.valueCode.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.valueCode = [];
        }
        return _this;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    DeviceProperty.prototype.doModelValidation = function () {
        var _a;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['type']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property type:fhir.CodeableConcept fhir: Device.property.type:CodeableConcept', }));
        }
        if (this["type"]) {
            (_a = outcome.issue).push.apply(_a, this.type.doModelValidation().issue);
        }
        if (this["valueQuantity"]) {
            this.valueQuantity.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["valueCode"]) {
            this.valueCode.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    DeviceProperty._fts_dataType = 'DeviceProperty';
    return DeviceProperty;
}(BackboneElement));
/**
 * A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
 */
var Device = /** @class */ (function (_super) {
    __extends(Device, _super);
    /**
     * Default constructor for Device - initializes any required elements to null if a value is not provided.
     */
    function Device(source, options) {
        if (source === void 0) { source = {}; }
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, source, options) || this;
        _this.resourceType = 'Device';
        if (source['identifier']) {
            _this.identifier = source.identifier.map(function (x) { return new Identifier(x); });
        }
        else {
            _this.identifier = [];
        }
        if (source['definition']) {
            _this.definition = new Reference(source.definition);
        }
        if (source['udiCarrier']) {
            _this.udiCarrier = source.udiCarrier.map(function (x) { return new DeviceUdiCarrier(x); });
        }
        else {
            _this.udiCarrier = [];
        }
        if (source['status']) {
            _this.status = source.status;
        }
        if (source['statusReason']) {
            _this.statusReason = source.statusReason.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.statusReason = [];
        }
        if (source['distinctIdentifier']) {
            _this.distinctIdentifier = new FhirString({ value: source.distinctIdentifier });
        }
        if (source['manufacturer']) {
            _this.manufacturer = new FhirString({ value: source.manufacturer });
        }
        if (source['manufactureDate']) {
            _this.manufactureDate = new FhirDateTime({ value: source.manufactureDate });
        }
        if (source['expirationDate']) {
            _this.expirationDate = new FhirDateTime({ value: source.expirationDate });
        }
        if (source['lotNumber']) {
            _this.lotNumber = new FhirString({ value: source.lotNumber });
        }
        if (source['serialNumber']) {
            _this.serialNumber = new FhirString({ value: source.serialNumber });
        }
        if (source['deviceName']) {
            _this.deviceName = source.deviceName.map(function (x) { return new DeviceDeviceName(x); });
        }
        else {
            _this.deviceName = [];
        }
        if (source['modelNumber']) {
            _this.modelNumber = new FhirString({ value: source.modelNumber });
        }
        if (source['partNumber']) {
            _this.partNumber = new FhirString({ value: source.partNumber });
        }
        if (source['type']) {
            _this.type = new CodeableConcept(source.type);
        }
        if (source['specialization']) {
            _this.specialization = source.specialization.map(function (x) { return new DeviceSpecialization(x); });
        }
        else {
            _this.specialization = [];
        }
        if (source['version']) {
            _this.version = source.version.map(function (x) { return new DeviceVersion(x); });
        }
        else {
            _this.version = [];
        }
        if (source['property']) {
            _this.property = source.property.map(function (x) { return new DeviceProperty(x); });
        }
        else {
            _this.property = [];
        }
        if (source['patient']) {
            _this.patient = new Reference(source.patient);
        }
        if (source['owner']) {
            _this.owner = new Reference(source.owner);
        }
        if (source['contact']) {
            _this.contact = source.contact.map(function (x) { return new ContactPoint(x); });
        }
        else {
            _this.contact = [];
        }
        if (source['location']) {
            _this.location = new Reference(source.location);
        }
        if (source['url']) {
            _this.url = new FhirUri({ value: source.url });
        }
        if (source['note']) {
            _this.note = source.note.map(function (x) { return new Annotation(x); });
        }
        else {
            _this.note = [];
        }
        if (source['safety']) {
            _this.safety = source.safety.map(function (x) { return new CodeableConcept(x); });
        }
        else {
            _this.safety = [];
        }
        if (source['parent']) {
            _this.parent = new Reference(source.parent);
        }
        return _this;
    }
    /**
     * Required-bound Value Set for status (Device.status)
     */
    Device.statusRequiredCoding = function () {
        return DeviceStatusCodings;
    };
    /**
     * Extensible-bound Value Set for statusReason (Device.statusReason)
     */
    Device.statusReasonExtensibleCoding = function () {
        return DeviceStatusReasonCodings;
    };
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    Device.prototype.doModelValidation = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        var outcome = _super.prototype.doModelValidation.call(this);
        if (!this['resourceType']) {
            outcome.issue.push(new OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing, diagnostics: 'Missing required property resourceType:"Device" fhir: Device.resourceType:"Device"', }));
        }
        if (this["identifier"]) {
            this.identifier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["definition"]) {
            (_a = outcome.issue).push.apply(_a, this.definition.doModelValidation().issue);
        }
        if (this["udiCarrier"]) {
            this.udiCarrier.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["statusReason"]) {
            this.statusReason.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["distinctIdentifier"]) {
            (_b = outcome.issue).push.apply(_b, this.distinctIdentifier.doModelValidation().issue);
        }
        if (this["manufacturer"]) {
            (_c = outcome.issue).push.apply(_c, this.manufacturer.doModelValidation().issue);
        }
        if (this["manufactureDate"]) {
            (_d = outcome.issue).push.apply(_d, this.manufactureDate.doModelValidation().issue);
        }
        if (this["expirationDate"]) {
            (_e = outcome.issue).push.apply(_e, this.expirationDate.doModelValidation().issue);
        }
        if (this["lotNumber"]) {
            (_f = outcome.issue).push.apply(_f, this.lotNumber.doModelValidation().issue);
        }
        if (this["serialNumber"]) {
            (_g = outcome.issue).push.apply(_g, this.serialNumber.doModelValidation().issue);
        }
        if (this["deviceName"]) {
            this.deviceName.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["modelNumber"]) {
            (_h = outcome.issue).push.apply(_h, this.modelNumber.doModelValidation().issue);
        }
        if (this["partNumber"]) {
            (_j = outcome.issue).push.apply(_j, this.partNumber.doModelValidation().issue);
        }
        if (this["type"]) {
            (_k = outcome.issue).push.apply(_k, this.type.doModelValidation().issue);
        }
        if (this["specialization"]) {
            this.specialization.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["version"]) {
            this.version.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["property"]) {
            this.property.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["patient"]) {
            (_l = outcome.issue).push.apply(_l, this.patient.doModelValidation().issue);
        }
        if (this["owner"]) {
            (_m = outcome.issue).push.apply(_m, this.owner.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["location"]) {
            (_o = outcome.issue).push.apply(_o, this.location.doModelValidation().issue);
        }
        if (this["url"]) {
            (_p = outcome.issue).push.apply(_p, this.url.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["safety"]) {
            this.safety.forEach(function (x) {
                var _a;
                (_a = outcome.issue).push.apply(_a, x.doModelValidation().issue);
            });
        }
        if (this["parent"]) {
            (_q = outcome.issue).push.apply(_q, this.parent.doModelValidation().issue);
        }
        return outcome;
    };
    /**
     * Mapping of this datatype to a FHIR equivalent
     */
    Device._fts_dataType = 'Device';
    return Device;
}(DomainResource));

export { Device, DeviceDeviceName, DeviceProperty, DeviceSpecialization, DeviceUdiCarrier, DeviceVersion };
//# sourceMappingURL=Device.js.map
