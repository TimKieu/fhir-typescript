// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: HealthcareService

import * as fhir from '../fhir.js';

// @ts-ignore
import { DaysOfWeekCodings, DaysOfWeekCodingType,} from '../fhirValueSets/DaysOfWeekCodings.js';
// @ts-ignore
import { DaysOfWeekCodes,  DaysOfWeekCodeType } from '../fhirValueSets/DaysOfWeekCodes.js';
// @ts-ignore
import { ServiceCategoryCodings, ServiceCategoryCodingType,} from '../fhirValueSets/ServiceCategoryCodings.js';
// @ts-ignore
import { ServiceCategoryCodes,  ServiceCategoryCodeType } from '../fhirValueSets/ServiceCategoryCodes.js';
// @ts-ignore
import { ServiceTypeCodings, ServiceTypeCodingType,} from '../fhirValueSets/ServiceTypeCodings.js';
// @ts-ignore
import { ServiceTypeCodes,  ServiceTypeCodeType } from '../fhirValueSets/ServiceTypeCodes.js';
// @ts-ignore
import { C80PracticeCodings, C80PracticeCodingType,} from '../fhirValueSets/C80PracticeCodings.js';
// @ts-ignore
import { C80PracticeCodes,  C80PracticeCodeType } from '../fhirValueSets/C80PracticeCodes.js';
// @ts-ignore
import { ServiceProvisionConditionsCodings, ServiceProvisionConditionsCodingType,} from '../fhirValueSets/ServiceProvisionConditionsCodings.js';
// @ts-ignore
import { ServiceProvisionConditionsCodes,  ServiceProvisionConditionsCodeType } from '../fhirValueSets/ServiceProvisionConditionsCodes.js';
// @ts-ignore
import { ProgramCodings, ProgramCodingType,} from '../fhirValueSets/ProgramCodings.js';
// @ts-ignore
import { ProgramCodes,  ProgramCodeType } from '../fhirValueSets/ProgramCodes.js';
// @ts-ignore
import { LanguagesCodings, LanguagesCodingType,} from '../fhirValueSets/LanguagesCodings.js';
// @ts-ignore
import { LanguagesCodes,  LanguagesCodeType } from '../fhirValueSets/LanguagesCodes.js';
// @ts-ignore
import { ServiceReferralMethodCodings, ServiceReferralMethodCodingType,} from '../fhirValueSets/ServiceReferralMethodCodings.js';
// @ts-ignore
import { ServiceReferralMethodCodes,  ServiceReferralMethodCodeType } from '../fhirValueSets/ServiceReferralMethodCodes.js';
/**
 * Valid arguments for the HealthcareServiceEligibility type.
 */
export interface HealthcareServiceEligibilityArgs extends fhir.BackboneElementArgs {
  /**
   * Coded value for the eligibility.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * The description of service eligibility should, in general, not exceed one or two paragraphs. It should be sufficient for a prospective consumer to determine if they are likely to be eligible or not. Where eligibility requirements and conditions are complex, it may simply be noted that an eligibility assessment is required. Where eligibility is determined by an outside source, such as an Act of Parliament, this should be noted, preferably with a reference to a commonly available copy of the source document such as a web page.
   */
  comment?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.eligibility.comment
   */
  _comment?:fhir.FhirElementArgs;
}

/**
 * Does this service have specific eligibility requirements that need to be met in order to use the service?
 */
export class HealthcareServiceEligibility extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'HealthcareServiceEligibility';
  /**
   * Coded value for the eligibility.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * The description of service eligibility should, in general, not exceed one or two paragraphs. It should be sufficient for a prospective consumer to determine if they are likely to be eligible or not. Where eligibility requirements and conditions are complex, it may simply be noted that an eligibility assessment is required. Where eligibility is determined by an outside source, such as an Act of Parliament, this should be noted, preferably with a reference to a commonly available copy of the source document such as a web page.
   */
  public comment?: fhir.FhirMarkdown|undefined;
  /**
   * Default constructor for HealthcareServiceEligibility - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<HealthcareServiceEligibilityArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['comment']) { this.comment = new fhir.FhirMarkdown({value: source.comment}); }
    if (source['_comment']) {
      if (this.comment) { this.comment.addExtendedProperties(source._comment!); }
      else { this.comment = new fhir.FhirMarkdown(source._comment as Partial<fhir.FhirMarkdownArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(expression:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(expression);
    if (expression === '') { expression = 'HealthcareService.eligibility' }
    if (this["code"]) { issues.push(...this.code.doModelValidation(expression+'.code')); }
    if (this["comment"]) { issues.push(...this.comment.doModelValidation(expression+'.comment')); }
    return issues;
  }
}
/**
 * Valid arguments for the HealthcareServiceAvailableTime type.
 */
export interface HealthcareServiceAvailableTimeArgs extends fhir.BackboneElementArgs {
  /**
   * Indicates which days of the week are available between the start and end Times.
   */
  daysOfWeek?: fhir.FhirCode<DaysOfWeekCodeType>[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.availableTime.daysOfWeek
   */
  _daysOfWeek?:(fhir.FhirElementArgs|null)[];
  /**
   * Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   */
  allDay?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.availableTime.allDay
   */
  _allDay?:fhir.FhirElementArgs;
  /**
   * The time zone is expected to be for where this HealthcareService is provided at.
   */
  availableStartTime?: fhir.FhirTime|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.availableTime.availableStartTime
   */
  _availableStartTime?:fhir.FhirElementArgs;
  /**
   * The time zone is expected to be for where this HealthcareService is provided at.
   */
  availableEndTime?: fhir.FhirTime|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.availableTime.availableEndTime
   */
  _availableEndTime?:fhir.FhirElementArgs;
}

/**
 * More detailed availability information may be provided in associated Schedule/Slot resources.
 */
export class HealthcareServiceAvailableTime extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'HealthcareServiceAvailableTime';
  /**
   * Indicates which days of the week are available between the start and end Times.
   */
  public daysOfWeek: fhir.FhirCode<DaysOfWeekCodeType>[];
  /**
   * Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   */
  public allDay?: fhir.FhirBoolean|undefined;
  /**
   * The time zone is expected to be for where this HealthcareService is provided at.
   */
  public availableStartTime?: fhir.FhirTime|undefined;
  /**
   * The time zone is expected to be for where this HealthcareService is provided at.
   */
  public availableEndTime?: fhir.FhirTime|undefined;
  /**
   * Default constructor for HealthcareServiceAvailableTime - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<HealthcareServiceAvailableTimeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['daysOfWeek']) { this.daysOfWeek = source.daysOfWeek.map((x) => new fhir.FhirCode<DaysOfWeekCodeType>({value: x})); }
    else { this.daysOfWeek = []; }
    if (source['_daysOfWeek']) {
      source._daysOfWeek.forEach((x,i) => {
        if (this.daysOfWeek.length >= i) { if (x) { this.daysOfWeek[i].addExtendedProperties(x); } }
        else { if (x) { this.daysOfWeek.push(new fhir.FhirCode<DaysOfWeekCodeType>(x as Partial<fhir.FhirCode>)); } }
      });
    }
    if (source['allDay']) { this.allDay = new fhir.FhirBoolean({value: source.allDay}); }
    if (source['_allDay']) {
      if (this.allDay) { this.allDay.addExtendedProperties(source._allDay!); }
      else { this.allDay = new fhir.FhirBoolean(source._allDay as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['availableStartTime']) { this.availableStartTime = new fhir.FhirTime({value: source.availableStartTime}); }
    if (source['_availableStartTime']) {
      if (this.availableStartTime) { this.availableStartTime.addExtendedProperties(source._availableStartTime!); }
      else { this.availableStartTime = new fhir.FhirTime(source._availableStartTime as Partial<fhir.FhirTimeArgs>); }
    }
    if (source['availableEndTime']) { this.availableEndTime = new fhir.FhirTime({value: source.availableEndTime}); }
    if (source['_availableEndTime']) {
      if (this.availableEndTime) { this.availableEndTime.addExtendedProperties(source._availableEndTime!); }
      else { this.availableEndTime = new fhir.FhirTime(source._availableEndTime as Partial<fhir.FhirTimeArgs>); }
    }
  }
  /**
   * Required-bound Value Set for daysOfWeek (HealthcareService.availableTime.daysOfWeek)
   */
  public static get daysOfWeekRequiredCodes() {
    return DaysOfWeekCodes;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(expression:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(expression);
    if (expression === '') { expression = 'HealthcareService.availableTime' }
    if (this['daysOfWeek']) {
      this.daysOfWeek.forEach((v) => {
        if (!Object.values(DaysOfWeekCodes).includes(v.value as any)) {
          issues.push({ severity: 'error', code: 'code-invalid', diagnostics: 'daysOfWeek (HealthcareService.availableTime.daysOfWeek) of type code is missing code for Required binding to: DaysOfWeek', expression: [expression] });
        }
      });
    }
    if (this["daysOfWeek"]) { this.daysOfWeek.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.daysOfWeek[${i}]`)); }) }
    if (this["allDay"]) { issues.push(...this.allDay.doModelValidation(expression+'.allDay')); }
    if (this["availableStartTime"]) { issues.push(...this.availableStartTime.doModelValidation(expression+'.availableStartTime')); }
    if (this["availableEndTime"]) { issues.push(...this.availableEndTime.doModelValidation(expression+'.availableEndTime')); }
    return issues;
  }
}
/**
 * Valid arguments for the HealthcareServiceNotAvailable type.
 */
export interface HealthcareServiceNotAvailableArgs extends fhir.BackboneElementArgs {
  /**
   * The reason that can be presented to the user as to why this time is not available.
   */
  description: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.notAvailable.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Service is not available (seasonally or for a public holiday) from this date.
   */
  during?: fhir.PeriodArgs|undefined;
}

/**
 * The HealthcareService is not available during this period of time due to the provided reason.
 */
export class HealthcareServiceNotAvailable extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'HealthcareServiceNotAvailable';
  /**
   * The reason that can be presented to the user as to why this time is not available.
   */
  public description: fhir.FhirString|null;
  /**
   * Service is not available (seasonally or for a public holiday) from this date.
   */
  public during?: fhir.Period|undefined;
  /**
   * Default constructor for HealthcareServiceNotAvailable - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<HealthcareServiceNotAvailableArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    else { this.description = null; }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['during']) { this.during = new fhir.Period(source.during); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(expression:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(expression);
    if (expression === '') { expression = 'HealthcareService.notAvailable' }
    if (!this['description']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property description fhir: HealthcareService.notAvailable.description:string', expression: [expression] });
    }
    if (this["description"]) { issues.push(...this.description.doModelValidation(expression+'.description')); }
    if (this["during"]) { issues.push(...this.during.doModelValidation(expression+'.during')); }
    return issues;
  }
}
/**
 * Valid arguments for the HealthcareService type.
 */
export interface HealthcareServiceArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "HealthcareService"|undefined;
  /**
   * External identifiers for this item.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   */
  active?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.active
   */
  _active?:fhir.FhirElementArgs;
  /**
   * This property is recommended to be the same as the Location's managingOrganization, and if not provided should be interpreted as such. If the Location does not have a managing Organization, then this property should be populated.
   */
  providedBy?: fhir.ReferenceArgs|undefined;
  /**
   * Selecting a Service Category then determines the list of relevant service types that can be selected in the primary service type.
   */
  category?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The specific type of service that may be delivered or performed.
   */
  type?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Collection of specialties handled by the service site. This is more of a medical term.
   */
  specialty?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The location(s) where this healthcare service may be provided.
   */
  location?: fhir.ReferenceArgs[]|undefined;
  /**
   * Further description of the service as it would be presented to a consumer while searching.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Would expect that a user would not see this information on a search results, and it would only be available when viewing the complete details of the service.
   */
  comment?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.comment
   */
  _comment?:fhir.FhirElementArgs;
  /**
   * Extra details about the service that can't be placed in the other fields.
   */
  extraDetails?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.extraDetails
   */
  _extraDetails?:fhir.FhirElementArgs;
  /**
   * If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
   */
  photo?: fhir.AttachmentArgs|undefined;
  /**
   * If this is empty, then refer to the location's contacts.
   */
  telecom?: fhir.ContactPointArgs[]|undefined;
  /**
   * The locations referenced by the coverage area can include both specific locations, including areas, and also conceptual domains too (mode = kind), such as a physical area (tri-state area) and some other attribute (covered by Example Care Organization). These types of Locations are often not managed by any specific organization. This could also include generic locations such as "in-home".
   */
  coverageArea?: fhir.ReferenceArgs[]|undefined;
  /**
   * The provision means being commissioned by, contractually obliged or financially sourced. Types of costings that may apply to this healthcare service, such if the service may be available for free, some discounts available, or fees apply.
   */
  serviceProvisionCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Does this service have specific eligibility requirements that need to be met in order to use the service?
   */
  eligibility?: fhir.HealthcareServiceEligibilityArgs[]|undefined;
  /**
   * Programs are often defined externally to an Organization, commonly by governments; e.g. Home and Community Care Programs, Homeless Program, ….
   */
  program?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * These could be such things as is wheelchair accessible.
   */
  characteristic?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * When using this property it indicates that the service is available with this language, it is not derived from the practitioners, and not all are required to use this language, just that this language is available while scheduling.
   */
  communication?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
   */
  referralMethod?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
   */
  appointmentRequired?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.appointmentRequired
   */
  _appointmentRequired?:fhir.FhirElementArgs;
  /**
   * More detailed availability information may be provided in associated Schedule/Slot resources.
   */
  availableTime?: fhir.HealthcareServiceAvailableTimeArgs[]|undefined;
  /**
   * The HealthcareService is not available during this period of time due to the provided reason.
   */
  notAvailable?: fhir.HealthcareServiceNotAvailableArgs[]|undefined;
  /**
   * A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   */
  availabilityExceptions?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: HealthcareService.availabilityExceptions
   */
  _availabilityExceptions?:fhir.FhirElementArgs;
  /**
   * Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
   */
  endpoint?: fhir.ReferenceArgs[]|undefined;
}

/**
 * The details of a healthcare service available at a location.
 */
export class HealthcareService extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'HealthcareService';
  /**
   * Resource Type Name
   */
  public override resourceType: "HealthcareService";
  /**
   * External identifiers for this item.
   */
  public identifier: fhir.Identifier[];
  /**
   * This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   */
  public active?: fhir.FhirBoolean|undefined;
  /**
   * This property is recommended to be the same as the Location's managingOrganization, and if not provided should be interpreted as such. If the Location does not have a managing Organization, then this property should be populated.
   */
  public providedBy?: fhir.Reference|undefined;
  /**
   * Selecting a Service Category then determines the list of relevant service types that can be selected in the primary service type.
   */
  public category: fhir.CodeableConcept[];
  /**
   * The specific type of service that may be delivered or performed.
   */
  public type: fhir.CodeableConcept[];
  /**
   * Collection of specialties handled by the service site. This is more of a medical term.
   */
  public specialty: fhir.CodeableConcept[];
  /**
   * The location(s) where this healthcare service may be provided.
   */
  public location: fhir.Reference[];
  /**
   * Further description of the service as it would be presented to a consumer while searching.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Would expect that a user would not see this information on a search results, and it would only be available when viewing the complete details of the service.
   */
  public comment?: fhir.FhirString|undefined;
  /**
   * Extra details about the service that can't be placed in the other fields.
   */
  public extraDetails?: fhir.FhirMarkdown|undefined;
  /**
   * If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
   */
  public photo?: fhir.Attachment|undefined;
  /**
   * If this is empty, then refer to the location's contacts.
   */
  public telecom: fhir.ContactPoint[];
  /**
   * The locations referenced by the coverage area can include both specific locations, including areas, and also conceptual domains too (mode = kind), such as a physical area (tri-state area) and some other attribute (covered by Example Care Organization). These types of Locations are often not managed by any specific organization. This could also include generic locations such as "in-home".
   */
  public coverageArea: fhir.Reference[];
  /**
   * The provision means being commissioned by, contractually obliged or financially sourced. Types of costings that may apply to this healthcare service, such if the service may be available for free, some discounts available, or fees apply.
   */
  public serviceProvisionCode: fhir.CodeableConcept[];
  /**
   * Does this service have specific eligibility requirements that need to be met in order to use the service?
   */
  public eligibility: fhir.HealthcareServiceEligibility[];
  /**
   * Programs are often defined externally to an Organization, commonly by governments; e.g. Home and Community Care Programs, Homeless Program, ….
   */
  public program: fhir.CodeableConcept[];
  /**
   * These could be such things as is wheelchair accessible.
   */
  public characteristic: fhir.CodeableConcept[];
  /**
   * When using this property it indicates that the service is available with this language, it is not derived from the practitioners, and not all are required to use this language, just that this language is available while scheduling.
   */
  public communication: fhir.CodeableConcept[];
  /**
   * Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
   */
  public referralMethod: fhir.CodeableConcept[];
  /**
   * Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
   */
  public appointmentRequired?: fhir.FhirBoolean|undefined;
  /**
   * More detailed availability information may be provided in associated Schedule/Slot resources.
   */
  public availableTime: fhir.HealthcareServiceAvailableTime[];
  /**
   * The HealthcareService is not available during this period of time due to the provided reason.
   */
  public notAvailable: fhir.HealthcareServiceNotAvailable[];
  /**
   * A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   */
  public availabilityExceptions?: fhir.FhirString|undefined;
  /**
   * Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
   */
  public endpoint: fhir.Reference[];
  /**
   * Default constructor for HealthcareService - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<HealthcareServiceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'HealthcareService';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['active']) { this.active = new fhir.FhirBoolean({value: source.active}); }
    if (source['_active']) {
      if (this.active) { this.active.addExtendedProperties(source._active!); }
      else { this.active = new fhir.FhirBoolean(source._active as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['providedBy']) { this.providedBy = new fhir.Reference(source.providedBy); }
    if (source['category']) { this.category = source.category.map((x) => new fhir.CodeableConcept(x)); }
    else { this.category = []; }
    if (source['type']) { this.type = source.type.map((x) => new fhir.CodeableConcept(x)); }
    else { this.type = []; }
    if (source['specialty']) { this.specialty = source.specialty.map((x) => new fhir.CodeableConcept(x)); }
    else { this.specialty = []; }
    if (source['location']) { this.location = source.location.map((x) => new fhir.Reference(x)); }
    else { this.location = []; }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['comment']) { this.comment = new fhir.FhirString({value: source.comment}); }
    if (source['_comment']) {
      if (this.comment) { this.comment.addExtendedProperties(source._comment!); }
      else { this.comment = new fhir.FhirString(source._comment as Partial<fhir.FhirStringArgs>); }
    }
    if (source['extraDetails']) { this.extraDetails = new fhir.FhirMarkdown({value: source.extraDetails}); }
    if (source['_extraDetails']) {
      if (this.extraDetails) { this.extraDetails.addExtendedProperties(source._extraDetails!); }
      else { this.extraDetails = new fhir.FhirMarkdown(source._extraDetails as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['photo']) { this.photo = new fhir.Attachment(source.photo); }
    if (source['telecom']) { this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x)); }
    else { this.telecom = []; }
    if (source['coverageArea']) { this.coverageArea = source.coverageArea.map((x) => new fhir.Reference(x)); }
    else { this.coverageArea = []; }
    if (source['serviceProvisionCode']) { this.serviceProvisionCode = source.serviceProvisionCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.serviceProvisionCode = []; }
    if (source['eligibility']) { this.eligibility = source.eligibility.map((x) => new fhir.HealthcareServiceEligibility(x)); }
    else { this.eligibility = []; }
    if (source['program']) { this.program = source.program.map((x) => new fhir.CodeableConcept(x)); }
    else { this.program = []; }
    if (source['characteristic']) { this.characteristic = source.characteristic.map((x) => new fhir.CodeableConcept(x)); }
    else { this.characteristic = []; }
    if (source['communication']) { this.communication = source.communication.map((x) => new fhir.CodeableConcept(x)); }
    else { this.communication = []; }
    if (source['referralMethod']) { this.referralMethod = source.referralMethod.map((x) => new fhir.CodeableConcept(x)); }
    else { this.referralMethod = []; }
    if (source['appointmentRequired']) { this.appointmentRequired = new fhir.FhirBoolean({value: source.appointmentRequired}); }
    if (source['_appointmentRequired']) {
      if (this.appointmentRequired) { this.appointmentRequired.addExtendedProperties(source._appointmentRequired!); }
      else { this.appointmentRequired = new fhir.FhirBoolean(source._appointmentRequired as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['availableTime']) { this.availableTime = source.availableTime.map((x) => new fhir.HealthcareServiceAvailableTime(x)); }
    else { this.availableTime = []; }
    if (source['notAvailable']) { this.notAvailable = source.notAvailable.map((x) => new fhir.HealthcareServiceNotAvailable(x)); }
    else { this.notAvailable = []; }
    if (source['availabilityExceptions']) { this.availabilityExceptions = new fhir.FhirString({value: source.availabilityExceptions}); }
    if (source['_availabilityExceptions']) {
      if (this.availabilityExceptions) { this.availabilityExceptions.addExtendedProperties(source._availabilityExceptions!); }
      else { this.availabilityExceptions = new fhir.FhirString(source._availabilityExceptions as Partial<fhir.FhirStringArgs>); }
    }
    if (source['endpoint']) { this.endpoint = source.endpoint.map((x) => new fhir.Reference(x)); }
    else { this.endpoint = []; }
  }
  /**
   * Preferred-bound Value Set for specialty (HealthcareService.specialty)
   */
  public static get specialtyPreferredCodings():C80PracticeCodingType {
    return C80PracticeCodings;
  }
  /**
   * Preferred-bound Value Set for communication (HealthcareService.communication)
   */
  public static get communicationPreferredCodings():LanguagesCodingType {
    return LanguagesCodings;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(expression:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(expression);
    if (expression === '') { expression = 'HealthcareService' }
    if (!this['resourceType']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property resourceType fhir: HealthcareService.resourceType:"HealthcareService"', expression: [expression] });
    }
    if (this["identifier"]) { this.identifier.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.identifier[${i}]`)); }) }
    if (this["active"]) { issues.push(...this.active.doModelValidation(expression+'.active')); }
    if (this["providedBy"]) { issues.push(...this.providedBy.doModelValidation(expression+'.providedBy')); }
    if (this["category"]) { this.category.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.category[${i}]`)); }) }
    if (this["type"]) { this.type.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.type[${i}]`)); }) }
    if (this["specialty"]) { this.specialty.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.specialty[${i}]`)); }) }
    if (this["location"]) { this.location.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.location[${i}]`)); }) }
    if (this["name"]) { issues.push(...this.name.doModelValidation(expression+'.name')); }
    if (this["comment"]) { issues.push(...this.comment.doModelValidation(expression+'.comment')); }
    if (this["extraDetails"]) { issues.push(...this.extraDetails.doModelValidation(expression+'.extraDetails')); }
    if (this["photo"]) { issues.push(...this.photo.doModelValidation(expression+'.photo')); }
    if (this["telecom"]) { this.telecom.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.telecom[${i}]`)); }) }
    if (this["coverageArea"]) { this.coverageArea.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.coverageArea[${i}]`)); }) }
    if (this["serviceProvisionCode"]) { this.serviceProvisionCode.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.serviceProvisionCode[${i}]`)); }) }
    if (this["eligibility"]) { this.eligibility.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.eligibility[${i}]`)); }) }
    if (this["program"]) { this.program.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.program[${i}]`)); }) }
    if (this["characteristic"]) { this.characteristic.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.characteristic[${i}]`)); }) }
    if (this["communication"]) { this.communication.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.communication[${i}]`)); }) }
    if (this["referralMethod"]) { this.referralMethod.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.referralMethod[${i}]`)); }) }
    if (this["appointmentRequired"]) { issues.push(...this.appointmentRequired.doModelValidation(expression+'.appointmentRequired')); }
    if (this["availableTime"]) { this.availableTime.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.availableTime[${i}]`)); }) }
    if (this["notAvailable"]) { this.notAvailable.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.notAvailable[${i}]`)); }) }
    if (this["availabilityExceptions"]) { issues.push(...this.availabilityExceptions.doModelValidation(expression+'.availabilityExceptions')); }
    if (this["endpoint"]) { this.endpoint.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.endpoint[${i}]`)); }) }
    return issues;
  }
}
