// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Contributor

import * as fhir from '../fhir.js';

// @ts-ignore
import { ContributorTypeCodings, ContributorTypeCodingType,} from '../fhirValueSets/ContributorTypeCodings.js';
// @ts-ignore
import { ContributorTypeCodes,  ContributorTypeCodeType } from '../fhirValueSets/ContributorTypeCodes.js';
/**
 * Valid arguments for the Contributor type.
 */
export interface ContributorArgs extends fhir.FhirElementArgs {
  /**
   * The type of contributor.
   */
  type: fhir.FhirCode<ContributorTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Contributor.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * The name of the individual or organization responsible for the contribution.
   */
  name: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Contributor.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Contact details to assist a user in finding and communicating with the contributor.
   */
  contact?: fhir.ContactDetailArgs[]|undefined;
}

/**
 * A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 */
export class Contributor extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Contributor';
  /**
   * The type of contributor.
   */
  public type: fhir.FhirCode<ContributorTypeCodeType>|null;
  /**
   * The name of the individual or organization responsible for the contribution.
   */
  public name: fhir.FhirString|null;
  /**
   * Contact details to assist a user in finding and communicating with the contributor.
   */
  public contact: fhir.ContactDetail[];
  /**
   * Default constructor for Contributor - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ContributorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.FhirCode<ContributorTypeCodeType>({value: source.type}); }
    else { this.type = null; }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<ContributorTypeCodeType>(source._type as Partial<fhir.FhirCode>); }
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    else { this.name = null; }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.ContactDetail(x)); }
    else { this.contact = []; }
  }
  /**
   * Required-bound Value Set for type (Contributor.type)
   */
  public static get typeRequiredCodes() {
    return ContributorTypeCodes;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(expression:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(expression);
    if (expression === '') { expression = 'Contributor' }
    if (!this['type']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property type fhir: Contributor.type:code', expression: [expression] });
    }
    if (this['type'] && (!Object.values(ContributorTypeCodes).includes(this.type.value as any))) {
      issues.push({ severity: 'error', code: 'code-invalid', diagnostics: 'Invalid code property type fhir: Contributor.type:code Required binding to: ContributorType', expression: [expression] });
    }
    if (this["type"]) { issues.push(...this.type.doModelValidation(expression+'.type')); }
    if (!this['name']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property name fhir: Contributor.name:string', expression: [expression] });
    }
    if (this["name"]) { issues.push(...this.name.doModelValidation(expression+'.name')); }
    if (this["contact"]) { this.contact.forEach((x,i) => { issues.push(...x.doModelValidation(expression+`.contact[${i}]`)); }) }
    return issues;
  }
}
