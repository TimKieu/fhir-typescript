// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ObservationDefinition

import * as fhir from '../fhir.js';

// @ts-ignore
import { UcumUnitsCodings, UcumUnitsCodingType,} from '../fhirValueSets/UcumUnitsCodings.js';
// @ts-ignore
import { UcumUnitsCodes,  UcumUnitsCodeType } from '../fhirValueSets/UcumUnitsCodes.js';
// @ts-ignore
import { ObservationRangeCategoryCodings, ObservationRangeCategoryCodingType,} from '../fhirValueSets/ObservationRangeCategoryCodings.js';
// @ts-ignore
import { ObservationRangeCategoryCodes,  ObservationRangeCategoryCodeType } from '../fhirValueSets/ObservationRangeCategoryCodes.js';
// @ts-ignore
import { ReferencerangeMeaningCodings, ReferencerangeMeaningCodingType,} from '../fhirValueSets/ReferencerangeMeaningCodings.js';
// @ts-ignore
import { ReferencerangeMeaningCodes,  ReferencerangeMeaningCodeType } from '../fhirValueSets/ReferencerangeMeaningCodes.js';
// @ts-ignore
import { ReferencerangeAppliestoCodings, ReferencerangeAppliestoCodingType,} from '../fhirValueSets/ReferencerangeAppliestoCodings.js';
// @ts-ignore
import { ReferencerangeAppliestoCodes,  ReferencerangeAppliestoCodeType } from '../fhirValueSets/ReferencerangeAppliestoCodes.js';
// @ts-ignore
import { AdministrativeGenderCodings, AdministrativeGenderCodingType,} from '../fhirValueSets/AdministrativeGenderCodings.js';
// @ts-ignore
import { AdministrativeGenderCodes,  AdministrativeGenderCodeType } from '../fhirValueSets/AdministrativeGenderCodes.js';
// @ts-ignore
import { ObservationCategoryCodings, ObservationCategoryCodingType,} from '../fhirValueSets/ObservationCategoryCodings.js';
// @ts-ignore
import { ObservationCategoryCodes,  ObservationCategoryCodeType } from '../fhirValueSets/ObservationCategoryCodes.js';
// @ts-ignore
import { ObservationCodings, ObservationCodingType,} from '../fhirValueSets/ObservationCodings.js';
// @ts-ignore
import { ObservationCodes,  ObservationCodeType } from '../fhirValueSets/ObservationCodes.js';
// @ts-ignore
import { PermittedDataTypeCodings, PermittedDataTypeCodingType,} from '../fhirValueSets/PermittedDataTypeCodings.js';
// @ts-ignore
import { PermittedDataTypeCodes,  PermittedDataTypeCodeType } from '../fhirValueSets/PermittedDataTypeCodes.js';
// @ts-ignore
import { ObservationMethodsCodings, ObservationMethodsCodingType,} from '../fhirValueSets/ObservationMethodsCodings.js';
// @ts-ignore
import { ObservationMethodsCodes,  ObservationMethodsCodeType } from '../fhirValueSets/ObservationMethodsCodes.js';
/**
 * Valid arguments for the ObservationDefinitionQuantitativeDetails type.
 */
export interface ObservationDefinitionQuantitativeDetailsArgs extends fhir.BackboneElementArgs {
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  customaryUnit?: fhir.CodeableConceptArgs|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  unit?: fhir.CodeableConceptArgs|undefined;
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  conversionFactor?: fhir.FhirDecimal|number|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  decimalPrecision?: fhir.FhirInteger|number|undefined;
}

/**
 * Characteristics for quantitative results of this observation.
 */
export class ObservationDefinitionQuantitativeDetails extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationDefinitionQuantitativeDetails';
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public customaryUnit?: fhir.CodeableConcept|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public unit?: fhir.CodeableConcept|undefined;
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  public conversionFactor?: fhir.FhirDecimal|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  public decimalPrecision?: fhir.FhirInteger|undefined;
  /**
   * Default constructor for ObservationDefinitionQuantitativeDetails - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationDefinitionQuantitativeDetailsArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['customaryUnit']) { this.customaryUnit = new fhir.CodeableConcept(source.customaryUnit); }
    if (source['unit']) { this.unit = new fhir.CodeableConcept(source.unit); }
    if (source['conversionFactor']) { this.conversionFactor = new fhir.FhirDecimal({value: source.conversionFactor}); }
    if (source['decimalPrecision']) { this.decimalPrecision = new fhir.FhirInteger({value: source.decimalPrecision}); }
  }
  /**
   * Extensible-bound Value Set for customaryUnit (ObservationDefinition.quantitativeDetails.customaryUnit)
   */
  public static get customaryUnitExtensibleCodings():UcumUnitsCodingType {
    return UcumUnitsCodings;
  }
  /**
   * Extensible-bound Value Set for unit (ObservationDefinition.quantitativeDetails.unit)
   */
  public static get unitExtensibleCodings():UcumUnitsCodingType {
    return UcumUnitsCodings;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["customaryUnit"]) { issues.push(...this.customaryUnit.doModelValidation()); }
    if (this["unit"]) { issues.push(...this.unit.doModelValidation()); }
    if (this["conversionFactor"]) { issues.push(...this.conversionFactor.doModelValidation()); }
    if (this["decimalPrecision"]) { issues.push(...this.decimalPrecision.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the ObservationDefinitionQualifiedInterval type.
 */
export interface ObservationDefinitionQualifiedIntervalArgs extends fhir.BackboneElementArgs {
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  category?: fhir.FhirCode<ObservationRangeCategoryCodeType>|string|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  range?: fhir.RangeArgs|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  context?: fhir.CodeableConceptArgs|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  appliesTo?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Sex of the population the range applies to.
   */
  gender?: fhir.FhirCode<AdministrativeGenderCodeType>|string|undefined;
  /**
   * Some analytes vary greatly over age.
   */
  age?: fhir.RangeArgs|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  gestationalAge?: fhir.RangeArgs|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  condition?: fhir.FhirString|string|undefined;
}

/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export class ObservationDefinitionQualifiedInterval extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationDefinitionQualifiedInterval';
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  public category?: fhir.FhirCode<ObservationRangeCategoryCodeType>|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  public range?: fhir.Range|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  public context?: fhir.CodeableConcept|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  public appliesTo: fhir.CodeableConcept[];
  /**
   * Sex of the population the range applies to.
   */
  public gender?: fhir.FhirCode<AdministrativeGenderCodeType>|undefined;
  /**
   * Some analytes vary greatly over age.
   */
  public age?: fhir.Range|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  public gestationalAge?: fhir.Range|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  public condition?: fhir.FhirString|undefined;
  /**
   * Default constructor for ObservationDefinitionQualifiedInterval - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationDefinitionQualifiedIntervalArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['category']) { this.category = new fhir.FhirCode<ObservationRangeCategoryCodeType>({value: source.category}); }
    if (source['range']) { this.range = new fhir.Range(source.range); }
    if (source['context']) { this.context = new fhir.CodeableConcept(source.context); }
    if (source['appliesTo']) { this.appliesTo = source.appliesTo.map((x) => new fhir.CodeableConcept(x)); }
    else { this.appliesTo = []; }
    if (source['gender']) { this.gender = new fhir.FhirCode<AdministrativeGenderCodeType>({value: source.gender}); }
    if (source['age']) { this.age = new fhir.Range(source.age); }
    if (source['gestationalAge']) { this.gestationalAge = new fhir.Range(source.gestationalAge); }
    if (source['condition']) { this.condition = new fhir.FhirString({value: source.condition}); }
  }
  /**
   * Required-bound Value Set for category (ObservationDefinition.qualifiedInterval.category)
   */
  public static get categoryRequiredCodes() {
    return ObservationRangeCategoryCodes;
  }
  /**
   * Extensible-bound Value Set for context (ObservationDefinition.qualifiedInterval.context)
   */
  public static get contextExtensibleCodings():ReferencerangeMeaningCodingType {
    return ReferencerangeMeaningCodings;
  }
  /**
   * Required-bound Value Set for gender (ObservationDefinition.qualifiedInterval.gender)
   */
  public static get genderRequiredCodes() {
    return AdministrativeGenderCodes;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this['category'] && (!Object.values(ObservationRangeCategoryCodes).includes(this.category as any))) {
      issues.push({ severity: 'error', code: 'code-invalid', diagnostics: 'Invalid code property category?:fhir.FhirCode<ObservationRangeCategoryCodeType> fhir: ObservationDefinition.qualifiedInterval.category:code Required binding to: ObservationRangeCategory' });
    }
    if (this["category"]) { issues.push(...this.category.doModelValidation()); }
    if (this["range"]) { issues.push(...this.range.doModelValidation()); }
    if (this["context"]) { issues.push(...this.context.doModelValidation()); }
    if (this["appliesTo"]) { this.appliesTo.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this['gender'] && (!Object.values(AdministrativeGenderCodes).includes(this.gender as any))) {
      issues.push({ severity: 'error', code: 'code-invalid', diagnostics: 'Invalid code property gender?:fhir.FhirCode<AdministrativeGenderCodeType> fhir: ObservationDefinition.qualifiedInterval.gender:code Required binding to: AdministrativeGender' });
    }
    if (this["gender"]) { issues.push(...this.gender.doModelValidation()); }
    if (this["age"]) { issues.push(...this.age.doModelValidation()); }
    if (this["gestationalAge"]) { issues.push(...this.gestationalAge.doModelValidation()); }
    if (this["condition"]) { issues.push(...this.condition.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the ObservationDefinition type.
 */
export interface ObservationDefinitionArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "ObservationDefinition"|undefined;
  /**
   * This element allows various categorization schemes based on the owner’s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  category?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  code: fhir.CodeableConceptArgs|null;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  permittedDataType?: fhir.FhirCode<PermittedDataTypeCodeType>[]|string[]|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  multipleResultsAllowed?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  method?: fhir.CodeableConceptArgs|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  preferredReportName?: fhir.FhirString|string|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  quantitativeDetails?: fhir.ObservationDefinitionQuantitativeDetailsArgs|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  qualifiedInterval?: fhir.ObservationDefinitionQualifiedIntervalArgs[]|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  validCodedValueSet?: fhir.ReferenceArgs|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  normalCodedValueSet?: fhir.ReferenceArgs|undefined;
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  abnormalCodedValueSet?: fhir.ReferenceArgs|undefined;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  criticalCodedValueSet?: fhir.ReferenceArgs|undefined;
}

/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export class ObservationDefinition extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationDefinition';
  /**
   * Resource Type Name
   */
  public override resourceType: "ObservationDefinition";
  /**
   * This element allows various categorization schemes based on the owner’s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  public category: fhir.CodeableConcept[];
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  public code: fhir.CodeableConcept|null;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  public identifier: fhir.Identifier[];
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  public permittedDataType: fhir.FhirCode<PermittedDataTypeCodeType>[];
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  public multipleResultsAllowed?: fhir.FhirBoolean|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  public preferredReportName?: fhir.FhirString|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  public quantitativeDetails?: fhir.ObservationDefinitionQuantitativeDetails|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  public qualifiedInterval: fhir.ObservationDefinitionQualifiedInterval[];
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  public validCodedValueSet?: fhir.Reference|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  public normalCodedValueSet?: fhir.Reference|undefined;
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  public abnormalCodedValueSet?: fhir.Reference|undefined;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  public criticalCodedValueSet?: fhir.Reference|undefined;
  /**
   * Default constructor for ObservationDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationDefinitionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'ObservationDefinition';
    if (source['category']) { this.category = source.category.map((x) => new fhir.CodeableConcept(x)); }
    else { this.category = []; }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['permittedDataType']) { this.permittedDataType = source.permittedDataType.map((x) => new fhir.FhirCode<PermittedDataTypeCodeType>({value: x})); }
    else { this.permittedDataType = []; }
    if (source['multipleResultsAllowed']) { this.multipleResultsAllowed = new fhir.FhirBoolean({value: source.multipleResultsAllowed}); }
    if (source['method']) { this.method = new fhir.CodeableConcept(source.method); }
    if (source['preferredReportName']) { this.preferredReportName = new fhir.FhirString({value: source.preferredReportName}); }
    if (source['quantitativeDetails']) { this.quantitativeDetails = new fhir.ObservationDefinitionQuantitativeDetails(source.quantitativeDetails); }
    if (source['qualifiedInterval']) { this.qualifiedInterval = source.qualifiedInterval.map((x) => new fhir.ObservationDefinitionQualifiedInterval(x)); }
    else { this.qualifiedInterval = []; }
    if (source['validCodedValueSet']) { this.validCodedValueSet = new fhir.Reference(source.validCodedValueSet); }
    if (source['normalCodedValueSet']) { this.normalCodedValueSet = new fhir.Reference(source.normalCodedValueSet); }
    if (source['abnormalCodedValueSet']) { this.abnormalCodedValueSet = new fhir.Reference(source.abnormalCodedValueSet); }
    if (source['criticalCodedValueSet']) { this.criticalCodedValueSet = new fhir.Reference(source.criticalCodedValueSet); }
  }
  /**
   * Required-bound Value Set for permittedDataType (ObservationDefinition.permittedDataType)
   */
  public static get permittedDataTypeRequiredCodes() {
    return PermittedDataTypeCodes;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (!this['resourceType']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property resourceType:"ObservationDefinition" fhir: ObservationDefinition.resourceType:"ObservationDefinition"' });
    }
    if (this["category"]) { this.category.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (!this['code']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property code:fhir.CodeableConcept fhir: ObservationDefinition.code:CodeableConcept' });
    }
    if (this["code"]) { issues.push(...this.code.doModelValidation()); }
    if (this["identifier"]) { this.identifier.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this['permittedDataType']) {
      this.permittedDataType.forEach((v) => {
        if (!Object.values(PermittedDataTypeCodes).includes(v as any)) {
          issues.push({ severity: 'error', code: 'code-invalid', diagnostics: 'Invalid code property permittedDataType?:fhir.FhirCode<PermittedDataTypeCodeType>[] fhir: ObservationDefinition.permittedDataType:code Required binding to: PermittedDataType' });
        }
      });
    }
    if (this["permittedDataType"]) { this.permittedDataType.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["multipleResultsAllowed"]) { issues.push(...this.multipleResultsAllowed.doModelValidation()); }
    if (this["method"]) { issues.push(...this.method.doModelValidation()); }
    if (this["preferredReportName"]) { issues.push(...this.preferredReportName.doModelValidation()); }
    if (this["quantitativeDetails"]) { issues.push(...this.quantitativeDetails.doModelValidation()); }
    if (this["qualifiedInterval"]) { this.qualifiedInterval.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["validCodedValueSet"]) { issues.push(...this.validCodedValueSet.doModelValidation()); }
    if (this["normalCodedValueSet"]) { issues.push(...this.normalCodedValueSet.doModelValidation()); }
    if (this["abnormalCodedValueSet"]) { issues.push(...this.abnormalCodedValueSet.doModelValidation()); }
    if (this["criticalCodedValueSet"]) { issues.push(...this.criticalCodedValueSet.doModelValidation()); }
    return issues;
  }
}
