// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: SubstancePolymer

import * as fhir from '../fhir.js';

/**
 * Valid arguments for the SubstancePolymerMonomerSetStartingMaterial type.
 */
export interface SubstancePolymerMonomerSetStartingMaterialArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  material?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  isDefining?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.monomerSet.startingMaterial.isDefining
   */
  _isDefining?:fhir.FhirElementArgs;
  /**
   * Todo.
   */
  amount?: fhir.SubstanceAmountArgs|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerMonomerSetStartingMaterial extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerMonomerSetStartingMaterial';
  /**
   * Todo.
   */
  public material?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public isDefining?: fhir.FhirBoolean|undefined;
  /**
   * Todo.
   */
  public amount?: fhir.SubstanceAmount|undefined;
  /**
   * Default constructor for SubstancePolymerMonomerSetStartingMaterial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerMonomerSetStartingMaterialArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['material']) { this.material = new fhir.CodeableConcept(source.material, options); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type, options); }
    if (source['isDefining'] !== undefined) { this.isDefining = new fhir.FhirBoolean({value: source.isDefining}, options); }
    if (source['_isDefining']) {
      if (this.isDefining) { this.isDefining.addExtendedProperties(source._isDefining!); }
      else { this.isDefining = new fhir.FhirBoolean(source._isDefining as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['amount']) { this.amount = new fhir.SubstanceAmount(source.amount, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.monomerSet.startingMaterial' }
    iss.push(...this.vOS('material',exp));
    iss.push(...this.vOS('type',exp));
    iss.push(...this.vOS('isDefining',exp));
    iss.push(...this.vOS('amount',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymerMonomerSet type.
 */
export interface SubstancePolymerMonomerSetArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  ratioType?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  startingMaterial?: fhir.SubstancePolymerMonomerSetStartingMaterialArgs[]|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerMonomerSet extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerMonomerSet';
  /**
   * Todo.
   */
  public ratioType?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public startingMaterial: fhir.SubstancePolymerMonomerSetStartingMaterial[];
  /**
   * Default constructor for SubstancePolymerMonomerSet - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerMonomerSetArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['ratioType']) { this.ratioType = new fhir.CodeableConcept(source.ratioType, options); }
    if (source['startingMaterial']) { this.startingMaterial = source.startingMaterial.map((x) => new fhir.SubstancePolymerMonomerSetStartingMaterial(x, options)); }
    else { this.startingMaterial = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.monomerSet' }
    iss.push(...this.vOS('ratioType',exp));
    iss.push(...this.vOA('startingMaterial',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation type.
 */
export interface SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  degree?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  amount?: fhir.SubstanceAmountArgs|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation';
  /**
   * Todo.
   */
  public degree?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public amount?: fhir.SubstanceAmount|undefined;
  /**
   * Default constructor for SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['degree']) { this.degree = new fhir.CodeableConcept(source.degree, options); }
    if (source['amount']) { this.amount = new fhir.SubstanceAmount(source.amount, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation' }
    iss.push(...this.vOS('degree',exp));
    iss.push(...this.vOS('amount',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymerRepeatRepeatUnitStructuralRepresentation type.
 */
export interface SubstancePolymerRepeatRepeatUnitStructuralRepresentationArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  representation?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.repeat.repeatUnit.structuralRepresentation.representation
   */
  _representation?:fhir.FhirElementArgs;
  /**
   * Todo.
   */
  attachment?: fhir.AttachmentArgs|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerRepeatRepeatUnitStructuralRepresentation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerRepeatRepeatUnitStructuralRepresentation';
  /**
   * Todo.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public representation?: fhir.FhirString|undefined;
  /**
   * Todo.
   */
  public attachment?: fhir.Attachment|undefined;
  /**
   * Default constructor for SubstancePolymerRepeatRepeatUnitStructuralRepresentation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerRepeatRepeatUnitStructuralRepresentationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type, options); }
    if (source['representation'] !== undefined) { this.representation = new fhir.FhirString({value: source.representation}, options); }
    if (source['_representation']) {
      if (this.representation) { this.representation.addExtendedProperties(source._representation!); }
      else { this.representation = new fhir.FhirString(source._representation as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['attachment']) { this.attachment = new fhir.Attachment(source.attachment, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation' }
    iss.push(...this.vOS('type',exp));
    iss.push(...this.vOS('representation',exp));
    iss.push(...this.vOS('attachment',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymerRepeatRepeatUnit type.
 */
export interface SubstancePolymerRepeatRepeatUnitArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  orientationOfPolymerisation?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  repeatUnit?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.repeat.repeatUnit.repeatUnit
   */
  _repeatUnit?:fhir.FhirElementArgs;
  /**
   * Todo.
   */
  amount?: fhir.SubstanceAmountArgs|undefined;
  /**
   * Todo.
   */
  degreeOfPolymerisation?: fhir.SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationArgs[]|undefined;
  /**
   * Todo.
   */
  structuralRepresentation?: fhir.SubstancePolymerRepeatRepeatUnitStructuralRepresentationArgs[]|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerRepeatRepeatUnit extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerRepeatRepeatUnit';
  /**
   * Todo.
   */
  public orientationOfPolymerisation?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public repeatUnit?: fhir.FhirString|undefined;
  /**
   * Todo.
   */
  public amount?: fhir.SubstanceAmount|undefined;
  /**
   * Todo.
   */
  public degreeOfPolymerisation: fhir.SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation[];
  /**
   * Todo.
   */
  public structuralRepresentation: fhir.SubstancePolymerRepeatRepeatUnitStructuralRepresentation[];
  /**
   * Default constructor for SubstancePolymerRepeatRepeatUnit - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerRepeatRepeatUnitArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['orientationOfPolymerisation']) { this.orientationOfPolymerisation = new fhir.CodeableConcept(source.orientationOfPolymerisation, options); }
    if (source['repeatUnit'] !== undefined) { this.repeatUnit = new fhir.FhirString({value: source.repeatUnit}, options); }
    if (source['_repeatUnit']) {
      if (this.repeatUnit) { this.repeatUnit.addExtendedProperties(source._repeatUnit!); }
      else { this.repeatUnit = new fhir.FhirString(source._repeatUnit as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['amount']) { this.amount = new fhir.SubstanceAmount(source.amount, options); }
    if (source['degreeOfPolymerisation']) { this.degreeOfPolymerisation = source.degreeOfPolymerisation.map((x) => new fhir.SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(x, options)); }
    else { this.degreeOfPolymerisation = []; }
    if (source['structuralRepresentation']) { this.structuralRepresentation = source.structuralRepresentation.map((x) => new fhir.SubstancePolymerRepeatRepeatUnitStructuralRepresentation(x, options)); }
    else { this.structuralRepresentation = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.repeat.repeatUnit' }
    iss.push(...this.vOS('orientationOfPolymerisation',exp));
    iss.push(...this.vOS('repeatUnit',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOA('degreeOfPolymerisation',exp));
    iss.push(...this.vOA('structuralRepresentation',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymerRepeat type.
 */
export interface SubstancePolymerRepeatArgs extends fhir.BackboneElementArgs {
  /**
   * Todo.
   */
  numberOfUnits?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.repeat.numberOfUnits
   */
  _numberOfUnits?:fhir.FhirElementArgs;
  /**
   * Todo.
   */
  averageMolecularFormula?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.repeat.averageMolecularFormula
   */
  _averageMolecularFormula?:fhir.FhirElementArgs;
  /**
   * Todo.
   */
  repeatUnitAmountType?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  repeatUnit?: fhir.SubstancePolymerRepeatRepeatUnitArgs[]|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymerRepeat extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymerRepeat';
  /**
   * Todo.
   */
  public numberOfUnits?: fhir.FhirInteger|undefined;
  /**
   * Todo.
   */
  public averageMolecularFormula?: fhir.FhirString|undefined;
  /**
   * Todo.
   */
  public repeatUnitAmountType?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public repeatUnit: fhir.SubstancePolymerRepeatRepeatUnit[];
  /**
   * Default constructor for SubstancePolymerRepeat - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerRepeatArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['numberOfUnits'] !== undefined) { this.numberOfUnits = new fhir.FhirInteger({value: source.numberOfUnits}, options); }
    if (source['_numberOfUnits']) {
      if (this.numberOfUnits) { this.numberOfUnits.addExtendedProperties(source._numberOfUnits!); }
      else { this.numberOfUnits = new fhir.FhirInteger(source._numberOfUnits as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['averageMolecularFormula'] !== undefined) { this.averageMolecularFormula = new fhir.FhirString({value: source.averageMolecularFormula}, options); }
    if (source['_averageMolecularFormula']) {
      if (this.averageMolecularFormula) { this.averageMolecularFormula.addExtendedProperties(source._averageMolecularFormula!); }
      else { this.averageMolecularFormula = new fhir.FhirString(source._averageMolecularFormula as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['repeatUnitAmountType']) { this.repeatUnitAmountType = new fhir.CodeableConcept(source.repeatUnitAmountType, options); }
    if (source['repeatUnit']) { this.repeatUnit = source.repeatUnit.map((x) => new fhir.SubstancePolymerRepeatRepeatUnit(x, options)); }
    else { this.repeatUnit = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer.repeat' }
    iss.push(...this.vOS('numberOfUnits',exp));
    iss.push(...this.vOS('averageMolecularFormula',exp));
    iss.push(...this.vOS('repeatUnitAmountType',exp));
    iss.push(...this.vOA('repeatUnit',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubstancePolymer type.
 */
export interface SubstancePolymerArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "SubstancePolymer"|undefined;
  /**
   * Todo.
   */
  class?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  geometry?: fhir.CodeableConceptArgs|undefined;
  /**
   * Todo.
   */
  copolymerConnectivity?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Todo.
   */
  modification?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: SubstancePolymer.modification
   */
  _modification?:(fhir.FhirElementArgs|null)[];
  /**
   * Todo.
   */
  monomerSet?: fhir.SubstancePolymerMonomerSetArgs[]|undefined;
  /**
   * Todo.
   */
  repeat?: fhir.SubstancePolymerRepeatArgs[]|undefined;
}

/**
 * Todo.
 */
export class SubstancePolymer extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstancePolymer';
  /**
   * Resource Type Name
   */
  public override resourceType: "SubstancePolymer";
  /**
   * Todo.
   */
  public class?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public geometry?: fhir.CodeableConcept|undefined;
  /**
   * Todo.
   */
  public copolymerConnectivity: fhir.CodeableConcept[];
  /**
   * Todo.
   */
  public modification: fhir.FhirString[];
  /**
   * Todo.
   */
  public monomerSet: fhir.SubstancePolymerMonomerSet[];
  /**
   * Todo.
   */
  public repeat: fhir.SubstancePolymerRepeat[];
  /**
   * Default constructor for SubstancePolymer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstancePolymerArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'SubstancePolymer';
    if (source['class']) { this.class = new fhir.CodeableConcept(source.class, options); }
    if (source['geometry']) { this.geometry = new fhir.CodeableConcept(source.geometry, options); }
    if (source['copolymerConnectivity']) { this.copolymerConnectivity = source.copolymerConnectivity.map((x) => new fhir.CodeableConcept(x, options)); }
    else { this.copolymerConnectivity = []; }
    if (source['modification'] !== undefined) { this.modification = source.modification.map((x) => new fhir.FhirString({value: x}, options)); }
    else { this.modification = []; }
    if (source['_modification']) {
      source._modification.forEach((x,i) => {
        if (this.modification.length >= i) { if (x) { this.modification[i].addExtendedProperties(x); } }
        else { if (x) { this.modification.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['monomerSet']) { this.monomerSet = source.monomerSet.map((x) => new fhir.SubstancePolymerMonomerSet(x, options)); }
    else { this.monomerSet = []; }
    if (source['repeat']) { this.repeat = source.repeat.map((x) => new fhir.SubstancePolymerRepeat(x, options)); }
    else { this.repeat = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstancePolymer' }
    iss.push(...this.vOS('class',exp));
    iss.push(...this.vOS('geometry',exp));
    iss.push(...this.vOA('copolymerConnectivity',exp));
    iss.push(...this.vOA('modification',exp));
    iss.push(...this.vOA('monomerSet',exp));
    iss.push(...this.vOA('repeat',exp));
    return iss;
  }
}
