// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Location

import * as fhir from '../fhir.js';

// @ts-ignore
import { LocationStatusCodes,  LocationStatusCodeType } from '../fhirValueSets/LocationStatusCodes.js';
// @ts-ignore
import { LocationStatusVsValidation } from '../fhirValueSets/LocationStatusVsValidation.js';
// @ts-ignore
import { V20116Codes,  V20116CodeType } from '../fhirValueSets/V20116Codes.js';
// @ts-ignore
import { V20116VsValidation } from '../fhirValueSets/V20116VsValidation.js';
// @ts-ignore
import { LocationModeCodes,  LocationModeCodeType } from '../fhirValueSets/LocationModeCodes.js';
// @ts-ignore
import { LocationModeVsValidation } from '../fhirValueSets/LocationModeVsValidation.js';
// @ts-ignore
import { V3ServiceDeliveryLocationRoleTypeCodes,  V3ServiceDeliveryLocationRoleTypeCodeType } from '../fhirValueSets/V3ServiceDeliveryLocationRoleTypeCodes.js';
// @ts-ignore
import { V3ServiceDeliveryLocationRoleTypeVsValidation } from '../fhirValueSets/V3ServiceDeliveryLocationRoleTypeVsValidation.js';
// @ts-ignore
import { LocationPhysicalTypeCodes,  LocationPhysicalTypeCodeType } from '../fhirValueSets/LocationPhysicalTypeCodes.js';
// @ts-ignore
import { LocationPhysicalTypeVsValidation } from '../fhirValueSets/LocationPhysicalTypeVsValidation.js';
/**
 * Valid arguments for the LocationPosition type.
 */
export interface LocationPositionArgs extends fhir.BackboneElementArgs {
  /**
   * Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
   */
  longitude: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Location.position.longitude
   */
  _longitude?:fhir.FhirElementArgs;
  /**
   * Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
   */
  latitude: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Location.position.latitude
   */
  _latitude?:fhir.FhirElementArgs;
  /**
   * Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
   */
  altitude?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Location.position.altitude
   */
  _altitude?:fhir.FhirElementArgs;
}

/**
 * The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
 */
export class LocationPosition extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'LocationPosition';
  /**
   * Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
   */
  public longitude: fhir.FhirDecimal|null;
  /**
   * Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
   */
  public latitude: fhir.FhirDecimal|null;
  /**
   * Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
   */
  public altitude?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for LocationPosition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LocationPositionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['longitude'] !== undefined) { this.longitude = new fhir.FhirDecimal({value: source.longitude}, options); }
    else { this.longitude = null; }
    if (source['_longitude']) {
      if (this.longitude) { this.longitude.addExtendedProperties(source._longitude!); }
      else { this.longitude = new fhir.FhirDecimal(source._longitude as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['latitude'] !== undefined) { this.latitude = new fhir.FhirDecimal({value: source.latitude}, options); }
    else { this.latitude = null; }
    if (source['_latitude']) {
      if (this.latitude) { this.latitude.addExtendedProperties(source._latitude!); }
      else { this.latitude = new fhir.FhirDecimal(source._latitude as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['altitude'] !== undefined) { this.altitude = new fhir.FhirDecimal({value: source.altitude}, options); }
    if (source['_altitude']) {
      if (this.altitude) { this.altitude.addExtendedProperties(source._altitude!); }
      else { this.altitude = new fhir.FhirDecimal(source._altitude as Partial<fhir.FhirDecimalArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Location.position' }
    iss.push(...this.vRS('longitude',exp));
    iss.push(...this.vRS('latitude',exp));
    iss.push(...this.vOS('altitude',exp));
    return iss;
  }
}
/**
 * Valid arguments for the Location type.
 */
export interface LocationArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Location"|undefined;
  /**
   * Unique code or number identifying the location to its users.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  status?: fhir.FhirCode<LocationStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Location.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * The Operational status covers operation values most relevant to beds (but can also apply to rooms/units/chair/etc such as an isolation unit/dialisys chair). This typically covers concepts such as contamination, housekeeping and other activities like maintenance.
   */
  operationalStatus?: fhir.CodingArgs|undefined;
  /**
   * If the name of an location changes, consider putting the old name in the alias column so that it can still be located through searches.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Location.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the location.
   */
  alias?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: Location.alias
   */
  _alias?:(fhir.FhirElementArgs|null)[];
  /**
   * Description of the Location, which helps in finding or referencing the place.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Location.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * This is labeled as a modifer because whether or not the location is a class of locations changes how it can be used and understood.
   */
  mode?: fhir.FhirCode<LocationModeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Location.mode
   */
  _mode?:fhir.FhirElementArgs;
  /**
   * Indicates the type of function performed at the location.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
   */
  telecom?: fhir.ContactPointArgs[]|undefined;
  /**
   * This was kept as 0..1 as there is no use property on the address, so wouldn't be able to identify different address types.
   */
  address?: fhir.AddressArgs|undefined;
  /**
   * Physical form of the location, e.g. building, room, vehicle, road.
   */
  physicalType?: fhir.CodeableConceptArgs|undefined;
  /**
   * The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
   */
  position?: fhir.LocationPositionArgs|undefined;
  /**
   * This can also be used as the part of the organization hierarchy where this location provides services. These services can be defined through the HealthcareService resource.
   */
  managingOrganization?: fhir.ReferenceArgs|undefined;
  /**
   * Another Location which this Location is physically part of.
   */
  partOf?: fhir.ReferenceArgs|undefined;
  /**
   * Technical endpoints providing access to services operated for the location.
   */
  endpoint?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Details and position information for a physical place where services are provided  and resources and participants may be stored, found, contained or accommodated.
 */
export class Location extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Location';
  /**
   * Resource Type Name
   */
  public override resourceType: "Location";
  /**
   * Unique code or number identifying the location to its users.
   */
  public identifier: fhir.Identifier[];
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  public status?: fhir.FhirCode<LocationStatusCodeType>|undefined;
  /**
   * The Operational status covers operation values most relevant to beds (but can also apply to rooms/units/chair/etc such as an isolation unit/dialisys chair). This typically covers concepts such as contamination, housekeeping and other activities like maintenance.
   */
  public operationalStatus?: fhir.Coding|undefined;
  /**
   * If the name of an location changes, consider putting the old name in the alias column so that it can still be located through searches.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the location.
   */
  public alias: fhir.FhirString[];
  /**
   * Description of the Location, which helps in finding or referencing the place.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * This is labeled as a modifer because whether or not the location is a class of locations changes how it can be used and understood.
   */
  public mode?: fhir.FhirCode<LocationModeCodeType>|undefined;
  /**
   * Indicates the type of function performed at the location.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
   */
  public telecom: fhir.ContactPoint[];
  /**
   * This was kept as 0..1 as there is no use property on the address, so wouldn't be able to identify different address types.
   */
  public address?: fhir.Address|undefined;
  /**
   * Physical form of the location, e.g. building, room, vehicle, road.
   */
  public physicalType?: fhir.CodeableConcept|undefined;
  /**
   * The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
   */
  public position?: fhir.LocationPosition|undefined;
  /**
   * This can also be used as the part of the organization hierarchy where this location provides services. These services can be defined through the HealthcareService resource.
   */
  public managingOrganization?: fhir.Reference|undefined;
  /**
   * Another Location which this Location is physically part of.
   */
  public partOf?: fhir.Reference|undefined;
  /**
   * Technical endpoints providing access to services operated for the location.
   */
  public endpoint: fhir.Reference[];
  /**
   * Default constructor for Location - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LocationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Location';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x, options)); }
    else { this.identifier = []; }
    if (source['status'] !== undefined) { this.status = new fhir.FhirCode<LocationStatusCodeType>({value: source.status}, options); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<LocationStatusCodeType>(source._status as Partial<fhir.FhirCode>, options); }
    }
    if (source['operationalStatus']) { this.operationalStatus = new fhir.Coding(source.operationalStatus, options); }
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['alias'] !== undefined) { this.alias = source.alias.map((x) => new fhir.FhirString({value: x}, options)); }
    else { this.alias = []; }
    if (source['_alias']) {
      source._alias.forEach((x,i) => {
        if (this.alias.length >= i) { if (x) { this.alias[i].addExtendedProperties(x); } }
        else { if (x) { this.alias.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['mode'] !== undefined) { this.mode = new fhir.FhirCode<LocationModeCodeType>({value: source.mode}, options); }
    if (source['_mode']) {
      if (this.mode) { this.mode.addExtendedProperties(source._mode!); }
      else { this.mode = new fhir.FhirCode<LocationModeCodeType>(source._mode as Partial<fhir.FhirCode>, options); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type, options); }
    if (source['telecom']) { this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x, options)); }
    else { this.telecom = []; }
    if (source['address']) { this.address = new fhir.Address(source.address, options); }
    if (source['physicalType']) { this.physicalType = new fhir.CodeableConcept(source.physicalType, options); }
    if (source['position']) { this.position = new fhir.LocationPosition(source.position, options); }
    if (source['managingOrganization']) { this.managingOrganization = new fhir.Reference(source.managingOrganization, options); }
    if (source['partOf']) { this.partOf = new fhir.Reference(source.partOf, options); }
    if (source['endpoint']) { this.endpoint = source.endpoint.map((x) => new fhir.Reference(x, options)); }
    else { this.endpoint = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Location' }
    iss.push(...this.vOA('identifier',exp));
    iss.push(...this.vOSV('status',exp,'LocationStatus',LocationStatusVsValidation,'r'));
    iss.push(...this.vOS('operationalStatus',exp));
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOA('alias',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOSV('mode',exp,'LocationMode',LocationModeVsValidation,'r'));
    iss.push(...this.vOS('type',exp));
    iss.push(...this.vOA('telecom',exp));
    iss.push(...this.vOS('address',exp));
    iss.push(...this.vOS('physicalType',exp));
    iss.push(...this.vOS('position',exp));
    iss.push(...this.vOS('managingOrganization',exp));
    iss.push(...this.vOS('partOf',exp));
    iss.push(...this.vOA('endpoint',exp));
    return iss;
  }
}
