// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: DataElement

import * as fhir from '../fhir.js';

// @ts-ignore
import { PublicationStatusCodes,  PublicationStatusCodeType } from '../fhirValueSets/PublicationStatusCodes.js';
// @ts-ignore
import { PublicationStatusVsValidation } from '../fhirValueSets/PublicationStatusVsValidation.js';
// @ts-ignore
import { JurisdictionCodes,  JurisdictionCodeType } from '../fhirValueSets/JurisdictionCodes.js';
// @ts-ignore
import { JurisdictionVsValidation } from '../fhirValueSets/JurisdictionVsValidation.js';
// @ts-ignore
import { DataelementStringencyCodes,  DataelementStringencyCodeType } from '../fhirValueSets/DataelementStringencyCodes.js';
// @ts-ignore
import { DataelementStringencyVsValidation } from '../fhirValueSets/DataelementStringencyVsValidation.js';
/**
 * Valid arguments for the DataElementMapping type.
 */
export interface DataElementMappingArgs extends fhir.BackboneElementArgs {
  /**
   * The specification is described once, with general comments, and then specific mappings are made that reference this declaration.
   */
  identity: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.mapping.identity
   */
  _identity?:fhir.FhirElementArgs;
  /**
   * A formal identity for the specification being mapped to helps with identifying maps consistently.
   */
  uri?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.mapping.uri
   */
  _uri?:fhir.FhirElementArgs;
  /**
   * A name for the specification that is being mapped to.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.mapping.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
   */
  comment?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.mapping.comment
   */
  _comment?:fhir.FhirElementArgs;
}

/**
 * Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
 */
export class DataElementMapping extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'DataElementMapping';
  /**
   * The specification is described once, with general comments, and then specific mappings are made that reference this declaration.
   */
  public identity: fhir.FhirId|null;
  /**
   * A formal identity for the specification being mapped to helps with identifying maps consistently.
   */
  public uri?: fhir.FhirUri|undefined;
  /**
   * A name for the specification that is being mapped to.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
   */
  public comment?: fhir.FhirString|undefined;
  /**
   * Default constructor for DataElementMapping - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<DataElementMappingArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identity']) { this.identity = new fhir.FhirId({value: source.identity}); }
    else { this.identity = null; }
    if (source['_identity']) {
      if (this.identity) { this.identity.addExtendedProperties(source._identity!); }
      else { this.identity = new fhir.FhirId(source._identity as Partial<fhir.FhirIdArgs>); }
    }
    if (source['uri']) { this.uri = new fhir.FhirUri({value: source.uri}); }
    if (source['_uri']) {
      if (this.uri) { this.uri.addExtendedProperties(source._uri!); }
      else { this.uri = new fhir.FhirUri(source._uri as Partial<fhir.FhirUriArgs>); }
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['comment']) { this.comment = new fhir.FhirString({value: source.comment}); }
    if (source['_comment']) {
      if (this.comment) { this.comment.addExtendedProperties(source._comment!); }
      else { this.comment = new fhir.FhirString(source._comment as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'DataElement.mapping' }
    this.vRS('identity',exp)
    this.vOS('uri',exp)
    this.vOS('name',exp)
    this.vOS('comment',exp)
    return issues;
  }
}
/**
 * Valid arguments for the DataElement type.
 */
export interface DataElementArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "DataElement"|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
   */
  url?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this data element outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * There may be different data element instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the data element with the format [url]|[version].
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * Allows filtering of data elements that are appropriate for use vs. not.  
   * This is labeled as "Is Modifier" because applications should not use a retired data element without due consideration.
   */
  status: fhir.FhirCode<PublicationStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * Allows filtering of data element that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental data element in production.
   */
  experimental?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: DataElement.experimental
   */
  _experimental?:fhir.FhirElementArgs;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the data element. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Usually an organization, but may be an individual. The publisher (or steward) of the data element is the organization or individual primarily responsible for the maintenance and upkeep of the data element. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the data element. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.publisher
   */
  _publisher?:fhir.FhirElementArgs;
  /**
   * The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc. This may be similar to the question used to prompt someone for a data element value, but the purpose is communicating about the data element, not asking the question.  (Refer to the 'question' element for the latter.).
   */
  title?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.title
   */
  _title?:fhir.FhirElementArgs;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  contact?: fhir.ContactDetailArgs[]|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
   */
  useContext?: fhir.UsageContextArgs[]|undefined;
  /**
   * It may be possible for the data element to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  jurisdiction?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * null The copyright statement does not apply to values for the data element, only to its definition.
   */
  copyright?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.copyright
   */
  _copyright?:fhir.FhirElementArgs;
  /**
   * Identifies how precise the data element is in its definition.
   */
  stringency?: fhir.FhirCode<DataelementStringencyCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: DataElement.stringency
   */
  _stringency?:fhir.FhirElementArgs;
  /**
   * Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
   */
  mapping?: fhir.DataElementMappingArgs[]|undefined;
  /**
   * For simple data types there will only be one repetition.  For complex data types, multiple repetitions will be present defining a nested structure using the "path" element.
   */
  element: fhir.ElementDefinitionArgs[]|null;
}

/**
 * The formal description of a single piece of information that can be gathered and reported.
 */
export class DataElement extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'DataElement';
  /**
   * Resource Type Name
   */
  public override resourceType: "DataElement";
  /**
   * Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
   */
  public url?: fhir.FhirUri|undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this data element outside of FHIR, where it is not possible to use the logical URI.
   */
  public identifier: fhir.Identifier[];
  /**
   * There may be different data element instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the data element with the format [url]|[version].
   */
  public version?: fhir.FhirString|undefined;
  /**
   * Allows filtering of data elements that are appropriate for use vs. not.  
   * This is labeled as "Is Modifier" because applications should not use a retired data element without due consideration.
   */
  public status: fhir.FhirCode<PublicationStatusCodeType>|null;
  /**
   * Allows filtering of data element that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental data element in production.
   */
  public experimental?: fhir.FhirBoolean|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the data element. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Usually an organization, but may be an individual. The publisher (or steward) of the data element is the organization or individual primarily responsible for the maintenance and upkeep of the data element. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the data element. This item SHOULD be populated unless the information is available from context.
   */
  public publisher?: fhir.FhirString|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc. This may be similar to the question used to prompt someone for a data element value, but the purpose is communicating about the data element, not asking the question.  (Refer to the 'question' element for the latter.).
   */
  public title?: fhir.FhirString|undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  public contact: fhir.ContactDetail[];
  /**
   * When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
   */
  public useContext: fhir.UsageContext[];
  /**
   * It may be possible for the data element to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  public jurisdiction: fhir.CodeableConcept[];
  /**
   * null The copyright statement does not apply to values for the data element, only to its definition.
   */
  public copyright?: fhir.FhirMarkdown|undefined;
  /**
   * Identifies how precise the data element is in its definition.
   */
  public stringency?: fhir.FhirCode<DataelementStringencyCodeType>|undefined;
  /**
   * Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
   */
  public mapping: fhir.DataElementMapping[];
  /**
   * For simple data types there will only be one repetition.  For complex data types, multiple repetitions will be present defining a nested structure using the "path" element.
   */
  public element: fhir.ElementDefinition[];
  /**
   * Default constructor for DataElement - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<DataElementArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'DataElement';
    if (source['url']) { this.url = new fhir.FhirUri({value: source.url}); }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>); }
    }
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['version']) { this.version = new fhir.FhirString({value: source.version}); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>); }
    }
    if (source['status']) { this.status = new fhir.FhirCode<PublicationStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<PublicationStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['experimental']) { this.experimental = new fhir.FhirBoolean({value: source.experimental}); }
    if (source['_experimental']) {
      if (this.experimental) { this.experimental.addExtendedProperties(source._experimental!); }
      else { this.experimental = new fhir.FhirBoolean(source._experimental as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['publisher']) { this.publisher = new fhir.FhirString({value: source.publisher}); }
    if (source['_publisher']) {
      if (this.publisher) { this.publisher.addExtendedProperties(source._publisher!); }
      else { this.publisher = new fhir.FhirString(source._publisher as Partial<fhir.FhirStringArgs>); }
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['title']) { this.title = new fhir.FhirString({value: source.title}); }
    if (source['_title']) {
      if (this.title) { this.title.addExtendedProperties(source._title!); }
      else { this.title = new fhir.FhirString(source._title as Partial<fhir.FhirStringArgs>); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.ContactDetail(x)); }
    else { this.contact = []; }
    if (source['useContext']) { this.useContext = source.useContext.map((x) => new fhir.UsageContext(x)); }
    else { this.useContext = []; }
    if (source['jurisdiction']) { this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x)); }
    else { this.jurisdiction = []; }
    if (source['copyright']) { this.copyright = new fhir.FhirMarkdown({value: source.copyright}); }
    if (source['_copyright']) {
      if (this.copyright) { this.copyright.addExtendedProperties(source._copyright!); }
      else { this.copyright = new fhir.FhirMarkdown(source._copyright as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['stringency']) { this.stringency = new fhir.FhirCode<DataelementStringencyCodeType>({value: source.stringency}); }
    if (source['_stringency']) {
      if (this.stringency) { this.stringency.addExtendedProperties(source._stringency!); }
      else { this.stringency = new fhir.FhirCode<DataelementStringencyCodeType>(source._stringency as Partial<fhir.FhirCode>); }
    }
    if (source['mapping']) { this.mapping = source.mapping.map((x) => new fhir.DataElementMapping(x)); }
    else { this.mapping = []; }
    if (source['element']) { this.element = source.element.map((x) => new fhir.ElementDefinition(x)); }
    else { this.element = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'DataElement' }
    this.vRS('resourceType',exp)
    this.vOS('url',exp)
    this.vOA('identifier',exp)
    this.vOS('version',exp)
    this.vRSV('status',exp,'PublicationStatus',PublicationStatusVsValidation,'r')
    this.vOS('experimental',exp)
    this.vOS('date',exp)
    this.vOS('publisher',exp)
    this.vOS('name',exp)
    this.vOS('title',exp)
    this.vOA('contact',exp)
    this.vOA('useContext',exp)
    this.vOA('jurisdiction',exp)
    this.vOS('copyright',exp)
    this.vOSV('stringency',exp,'DataelementStringency',DataelementStringencyVsValidation,'r')
    this.vOA('mapping',exp)
    this.vRA('element',exp)
    return issues;
  }
}
