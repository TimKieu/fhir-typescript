// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Claim

import * as fhir from '../fhir.js';

// @ts-ignore
import { RelatedClaimRelationshipCodes,  RelatedClaimRelationshipCodeType } from '../fhirValueSets/RelatedClaimRelationshipCodes.js';
// @ts-ignore
import { RelatedClaimRelationshipVsValidation } from '../fhirValueSets/RelatedClaimRelationshipVsValidation.js';
// @ts-ignore
import { PayeetypeCodes,  PayeetypeCodeType } from '../fhirValueSets/PayeetypeCodes.js';
// @ts-ignore
import { PayeetypeVsValidation } from '../fhirValueSets/PayeetypeVsValidation.js';
// @ts-ignore
import { ExPayeeResourceTypeCodes,  ExPayeeResourceTypeCodeType } from '../fhirValueSets/ExPayeeResourceTypeCodes.js';
// @ts-ignore
import { ExPayeeResourceTypeVsValidation } from '../fhirValueSets/ExPayeeResourceTypeVsValidation.js';
// @ts-ignore
import { ClaimCareteamroleCodes,  ClaimCareteamroleCodeType } from '../fhirValueSets/ClaimCareteamroleCodes.js';
// @ts-ignore
import { ClaimCareteamroleVsValidation } from '../fhirValueSets/ClaimCareteamroleVsValidation.js';
// @ts-ignore
import { ProviderQualificationCodes,  ProviderQualificationCodeType } from '../fhirValueSets/ProviderQualificationCodes.js';
// @ts-ignore
import { ProviderQualificationVsValidation } from '../fhirValueSets/ProviderQualificationVsValidation.js';
// @ts-ignore
import { ClaimInformationcategoryCodes,  ClaimInformationcategoryCodeType } from '../fhirValueSets/ClaimInformationcategoryCodes.js';
// @ts-ignore
import { ClaimInformationcategoryVsValidation } from '../fhirValueSets/ClaimInformationcategoryVsValidation.js';
// @ts-ignore
import { ClaimExceptionCodes,  ClaimExceptionCodeType } from '../fhirValueSets/ClaimExceptionCodes.js';
// @ts-ignore
import { ClaimExceptionVsValidation } from '../fhirValueSets/ClaimExceptionVsValidation.js';
// @ts-ignore
import { MissingToothReasonCodes,  MissingToothReasonCodeType } from '../fhirValueSets/MissingToothReasonCodes.js';
// @ts-ignore
import { MissingToothReasonVsValidation } from '../fhirValueSets/MissingToothReasonVsValidation.js';
// @ts-ignore
import { ExDiagnosistypeCodes,  ExDiagnosistypeCodeType } from '../fhirValueSets/ExDiagnosistypeCodes.js';
// @ts-ignore
import { ExDiagnosistypeVsValidation } from '../fhirValueSets/ExDiagnosistypeVsValidation.js';
// @ts-ignore
import { ExDiagnosisrelatedgroupCodes,  ExDiagnosisrelatedgroupCodeType } from '../fhirValueSets/ExDiagnosisrelatedgroupCodes.js';
// @ts-ignore
import { ExDiagnosisrelatedgroupVsValidation } from '../fhirValueSets/ExDiagnosisrelatedgroupVsValidation.js';
// @ts-ignore
import { V3ActIncidentCodes,  V3ActIncidentCodeType } from '../fhirValueSets/V3ActIncidentCodes.js';
// @ts-ignore
import { V3ActIncidentVsValidation } from '../fhirValueSets/V3ActIncidentVsValidation.js';
// @ts-ignore
import { ExRevenueCenterCodes,  ExRevenueCenterCodeType } from '../fhirValueSets/ExRevenueCenterCodes.js';
// @ts-ignore
import { ExRevenueCenterVsValidation } from '../fhirValueSets/ExRevenueCenterVsValidation.js';
// @ts-ignore
import { BenefitSubcategoryCodes,  BenefitSubcategoryCodeType } from '../fhirValueSets/BenefitSubcategoryCodes.js';
// @ts-ignore
import { BenefitSubcategoryVsValidation } from '../fhirValueSets/BenefitSubcategoryVsValidation.js';
// @ts-ignore
import { ServiceUsclsCodes,  ServiceUsclsCodeType } from '../fhirValueSets/ServiceUsclsCodes.js';
// @ts-ignore
import { ServiceUsclsVsValidation } from '../fhirValueSets/ServiceUsclsVsValidation.js';
// @ts-ignore
import { ClaimModifiersCodes,  ClaimModifiersCodeType } from '../fhirValueSets/ClaimModifiersCodes.js';
// @ts-ignore
import { ClaimModifiersVsValidation } from '../fhirValueSets/ClaimModifiersVsValidation.js';
// @ts-ignore
import { ExProgramCodes,  ExProgramCodeType } from '../fhirValueSets/ExProgramCodes.js';
// @ts-ignore
import { ExProgramVsValidation } from '../fhirValueSets/ExProgramVsValidation.js';
// @ts-ignore
import { ToothCodes,  ToothCodeType } from '../fhirValueSets/ToothCodes.js';
// @ts-ignore
import { ToothVsValidation } from '../fhirValueSets/ToothVsValidation.js';
// @ts-ignore
import { SurfaceCodes,  SurfaceCodeType } from '../fhirValueSets/SurfaceCodes.js';
// @ts-ignore
import { SurfaceVsValidation } from '../fhirValueSets/SurfaceVsValidation.js';
// @ts-ignore
import { FmStatusCodes,  FmStatusCodeType } from '../fhirValueSets/FmStatusCodes.js';
// @ts-ignore
import { FmStatusVsValidation } from '../fhirValueSets/FmStatusVsValidation.js';
// @ts-ignore
import { ClaimTypeCodes,  ClaimTypeCodeType } from '../fhirValueSets/ClaimTypeCodes.js';
// @ts-ignore
import { ClaimTypeVsValidation } from '../fhirValueSets/ClaimTypeVsValidation.js';
// @ts-ignore
import { ClaimSubtypeCodes,  ClaimSubtypeCodeType } from '../fhirValueSets/ClaimSubtypeCodes.js';
// @ts-ignore
import { ClaimSubtypeVsValidation } from '../fhirValueSets/ClaimSubtypeVsValidation.js';
// @ts-ignore
import { ClaimUseCodes,  ClaimUseCodeType } from '../fhirValueSets/ClaimUseCodes.js';
// @ts-ignore
import { ClaimUseVsValidation } from '../fhirValueSets/ClaimUseVsValidation.js';
// @ts-ignore
import { ProcessPriorityCodes,  ProcessPriorityCodeType } from '../fhirValueSets/ProcessPriorityCodes.js';
// @ts-ignore
import { ProcessPriorityVsValidation } from '../fhirValueSets/ProcessPriorityVsValidation.js';
// @ts-ignore
import { FundsreserveCodes,  FundsreserveCodeType } from '../fhirValueSets/FundsreserveCodes.js';
// @ts-ignore
import { FundsreserveVsValidation } from '../fhirValueSets/FundsreserveVsValidation.js';
/**
 * Valid arguments for the ClaimRelated type.
 */
export interface ClaimRelatedArgs extends fhir.BackboneElementArgs {
  /**
   * Do we need a relationship code?
   */
  claim?: fhir.ReferenceArgs|undefined;
  /**
   * For example prior or umbrella.
   */
  relationship?: fhir.CodeableConceptArgs|undefined;
  /**
   * An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # .
   */
  reference?: fhir.IdentifierArgs|undefined;
}

/**
 * Other claims which are related to this claim such as prior claim versions or for related services.
 */
export class ClaimRelated extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimRelated';
  /**
   * Do we need a relationship code?
   */
  public claim?: fhir.Reference|undefined;
  /**
   * For example prior or umbrella.
   */
  public relationship?: fhir.CodeableConcept|undefined;
  /**
   * An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # .
   */
  public reference?: fhir.Identifier|undefined;
  /**
   * Default constructor for ClaimRelated - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimRelatedArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['claim']) { this.claim = new fhir.Reference(source.claim); }
    if (source['relationship']) { this.relationship = new fhir.CodeableConcept(source.relationship); }
    if (source['reference']) { this.reference = new fhir.Identifier(source.reference); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.related' }
    this.vOS('claim',exp)
    this.vOS('relationship',exp)
    this.vOS('reference',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimPayee type.
 */
export interface ClaimPayeeArgs extends fhir.BackboneElementArgs {
  /**
   * Type of Party to be reimbursed: Subscriber, provider, other.
   */
  type: fhir.CodeableConceptArgs|null;
  /**
   * organization | patient | practitioner | relatedperson.
   */
  resourceType?: fhir.CodingArgs|undefined;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  party?: fhir.ReferenceArgs|undefined;
}

/**
 * The party to be reimbursed for the services.
 */
export class ClaimPayee extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimPayee';
  /**
   * Type of Party to be reimbursed: Subscriber, provider, other.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * organization | patient | practitioner | relatedperson.
   */
  public resourceType?: fhir.Coding|undefined;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  public party?: fhir.Reference|undefined;
  /**
   * Default constructor for ClaimPayee - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimPayeeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    else { this.type = null; }
    if (source['resourceType']) { this.resourceType = new fhir.Coding(source.resourceType); }
    if (source['party']) { this.party = new fhir.Reference(source.party); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.payee' }
    this.vRS('type',exp)
    this.vOS('resourceType',exp)
    this.vOS('party',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimCareTeam type.
 */
export interface ClaimCareTeamArgs extends fhir.BackboneElementArgs {
  /**
   * Sequence of the careTeam which serves to order and provide a link.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.careTeam.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * Member of the team who provided the overall service.
   */
  provider: fhir.ReferenceArgs|null;
  /**
   * The party who is billing and responsible for the claimed good or service rendered to the patient.
   */
  responsible?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Claim.careTeam.responsible
   */
  _responsible?:fhir.FhirElementArgs;
  /**
   * The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team.
   */
  role?: fhir.CodeableConceptArgs|undefined;
  /**
   * The qualification which is applicable for this service.
   */
  qualification?: fhir.CodeableConceptArgs|undefined;
}

/**
 * The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
 */
export class ClaimCareTeam extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimCareTeam';
  /**
   * Sequence of the careTeam which serves to order and provide a link.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * Member of the team who provided the overall service.
   */
  public provider: fhir.Reference|null;
  /**
   * The party who is billing and responsible for the claimed good or service rendered to the patient.
   */
  public responsible?: fhir.FhirBoolean|undefined;
  /**
   * The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * The qualification which is applicable for this service.
   */
  public qualification?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ClaimCareTeam - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimCareTeamArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['provider']) { this.provider = new fhir.Reference(source.provider); }
    else { this.provider = null; }
    if (source['responsible']) { this.responsible = new fhir.FhirBoolean({value: source.responsible}); }
    if (source['_responsible']) {
      if (this.responsible) { this.responsible.addExtendedProperties(source._responsible!); }
      else { this.responsible = new fhir.FhirBoolean(source._responsible as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    if (source['qualification']) { this.qualification = new fhir.CodeableConcept(source.qualification); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.careTeam' }
    this.vRS('sequence',exp)
    this.vRS('provider',exp)
    this.vOS('responsible',exp)
    this.vOS('role',exp)
    this.vOS('qualification',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimInformation type.
 */
export interface ClaimInformationArgs extends fhir.BackboneElementArgs {
  /**
   * Sequence of the information element which serves to provide a link.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.information.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  category: fhir.CodeableConceptArgs|null;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * The date when or period to which this information refers.
   */
  timing?: fhir.FhirDate|fhir.Period|undefined;
  /**
   * The date when or period to which this information refers.
   */
  timingDate?: fhir.FhirDate|string|undefined;
  /**
   * The date when or period to which this information refers.
   */
  timingPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  value?: fhir.FhirString|fhir.Quantity|fhir.Attachment|fhir.Reference|undefined;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  valueString?: fhir.FhirString|string|undefined;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  valueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  valueReference?: fhir.ReferenceArgs|undefined;
  /**
   * For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content.
   */
  reason?: fhir.CodeableConceptArgs|undefined;
}

/**
 * Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
 */
export class ClaimInformation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimInformation';
  /**
   * Sequence of the information element which serves to provide a link.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  public category: fhir.CodeableConcept|null;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * The date when or period to which this information refers.
   */
  public timing?: (fhir.FhirDate|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Claim.information.timing[x]
   */
  protected static readonly _fts_timingIsChoice:true = true;
  /**
   * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
   */
  public value?: (fhir.FhirString|fhir.Quantity|fhir.Attachment|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Claim.information.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content.
   */
  public reason?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ClaimInformation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimInformationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    else { this.category = null; }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['timing']) { this.timing = source.timing; }
    else if (source['timingDate']) { this.timing = new fhir.FhirDate({value: source.timingDate}); }
    else if (source['timingPeriod']) { this.timing = new fhir.Period(source.timingPeriod); }
    if (source['value']) { this.value = source.value; }
    else if (source['valueString']) { this.value = new fhir.FhirString({value: source.valueString}); }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueAttachment']) { this.value = new fhir.Attachment(source.valueAttachment); }
    else if (source['valueReference']) { this.value = new fhir.Reference(source.valueReference); }
    if (source['reason']) { this.reason = new fhir.CodeableConcept(source.reason); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.information' }
    this.vRS('sequence',exp)
    this.vRS('category',exp)
    this.vOS('code',exp)
    this.vOS('timing',exp)
    this.vOS('value',exp)
    this.vOS('reason',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimDiagnosis type.
 */
export interface ClaimDiagnosisArgs extends fhir.BackboneElementArgs {
  /**
   * Sequence of diagnosis which serves to provide a link.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.diagnosis.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * The diagnosis.
   */
  diagnosis?: fhir.CodeableConcept|fhir.Reference|undefined;
  /**
   * The diagnosis.
   */
  diagnosisCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The diagnosis.
   */
  diagnosisReference?: fhir.ReferenceArgs|undefined;
  /**
   * Diagnosis are presented in list order to their expected importance: primary, secondary, etc.
   */
  type?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The package billing code, for example DRG, based on the assigned grouping code system.
   */
  packageCode?: fhir.CodeableConceptArgs|undefined;
}

/**
 * List of patient diagnosis for which care is sought.
 */
export class ClaimDiagnosis extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimDiagnosis';
  /**
   * Sequence of diagnosis which serves to provide a link.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * The diagnosis.
   */
  public diagnosis: (fhir.CodeableConcept|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element Claim.diagnosis.diagnosis[x]
   */
  protected static readonly _fts_diagnosisIsChoice:true = true;
  /**
   * Diagnosis are presented in list order to their expected importance: primary, secondary, etc.
   */
  public type: fhir.CodeableConcept[];
  /**
   * The package billing code, for example DRG, based on the assigned grouping code system.
   */
  public packageCode?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ClaimDiagnosis - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimDiagnosisArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['diagnosis']) { this.diagnosis = source.diagnosis; }
    else if (source['diagnosisCodeableConcept']) { this.diagnosis = new fhir.CodeableConcept(source.diagnosisCodeableConcept); }
    else if (source['diagnosisReference']) { this.diagnosis = new fhir.Reference(source.diagnosisReference); }
    else { this.diagnosis = null; }
    if (source['type']) { this.type = source.type.map((x) => new fhir.CodeableConcept(x)); }
    else { this.type = []; }
    if (source['packageCode']) { this.packageCode = new fhir.CodeableConcept(source.packageCode); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.diagnosis' }
    this.vRS('sequence',exp)
    this.vRS('diagnosis',exp)
    this.vOA('type',exp)
    this.vOS('packageCode',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimProcedure type.
 */
export interface ClaimProcedureArgs extends fhir.BackboneElementArgs {
  /**
   * Sequence of procedures which serves to order and provide a link.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.procedure.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * SB DateTime??
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Claim.procedure.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * The procedure code.
   */
  procedure?: fhir.CodeableConcept|fhir.Reference|undefined;
  /**
   * The procedure code.
   */
  procedureCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The procedure code.
   */
  procedureReference?: fhir.ReferenceArgs|undefined;
}

/**
 * Ordered list of patient procedures performed to support the adjudication.
 */
export class ClaimProcedure extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimProcedure';
  /**
   * Sequence of procedures which serves to order and provide a link.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * SB DateTime??
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * The procedure code.
   */
  public procedure: (fhir.CodeableConcept|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element Claim.procedure.procedure[x]
   */
  protected static readonly _fts_procedureIsChoice:true = true;
  /**
   * Default constructor for ClaimProcedure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimProcedureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['procedure']) { this.procedure = source.procedure; }
    else if (source['procedureCodeableConcept']) { this.procedure = new fhir.CodeableConcept(source.procedureCodeableConcept); }
    else if (source['procedureReference']) { this.procedure = new fhir.Reference(source.procedureReference); }
    else { this.procedure = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.procedure' }
    this.vRS('sequence',exp)
    this.vOS('date',exp)
    this.vRS('procedure',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimInsurance type.
 */
export interface ClaimInsuranceArgs extends fhir.BackboneElementArgs {
  /**
   * Sequence of coverage which serves to provide a link and convey coordination of benefit order.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.insurance.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * A flag to indicate that this Coverage is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
   */
  focal: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Claim.insurance.focal
   */
  _focal?:fhir.FhirElementArgs;
  /**
   * Reference to the program or plan identification, underwriter or payor.
   */
  coverage: fhir.ReferenceArgs|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  businessArrangement?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Claim.insurance.businessArrangement
   */
  _businessArrangement?:fhir.FhirElementArgs;
  /**
   * A list of references from the Insurer to which these services pertain.
   */
  preAuthRef?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: Claim.insurance.preAuthRef
   */
  _preAuthRef?:(fhir.FhirElementArgs|null)[];
  /**
   * The Coverages adjudication details.
   */
  claimResponse?: fhir.ReferenceArgs|undefined;
}

/**
 * Financial instrument by which payment information for health care.
 */
export class ClaimInsurance extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimInsurance';
  /**
   * Sequence of coverage which serves to provide a link and convey coordination of benefit order.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * A flag to indicate that this Coverage is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
   */
  public focal: fhir.FhirBoolean|null;
  /**
   * Reference to the program or plan identification, underwriter or payor.
   */
  public coverage: fhir.Reference|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  public businessArrangement?: fhir.FhirString|undefined;
  /**
   * A list of references from the Insurer to which these services pertain.
   */
  public preAuthRef: fhir.FhirString[];
  /**
   * The Coverages adjudication details.
   */
  public claimResponse?: fhir.Reference|undefined;
  /**
   * Default constructor for ClaimInsurance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimInsuranceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['focal']) { this.focal = new fhir.FhirBoolean({value: source.focal}); }
    else { this.focal = null; }
    if (source['_focal']) {
      if (this.focal) { this.focal.addExtendedProperties(source._focal!); }
      else { this.focal = new fhir.FhirBoolean(source._focal as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['coverage']) { this.coverage = new fhir.Reference(source.coverage); }
    else { this.coverage = null; }
    if (source['businessArrangement']) { this.businessArrangement = new fhir.FhirString({value: source.businessArrangement}); }
    if (source['_businessArrangement']) {
      if (this.businessArrangement) { this.businessArrangement.addExtendedProperties(source._businessArrangement!); }
      else { this.businessArrangement = new fhir.FhirString(source._businessArrangement as Partial<fhir.FhirStringArgs>); }
    }
    if (source['preAuthRef']) { this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({value: x})); }
    else { this.preAuthRef = []; }
    if (source['_preAuthRef']) {
      source._preAuthRef.forEach((x,i) => {
        if (this.preAuthRef.length >= i) { if (x) { this.preAuthRef[i].addExtendedProperties(x); } }
        else { if (x) { this.preAuthRef.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['claimResponse']) { this.claimResponse = new fhir.Reference(source.claimResponse); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.insurance' }
    this.vRS('sequence',exp)
    this.vRS('focal',exp)
    this.vRS('coverage',exp)
    this.vOS('businessArrangement',exp)
    this.vOA('preAuthRef',exp)
    this.vOS('claimResponse',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimAccident type.
 */
export interface ClaimAccidentArgs extends fhir.BackboneElementArgs {
  /**
   * Date of an accident which these services are addressing.
   */
  date: fhir.FhirDate|string|undefined;
  /**
   * Extended properties for primitive element: Claim.accident.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Type of accident: work, auto, etc.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Accident Place.
   */
  location?: fhir.Address|fhir.Reference|undefined;
  /**
   * Accident Place.
   */
  locationAddress?: fhir.AddressArgs|undefined;
  /**
   * Accident Place.
   */
  locationReference?: fhir.ReferenceArgs|undefined;
}

/**
 * An accident which resulted in the need for healthcare services.
 */
export class ClaimAccident extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimAccident';
  /**
   * Date of an accident which these services are addressing.
   */
  public date: fhir.FhirDate|null;
  /**
   * Type of accident: work, auto, etc.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Accident Place.
   */
  public location?: (fhir.Address|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Claim.accident.location[x]
   */
  protected static readonly _fts_locationIsChoice:true = true;
  /**
   * Default constructor for ClaimAccident - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimAccidentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['date']) { this.date = new fhir.FhirDate({value: source.date}); }
    else { this.date = null; }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDate(source._date as Partial<fhir.FhirDateArgs>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['location']) { this.location = source.location; }
    else if (source['locationAddress']) { this.location = new fhir.Address(source.locationAddress); }
    else if (source['locationReference']) { this.location = new fhir.Reference(source.locationReference); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.accident' }
    this.vRS('date',exp)
    this.vOSV('type',exp,'V3ActIncident',V3ActIncidentVsValidation,'r')
    this.vOS('location',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimItemDetailSubDetail type.
 */
export interface ClaimItemDetailSubDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.detail.subDetail.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  revenue?: fhir.CodeableConceptArgs|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
   */
  service?: fhir.CodeableConceptArgs|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  modifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
   */
  programCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The number of repetitions of a service or product.
   */
  quantity?: fhir.QuantityArgs|undefined;
  /**
   * The fee for an addittional service or product or charge.
   */
  unitPrice?: fhir.MoneyArgs|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  factor?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.detail.subDetail.factor
   */
  _factor?:fhir.FhirElementArgs;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  net?: fhir.MoneyArgs|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  udi?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Third tier of goods and services.
 */
export class ClaimItemDetailSubDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimItemDetailSubDetail';
  /**
   * A service line number.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  public revenue?: fhir.CodeableConcept|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
   */
  public service?: fhir.CodeableConcept|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  public modifier: fhir.CodeableConcept[];
  /**
   * For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
   */
  public programCode: fhir.CodeableConcept[];
  /**
   * The number of repetitions of a service or product.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * The fee for an addittional service or product or charge.
   */
  public unitPrice?: fhir.Money|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  public factor?: fhir.FhirDecimal|undefined;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  public net?: fhir.Money|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  public udi: fhir.Reference[];
  /**
   * Default constructor for ClaimItemDetailSubDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimItemDetailSubDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['revenue']) { this.revenue = new fhir.CodeableConcept(source.revenue); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['service']) { this.service = new fhir.CodeableConcept(source.service); }
    if (source['modifier']) { this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.modifier = []; }
    if (source['programCode']) { this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.programCode = []; }
    if (source['quantity']) { this.quantity = new fhir.Quantity(source.quantity); }
    if (source['unitPrice']) { this.unitPrice = new fhir.Money(source.unitPrice); }
    if (source['factor']) { this.factor = new fhir.FhirDecimal({value: source.factor}); }
    if (source['_factor']) {
      if (this.factor) { this.factor.addExtendedProperties(source._factor!); }
      else { this.factor = new fhir.FhirDecimal(source._factor as Partial<fhir.FhirDecimalArgs>); }
    }
    if (source['net']) { this.net = new fhir.Money(source.net); }
    if (source['udi']) { this.udi = source.udi.map((x) => new fhir.Reference(x)); }
    else { this.udi = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.item.detail.subDetail' }
    this.vRS('sequence',exp)
    this.vOS('revenue',exp)
    this.vOS('category',exp)
    this.vOS('service',exp)
    this.vOA('modifier',exp)
    this.vOA('programCode',exp)
    this.vOS('quantity',exp)
    this.vOS('unitPrice',exp)
    this.vOS('factor',exp)
    this.vOS('net',exp)
    this.vOA('udi',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimItemDetail type.
 */
export interface ClaimItemDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.detail.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  revenue?: fhir.CodeableConceptArgs|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
   */
  service?: fhir.CodeableConceptArgs|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  modifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
   */
  programCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The number of repetitions of a service or product.
   */
  quantity?: fhir.QuantityArgs|undefined;
  /**
   * If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
   */
  unitPrice?: fhir.MoneyArgs|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  factor?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.detail.factor
   */
  _factor?:fhir.FhirElementArgs;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  net?: fhir.MoneyArgs|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  udi?: fhir.ReferenceArgs[]|undefined;
  /**
   * Third tier of goods and services.
   */
  subDetail?: fhir.ClaimItemDetailSubDetailArgs[]|undefined;
}

/**
 * Second tier of goods and services.
 */
export class ClaimItemDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimItemDetail';
  /**
   * A service line number.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  public revenue?: fhir.CodeableConcept|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
   */
  public service?: fhir.CodeableConcept|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  public modifier: fhir.CodeableConcept[];
  /**
   * For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
   */
  public programCode: fhir.CodeableConcept[];
  /**
   * The number of repetitions of a service or product.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
   */
  public unitPrice?: fhir.Money|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  public factor?: fhir.FhirDecimal|undefined;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  public net?: fhir.Money|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  public udi: fhir.Reference[];
  /**
   * Third tier of goods and services.
   */
  public subDetail: fhir.ClaimItemDetailSubDetail[];
  /**
   * Default constructor for ClaimItemDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimItemDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['revenue']) { this.revenue = new fhir.CodeableConcept(source.revenue); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['service']) { this.service = new fhir.CodeableConcept(source.service); }
    if (source['modifier']) { this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.modifier = []; }
    if (source['programCode']) { this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.programCode = []; }
    if (source['quantity']) { this.quantity = new fhir.Quantity(source.quantity); }
    if (source['unitPrice']) { this.unitPrice = new fhir.Money(source.unitPrice); }
    if (source['factor']) { this.factor = new fhir.FhirDecimal({value: source.factor}); }
    if (source['_factor']) {
      if (this.factor) { this.factor.addExtendedProperties(source._factor!); }
      else { this.factor = new fhir.FhirDecimal(source._factor as Partial<fhir.FhirDecimalArgs>); }
    }
    if (source['net']) { this.net = new fhir.Money(source.net); }
    if (source['udi']) { this.udi = source.udi.map((x) => new fhir.Reference(x)); }
    else { this.udi = []; }
    if (source['subDetail']) { this.subDetail = source.subDetail.map((x) => new fhir.ClaimItemDetailSubDetail(x)); }
    else { this.subDetail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.item.detail' }
    this.vRS('sequence',exp)
    this.vOS('revenue',exp)
    this.vOS('category',exp)
    this.vOS('service',exp)
    this.vOA('modifier',exp)
    this.vOA('programCode',exp)
    this.vOS('quantity',exp)
    this.vOS('unitPrice',exp)
    this.vOS('factor',exp)
    this.vOS('net',exp)
    this.vOA('udi',exp)
    this.vOA('subDetail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimItem type.
 */
export interface ClaimItemArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * CareTeam applicable for this service or product line.
   */
  careTeamLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: Claim.item.careTeamLinkId
   */
  _careTeamLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * Diagnosis applicable for this service or product line.
   */
  diagnosisLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: Claim.item.diagnosisLinkId
   */
  _diagnosisLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * Procedures applicable for this service or product line.
   */
  procedureLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: Claim.item.procedureLinkId
   */
  _procedureLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * Exceptions, special conditions and supporting information pplicable for this service or product line.
   */
  informationLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: Claim.item.informationLinkId
   */
  _informationLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  revenue?: fhir.CodeableConceptArgs|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
   */
  service?: fhir.CodeableConceptArgs|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  modifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * For programs which require reason codes for the inclusion or covering of this billed item under the program or sub-program.
   */
  programCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The date or dates when the enclosed suite of services were performed or completed.
   */
  serviced?: fhir.FhirDate|fhir.Period|undefined;
  /**
   * The date or dates when the enclosed suite of services were performed or completed.
   */
  servicedDate?: fhir.FhirDate|string|undefined;
  /**
   * The date or dates when the enclosed suite of services were performed or completed.
   */
  servicedPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Where the service was provided.
   */
  location?: fhir.CodeableConcept|fhir.Address|fhir.Reference|undefined;
  /**
   * Where the service was provided.
   */
  locationCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Where the service was provided.
   */
  locationAddress?: fhir.AddressArgs|undefined;
  /**
   * Where the service was provided.
   */
  locationReference?: fhir.ReferenceArgs|undefined;
  /**
   * The number of repetitions of a service or product.
   */
  quantity?: fhir.QuantityArgs|undefined;
  /**
   * If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
   */
  unitPrice?: fhir.MoneyArgs|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  factor?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Claim.item.factor
   */
  _factor?:fhir.FhirElementArgs;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  net?: fhir.MoneyArgs|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  udi?: fhir.ReferenceArgs[]|undefined;
  /**
   * Physical service site on the patient (limb, tooth, etc).
   */
  bodySite?: fhir.CodeableConceptArgs|undefined;
  /**
   * A region or surface of the site, eg. limb region or tooth surface(s).
   */
  subSite?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * A billed item may include goods or services provided in multiple encounters.
   */
  encounter?: fhir.ReferenceArgs[]|undefined;
  /**
   * Second tier of goods and services.
   */
  detail?: fhir.ClaimItemDetailArgs[]|undefined;
}

/**
 * First tier of goods and services.
 */
export class ClaimItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimItem';
  /**
   * A service line number.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * CareTeam applicable for this service or product line.
   */
  public careTeamLinkId: fhir.FhirPositiveInt[];
  /**
   * Diagnosis applicable for this service or product line.
   */
  public diagnosisLinkId: fhir.FhirPositiveInt[];
  /**
   * Procedures applicable for this service or product line.
   */
  public procedureLinkId: fhir.FhirPositiveInt[];
  /**
   * Exceptions, special conditions and supporting information pplicable for this service or product line.
   */
  public informationLinkId: fhir.FhirPositiveInt[];
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  public revenue?: fhir.CodeableConcept|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
   */
  public service?: fhir.CodeableConcept|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  public modifier: fhir.CodeableConcept[];
  /**
   * For programs which require reason codes for the inclusion or covering of this billed item under the program or sub-program.
   */
  public programCode: fhir.CodeableConcept[];
  /**
   * The date or dates when the enclosed suite of services were performed or completed.
   */
  public serviced?: (fhir.FhirDate|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Claim.item.serviced[x]
   */
  protected static readonly _fts_servicedIsChoice:true = true;
  /**
   * Where the service was provided.
   */
  public location?: (fhir.CodeableConcept|fhir.Address|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Claim.item.location[x]
   */
  protected static readonly _fts_locationIsChoice:true = true;
  /**
   * The number of repetitions of a service or product.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
   */
  public unitPrice?: fhir.Money|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  public factor?: fhir.FhirDecimal|undefined;
  /**
   * The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  public net?: fhir.Money|undefined;
  /**
   * List of Unique Device Identifiers associated with this line item.
   */
  public udi: fhir.Reference[];
  /**
   * Physical service site on the patient (limb, tooth, etc).
   */
  public bodySite?: fhir.CodeableConcept|undefined;
  /**
   * A region or surface of the site, eg. limb region or tooth surface(s).
   */
  public subSite: fhir.CodeableConcept[];
  /**
   * A billed item may include goods or services provided in multiple encounters.
   */
  public encounter: fhir.Reference[];
  /**
   * Second tier of goods and services.
   */
  public detail: fhir.ClaimItemDetail[];
  /**
   * Default constructor for ClaimItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['careTeamLinkId']) { this.careTeamLinkId = source.careTeamLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.careTeamLinkId = []; }
    if (source['_careTeamLinkId']) {
      source._careTeamLinkId.forEach((x,i) => {
        if (this.careTeamLinkId.length >= i) { if (x) { this.careTeamLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.careTeamLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['diagnosisLinkId']) { this.diagnosisLinkId = source.diagnosisLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.diagnosisLinkId = []; }
    if (source['_diagnosisLinkId']) {
      source._diagnosisLinkId.forEach((x,i) => {
        if (this.diagnosisLinkId.length >= i) { if (x) { this.diagnosisLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.diagnosisLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['procedureLinkId']) { this.procedureLinkId = source.procedureLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.procedureLinkId = []; }
    if (source['_procedureLinkId']) {
      source._procedureLinkId.forEach((x,i) => {
        if (this.procedureLinkId.length >= i) { if (x) { this.procedureLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.procedureLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['informationLinkId']) { this.informationLinkId = source.informationLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.informationLinkId = []; }
    if (source['_informationLinkId']) {
      source._informationLinkId.forEach((x,i) => {
        if (this.informationLinkId.length >= i) { if (x) { this.informationLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.informationLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['revenue']) { this.revenue = new fhir.CodeableConcept(source.revenue); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['service']) { this.service = new fhir.CodeableConcept(source.service); }
    if (source['modifier']) { this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.modifier = []; }
    if (source['programCode']) { this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.programCode = []; }
    if (source['serviced']) { this.serviced = source.serviced; }
    else if (source['servicedDate']) { this.serviced = new fhir.FhirDate({value: source.servicedDate}); }
    else if (source['servicedPeriod']) { this.serviced = new fhir.Period(source.servicedPeriod); }
    if (source['location']) { this.location = source.location; }
    else if (source['locationCodeableConcept']) { this.location = new fhir.CodeableConcept(source.locationCodeableConcept); }
    else if (source['locationAddress']) { this.location = new fhir.Address(source.locationAddress); }
    else if (source['locationReference']) { this.location = new fhir.Reference(source.locationReference); }
    if (source['quantity']) { this.quantity = new fhir.Quantity(source.quantity); }
    if (source['unitPrice']) { this.unitPrice = new fhir.Money(source.unitPrice); }
    if (source['factor']) { this.factor = new fhir.FhirDecimal({value: source.factor}); }
    if (source['_factor']) {
      if (this.factor) { this.factor.addExtendedProperties(source._factor!); }
      else { this.factor = new fhir.FhirDecimal(source._factor as Partial<fhir.FhirDecimalArgs>); }
    }
    if (source['net']) { this.net = new fhir.Money(source.net); }
    if (source['udi']) { this.udi = source.udi.map((x) => new fhir.Reference(x)); }
    else { this.udi = []; }
    if (source['bodySite']) { this.bodySite = new fhir.CodeableConcept(source.bodySite); }
    if (source['subSite']) { this.subSite = source.subSite.map((x) => new fhir.CodeableConcept(x)); }
    else { this.subSite = []; }
    if (source['encounter']) { this.encounter = source.encounter.map((x) => new fhir.Reference(x)); }
    else { this.encounter = []; }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.ClaimItemDetail(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim.item' }
    this.vRS('sequence',exp)
    this.vOA('careTeamLinkId',exp)
    this.vOA('diagnosisLinkId',exp)
    this.vOA('procedureLinkId',exp)
    this.vOA('informationLinkId',exp)
    this.vOS('revenue',exp)
    this.vOS('category',exp)
    this.vOS('service',exp)
    this.vOA('modifier',exp)
    this.vOA('programCode',exp)
    this.vOS('serviced',exp)
    this.vOS('location',exp)
    this.vOS('quantity',exp)
    this.vOS('unitPrice',exp)
    this.vOS('factor',exp)
    this.vOS('net',exp)
    this.vOA('udi',exp)
    this.vOS('bodySite',exp)
    this.vOA('subSite',exp)
    this.vOA('encounter',exp)
    this.vOA('detail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Claim type.
 */
export interface ClaimArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Claim"|undefined;
  /**
   * The business identifier for the instance: claim number, pre-determination or pre-authorization number.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains the code entered-in-error that marks the claim as not currently valid.
   */
  status?: fhir.FhirCode<FmStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Claim.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * Affects which fields and value sets are used.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  subType?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Complete (Bill or Claim), Proposed (Pre-Authorization), Exploratory (Pre-determination).
   */
  use?: fhir.FhirCode<ClaimUseCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Claim.use
   */
  _use?:fhir.FhirElementArgs;
  /**
   * Patient Resource.
   */
  patient?: fhir.ReferenceArgs|undefined;
  /**
   * The billable period for which charges are being submitted.
   */
  billablePeriod?: fhir.PeriodArgs|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  created?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Claim.created
   */
  _created?:fhir.FhirElementArgs;
  /**
   * Person who created the invoice/claim/pre-determination or pre-authorization.
   */
  enterer?: fhir.ReferenceArgs|undefined;
  /**
   * The Insurer who is target of the request.
   */
  insurer?: fhir.ReferenceArgs|undefined;
  /**
   * The provider which is responsible for the bill, claim pre-determination, pre-authorization.
   */
  provider?: fhir.ReferenceArgs|undefined;
  /**
   * The organization which is responsible for the bill, claim pre-determination, pre-authorization.
   */
  organization?: fhir.ReferenceArgs|undefined;
  /**
   * Immediate (STAT), best effort (NORMAL), deferred (DEFER).
   */
  priority?: fhir.CodeableConceptArgs|undefined;
  /**
   * In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested.
   */
  fundsReserve?: fhir.CodeableConceptArgs|undefined;
  /**
   * Other claims which are related to this claim such as prior claim versions or for related services.
   */
  related?: fhir.ClaimRelatedArgs[]|undefined;
  /**
   * Should we create a group to hold multiple prescriptions and add a sequence number and on the line items a link to the sequence.
   */
  prescription?: fhir.ReferenceArgs|undefined;
  /**
   * as above.
   */
  originalPrescription?: fhir.ReferenceArgs|undefined;
  /**
   * The party to be reimbursed for the services.
   */
  payee?: fhir.ClaimPayeeArgs|undefined;
  /**
   * The referral resource which lists the date, practitioner, reason and other supporting information.
   */
  referral?: fhir.ReferenceArgs|undefined;
  /**
   * Facility where the services were provided.
   */
  facility?: fhir.ReferenceArgs|undefined;
  /**
   * The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
   */
  careTeam?: fhir.ClaimCareTeamArgs[]|undefined;
  /**
   * Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
   */
  information?: fhir.ClaimInformationArgs[]|undefined;
  /**
   * List of patient diagnosis for which care is sought.
   */
  diagnosis?: fhir.ClaimDiagnosisArgs[]|undefined;
  /**
   * Ordered list of patient procedures performed to support the adjudication.
   */
  procedure?: fhir.ClaimProcedureArgs[]|undefined;
  /**
   * Financial instrument by which payment information for health care.
   */
  insurance?: fhir.ClaimInsuranceArgs[]|undefined;
  /**
   * An accident which resulted in the need for healthcare services.
   */
  accident?: fhir.ClaimAccidentArgs|undefined;
  /**
   * The start and optional end dates of when the patient was precluded from working due to the treatable condition(s).
   */
  employmentImpacted?: fhir.PeriodArgs|undefined;
  /**
   * The start and optional end dates of when the patient was confined to a treatment center.
   */
  hospitalization?: fhir.PeriodArgs|undefined;
  /**
   * First tier of goods and services.
   */
  item?: fhir.ClaimItemArgs[]|undefined;
  /**
   * The total value of the claim.
   */
  total?: fhir.MoneyArgs|undefined;
}

/**
 * A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
 */
export class Claim extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Claim';
  /**
   * Resource Type Name
   */
  public override resourceType: "Claim";
  /**
   * The business identifier for the instance: claim number, pre-determination or pre-authorization number.
   */
  public identifier: fhir.Identifier[];
  /**
   * This element is labeled as a modifier because the status contains the code entered-in-error that marks the claim as not currently valid.
   */
  public status?: fhir.FhirCode<FmStatusCodeType>|undefined;
  /**
   * Affects which fields and value sets are used.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * This may contain the local bill type codes such as the US UB-04 bill type code.
   */
  public subType: fhir.CodeableConcept[];
  /**
   * Complete (Bill or Claim), Proposed (Pre-Authorization), Exploratory (Pre-determination).
   */
  public use?: fhir.FhirCode<ClaimUseCodeType>|undefined;
  /**
   * Patient Resource.
   */
  public patient?: fhir.Reference|undefined;
  /**
   * The billable period for which charges are being submitted.
   */
  public billablePeriod?: fhir.Period|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  public created?: fhir.FhirDateTime|undefined;
  /**
   * Person who created the invoice/claim/pre-determination or pre-authorization.
   */
  public enterer?: fhir.Reference|undefined;
  /**
   * The Insurer who is target of the request.
   */
  public insurer?: fhir.Reference|undefined;
  /**
   * The provider which is responsible for the bill, claim pre-determination, pre-authorization.
   */
  public provider?: fhir.Reference|undefined;
  /**
   * The organization which is responsible for the bill, claim pre-determination, pre-authorization.
   */
  public organization?: fhir.Reference|undefined;
  /**
   * Immediate (STAT), best effort (NORMAL), deferred (DEFER).
   */
  public priority?: fhir.CodeableConcept|undefined;
  /**
   * In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested.
   */
  public fundsReserve?: fhir.CodeableConcept|undefined;
  /**
   * Other claims which are related to this claim such as prior claim versions or for related services.
   */
  public related: fhir.ClaimRelated[];
  /**
   * Should we create a group to hold multiple prescriptions and add a sequence number and on the line items a link to the sequence.
   */
  public prescription?: fhir.Reference|undefined;
  /**
   * as above.
   */
  public originalPrescription?: fhir.Reference|undefined;
  /**
   * The party to be reimbursed for the services.
   */
  public payee?: fhir.ClaimPayee|undefined;
  /**
   * The referral resource which lists the date, practitioner, reason and other supporting information.
   */
  public referral?: fhir.Reference|undefined;
  /**
   * Facility where the services were provided.
   */
  public facility?: fhir.Reference|undefined;
  /**
   * The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
   */
  public careTeam: fhir.ClaimCareTeam[];
  /**
   * Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
   */
  public information: fhir.ClaimInformation[];
  /**
   * List of patient diagnosis for which care is sought.
   */
  public diagnosis: fhir.ClaimDiagnosis[];
  /**
   * Ordered list of patient procedures performed to support the adjudication.
   */
  public procedure: fhir.ClaimProcedure[];
  /**
   * Financial instrument by which payment information for health care.
   */
  public insurance: fhir.ClaimInsurance[];
  /**
   * An accident which resulted in the need for healthcare services.
   */
  public accident?: fhir.ClaimAccident|undefined;
  /**
   * The start and optional end dates of when the patient was precluded from working due to the treatable condition(s).
   */
  public employmentImpacted?: fhir.Period|undefined;
  /**
   * The start and optional end dates of when the patient was confined to a treatment center.
   */
  public hospitalization?: fhir.Period|undefined;
  /**
   * First tier of goods and services.
   */
  public item: fhir.ClaimItem[];
  /**
   * The total value of the claim.
   */
  public total?: fhir.Money|undefined;
  /**
   * Default constructor for Claim - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Claim';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['status']) { this.status = new fhir.FhirCode<FmStatusCodeType>({value: source.status}); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<FmStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['subType']) { this.subType = source.subType.map((x) => new fhir.CodeableConcept(x)); }
    else { this.subType = []; }
    if (source['use']) { this.use = new fhir.FhirCode<ClaimUseCodeType>({value: source.use}); }
    if (source['_use']) {
      if (this.use) { this.use.addExtendedProperties(source._use!); }
      else { this.use = new fhir.FhirCode<ClaimUseCodeType>(source._use as Partial<fhir.FhirCode>); }
    }
    if (source['patient']) { this.patient = new fhir.Reference(source.patient); }
    if (source['billablePeriod']) { this.billablePeriod = new fhir.Period(source.billablePeriod); }
    if (source['created']) { this.created = new fhir.FhirDateTime({value: source.created}); }
    if (source['_created']) {
      if (this.created) { this.created.addExtendedProperties(source._created!); }
      else { this.created = new fhir.FhirDateTime(source._created as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['enterer']) { this.enterer = new fhir.Reference(source.enterer); }
    if (source['insurer']) { this.insurer = new fhir.Reference(source.insurer); }
    if (source['provider']) { this.provider = new fhir.Reference(source.provider); }
    if (source['organization']) { this.organization = new fhir.Reference(source.organization); }
    if (source['priority']) { this.priority = new fhir.CodeableConcept(source.priority); }
    if (source['fundsReserve']) { this.fundsReserve = new fhir.CodeableConcept(source.fundsReserve); }
    if (source['related']) { this.related = source.related.map((x) => new fhir.ClaimRelated(x)); }
    else { this.related = []; }
    if (source['prescription']) { this.prescription = new fhir.Reference(source.prescription); }
    if (source['originalPrescription']) { this.originalPrescription = new fhir.Reference(source.originalPrescription); }
    if (source['payee']) { this.payee = new fhir.ClaimPayee(source.payee); }
    if (source['referral']) { this.referral = new fhir.Reference(source.referral); }
    if (source['facility']) { this.facility = new fhir.Reference(source.facility); }
    if (source['careTeam']) { this.careTeam = source.careTeam.map((x) => new fhir.ClaimCareTeam(x)); }
    else { this.careTeam = []; }
    if (source['information']) { this.information = source.information.map((x) => new fhir.ClaimInformation(x)); }
    else { this.information = []; }
    if (source['diagnosis']) { this.diagnosis = source.diagnosis.map((x) => new fhir.ClaimDiagnosis(x)); }
    else { this.diagnosis = []; }
    if (source['procedure']) { this.procedure = source.procedure.map((x) => new fhir.ClaimProcedure(x)); }
    else { this.procedure = []; }
    if (source['insurance']) { this.insurance = source.insurance.map((x) => new fhir.ClaimInsurance(x)); }
    else { this.insurance = []; }
    if (source['accident']) { this.accident = new fhir.ClaimAccident(source.accident); }
    if (source['employmentImpacted']) { this.employmentImpacted = new fhir.Period(source.employmentImpacted); }
    if (source['hospitalization']) { this.hospitalization = new fhir.Period(source.hospitalization); }
    if (source['item']) { this.item = source.item.map((x) => new fhir.ClaimItem(x)); }
    else { this.item = []; }
    if (source['total']) { this.total = new fhir.Money(source.total); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Claim' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOSV('status',exp,'FmStatus',FmStatusVsValidation,'r')
    this.vOSV('type',exp,'ClaimType',ClaimTypeVsValidation,'r')
    this.vOA('subType',exp)
    this.vOSV('use',exp,'ClaimUse',ClaimUseVsValidation,'r')
    this.vOS('patient',exp)
    this.vOS('billablePeriod',exp)
    this.vOS('created',exp)
    this.vOS('enterer',exp)
    this.vOS('insurer',exp)
    this.vOS('provider',exp)
    this.vOS('organization',exp)
    this.vOS('priority',exp)
    this.vOS('fundsReserve',exp)
    this.vOA('related',exp)
    this.vOS('prescription',exp)
    this.vOS('originalPrescription',exp)
    this.vOS('payee',exp)
    this.vOS('referral',exp)
    this.vOS('facility',exp)
    this.vOA('careTeam',exp)
    this.vOA('information',exp)
    this.vOA('diagnosis',exp)
    this.vOA('procedure',exp)
    this.vOA('insurance',exp)
    this.vOS('accident',exp)
    this.vOS('employmentImpacted',exp)
    this.vOS('hospitalization',exp)
    this.vOA('item',exp)
    this.vOS('total',exp)
    return issues;
  }
}
