// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: EligibilityResponse

import * as fhir from '../fhir.js';

// @ts-ignore
import { BenefitTypeCodes,  BenefitTypeCodeType } from '../fhirValueSets/BenefitTypeCodes.js';
// @ts-ignore
import { BenefitTypeVsValidation } from '../fhirValueSets/BenefitTypeVsValidation.js';
// @ts-ignore
import { BenefitCategoryCodes,  BenefitCategoryCodeType } from '../fhirValueSets/BenefitCategoryCodes.js';
// @ts-ignore
import { BenefitCategoryVsValidation } from '../fhirValueSets/BenefitCategoryVsValidation.js';
// @ts-ignore
import { BenefitSubcategoryCodes,  BenefitSubcategoryCodeType } from '../fhirValueSets/BenefitSubcategoryCodes.js';
// @ts-ignore
import { BenefitSubcategoryVsValidation } from '../fhirValueSets/BenefitSubcategoryVsValidation.js';
// @ts-ignore
import { BenefitNetworkCodes,  BenefitNetworkCodeType } from '../fhirValueSets/BenefitNetworkCodes.js';
// @ts-ignore
import { BenefitNetworkVsValidation } from '../fhirValueSets/BenefitNetworkVsValidation.js';
// @ts-ignore
import { BenefitUnitCodes,  BenefitUnitCodeType } from '../fhirValueSets/BenefitUnitCodes.js';
// @ts-ignore
import { BenefitUnitVsValidation } from '../fhirValueSets/BenefitUnitVsValidation.js';
// @ts-ignore
import { BenefitTermCodes,  BenefitTermCodeType } from '../fhirValueSets/BenefitTermCodes.js';
// @ts-ignore
import { BenefitTermVsValidation } from '../fhirValueSets/BenefitTermVsValidation.js';
// @ts-ignore
import { AdjudicationErrorCodes,  AdjudicationErrorCodeType } from '../fhirValueSets/AdjudicationErrorCodes.js';
// @ts-ignore
import { AdjudicationErrorVsValidation } from '../fhirValueSets/AdjudicationErrorVsValidation.js';
// @ts-ignore
import { FmStatusCodes,  FmStatusCodeType } from '../fhirValueSets/FmStatusCodes.js';
// @ts-ignore
import { FmStatusVsValidation } from '../fhirValueSets/FmStatusVsValidation.js';
// @ts-ignore
import { RemittanceOutcomeCodes,  RemittanceOutcomeCodeType } from '../fhirValueSets/RemittanceOutcomeCodes.js';
// @ts-ignore
import { RemittanceOutcomeVsValidation } from '../fhirValueSets/RemittanceOutcomeVsValidation.js';
// @ts-ignore
import { FormsCodes,  FormsCodeType } from '../fhirValueSets/FormsCodes.js';
// @ts-ignore
import { FormsVsValidation } from '../fhirValueSets/FormsVsValidation.js';
/**
 * Valid arguments for the EligibilityResponseInsuranceBenefitBalanceFinancial type.
 */
export interface EligibilityResponseInsuranceBenefitBalanceFinancialArgs extends fhir.BackboneElementArgs {
  /**
   * Deductable, visits, benefit amount.
   */
  type: fhir.CodeableConceptArgs|null;
  /**
   * Benefits allowed.
   */
  allowed?: fhir.FhirUnsignedInt|fhir.FhirString|fhir.Money|undefined;
  /**
   * Benefits allowed.
   */
  allowedUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * Benefits allowed.
   */
  allowedString?: fhir.FhirString|string|undefined;
  /**
   * Benefits allowed.
   */
  allowedMoney?: fhir.MoneyArgs|undefined;
  /**
   * Benefits used.
   */
  used?: fhir.FhirUnsignedInt|fhir.Money|undefined;
  /**
   * Benefits used.
   */
  usedUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * Benefits used.
   */
  usedMoney?: fhir.MoneyArgs|undefined;
}

/**
 * Benefits Used to date.
 */
export class EligibilityResponseInsuranceBenefitBalanceFinancial extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EligibilityResponseInsuranceBenefitBalanceFinancial';
  /**
   * Deductable, visits, benefit amount.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * Benefits allowed.
   */
  public allowed?: (fhir.FhirUnsignedInt|fhir.FhirString|fhir.Money)|undefined;
  /**
   * Internal flag to properly serialize choice-type element EligibilityResponse.insurance.benefitBalance.financial.allowed[x]
   */
  protected static readonly _fts_allowedIsChoice:true = true;
  /**
   * Benefits used.
   */
  public used?: (fhir.FhirUnsignedInt|fhir.Money)|undefined;
  /**
   * Internal flag to properly serialize choice-type element EligibilityResponse.insurance.benefitBalance.financial.used[x]
   */
  protected static readonly _fts_usedIsChoice:true = true;
  /**
   * Default constructor for EligibilityResponseInsuranceBenefitBalanceFinancial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EligibilityResponseInsuranceBenefitBalanceFinancialArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    else { this.type = null; }
    if (source['allowed']) { this.allowed = source.allowed; }
    else if (source['allowedUnsignedInt']) { this.allowed = new fhir.FhirUnsignedInt({value: source.allowedUnsignedInt}); }
    else if (source['allowedString']) { this.allowed = new fhir.FhirString({value: source.allowedString}); }
    else if (source['allowedMoney']) { this.allowed = new fhir.Money(source.allowedMoney); }
    if (source['used']) { this.used = source.used; }
    else if (source['usedUnsignedInt']) { this.used = new fhir.FhirUnsignedInt({value: source.usedUnsignedInt}); }
    else if (source['usedMoney']) { this.used = new fhir.Money(source.usedMoney); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EligibilityResponse.insurance.benefitBalance.financial' }
    this.vRS('type',exp)
    this.vOS('allowed',exp)
    this.vOS('used',exp)
    return issues;
  }
}
/**
 * Valid arguments for the EligibilityResponseInsuranceBenefitBalance type.
 */
export interface EligibilityResponseInsuranceBenefitBalanceArgs extends fhir.BackboneElementArgs {
  /**
   * Dental, Vision, Medical, Pharmacy, Rehab etc.
   */
  category: fhir.CodeableConceptArgs|null;
  /**
   * Dental: basic, major, ortho; Vision exam, glasses, contacts; etc.
   */
  subCategory?: fhir.CodeableConceptArgs|undefined;
  /**
   * True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
   */
  excluded?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.insurance.benefitBalance.excluded
   */
  _excluded?:fhir.FhirElementArgs;
  /**
   * A short name or tag for the benefit, for example MED01, or DENT2.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.insurance.benefitBalance.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.insurance.benefitBalance.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Network designation.
   */
  network?: fhir.CodeableConceptArgs|undefined;
  /**
   * Unit designation: individual or family.
   */
  unit?: fhir.CodeableConceptArgs|undefined;
  /**
   * The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'.
   */
  term?: fhir.CodeableConceptArgs|undefined;
  /**
   * Benefits Used to date.
   */
  financial?: fhir.EligibilityResponseInsuranceBenefitBalanceFinancialArgs[]|undefined;
}

/**
 * Benefits and optionally current balances by Category.
 */
export class EligibilityResponseInsuranceBenefitBalance extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EligibilityResponseInsuranceBenefitBalance';
  /**
   * Dental, Vision, Medical, Pharmacy, Rehab etc.
   */
  public category: fhir.CodeableConcept|null;
  /**
   * Dental: basic, major, ortho; Vision exam, glasses, contacts; etc.
   */
  public subCategory?: fhir.CodeableConcept|undefined;
  /**
   * True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
   */
  public excluded?: fhir.FhirBoolean|undefined;
  /**
   * A short name or tag for the benefit, for example MED01, or DENT2.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Network designation.
   */
  public network?: fhir.CodeableConcept|undefined;
  /**
   * Unit designation: individual or family.
   */
  public unit?: fhir.CodeableConcept|undefined;
  /**
   * The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'.
   */
  public term?: fhir.CodeableConcept|undefined;
  /**
   * Benefits Used to date.
   */
  public financial: fhir.EligibilityResponseInsuranceBenefitBalanceFinancial[];
  /**
   * Default constructor for EligibilityResponseInsuranceBenefitBalance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EligibilityResponseInsuranceBenefitBalanceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    else { this.category = null; }
    if (source['subCategory']) { this.subCategory = new fhir.CodeableConcept(source.subCategory); }
    if (source['excluded']) { this.excluded = new fhir.FhirBoolean({value: source.excluded}); }
    if (source['_excluded']) {
      if (this.excluded) { this.excluded.addExtendedProperties(source._excluded!); }
      else { this.excluded = new fhir.FhirBoolean(source._excluded as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['network']) { this.network = new fhir.CodeableConcept(source.network); }
    if (source['unit']) { this.unit = new fhir.CodeableConcept(source.unit); }
    if (source['term']) { this.term = new fhir.CodeableConcept(source.term); }
    if (source['financial']) { this.financial = source.financial.map((x) => new fhir.EligibilityResponseInsuranceBenefitBalanceFinancial(x)); }
    else { this.financial = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EligibilityResponse.insurance.benefitBalance' }
    this.vRS('category',exp)
    this.vOS('subCategory',exp)
    this.vOS('excluded',exp)
    this.vOS('name',exp)
    this.vOS('description',exp)
    this.vOS('network',exp)
    this.vOS('unit',exp)
    this.vOS('term',exp)
    this.vOA('financial',exp)
    return issues;
  }
}
/**
 * Valid arguments for the EligibilityResponseInsurance type.
 */
export interface EligibilityResponseInsuranceArgs extends fhir.BackboneElementArgs {
  /**
   * A suite of updated or additional Coverages from the Insurer.
   */
  coverage?: fhir.ReferenceArgs|undefined;
  /**
   * The contract resource which may provide more detailed information.
   */
  contract?: fhir.ReferenceArgs|undefined;
  /**
   * Benefits and optionally current balances by Category.
   */
  benefitBalance?: fhir.EligibilityResponseInsuranceBenefitBalanceArgs[]|undefined;
}

/**
 * The insurer may provide both the details for the requested coverage as well as details for additional coverages known to the insurer.
 */
export class EligibilityResponseInsurance extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EligibilityResponseInsurance';
  /**
   * A suite of updated or additional Coverages from the Insurer.
   */
  public coverage?: fhir.Reference|undefined;
  /**
   * The contract resource which may provide more detailed information.
   */
  public contract?: fhir.Reference|undefined;
  /**
   * Benefits and optionally current balances by Category.
   */
  public benefitBalance: fhir.EligibilityResponseInsuranceBenefitBalance[];
  /**
   * Default constructor for EligibilityResponseInsurance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EligibilityResponseInsuranceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['coverage']) { this.coverage = new fhir.Reference(source.coverage); }
    if (source['contract']) { this.contract = new fhir.Reference(source.contract); }
    if (source['benefitBalance']) { this.benefitBalance = source.benefitBalance.map((x) => new fhir.EligibilityResponseInsuranceBenefitBalance(x)); }
    else { this.benefitBalance = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EligibilityResponse.insurance' }
    this.vOS('coverage',exp)
    this.vOS('contract',exp)
    this.vOA('benefitBalance',exp)
    return issues;
  }
}
/**
 * Valid arguments for the EligibilityResponseError type.
 */
export interface EligibilityResponseErrorArgs extends fhir.BackboneElementArgs {
  /**
   * An error code,from a specified code system, which details why the eligibility check could not be performed.
   */
  code: fhir.CodeableConceptArgs|null;
}

/**
 * Mutually exclusive with Services Provided (Item).
 */
export class EligibilityResponseError extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EligibilityResponseError';
  /**
   * An error code,from a specified code system, which details why the eligibility check could not be performed.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * Default constructor for EligibilityResponseError - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EligibilityResponseErrorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EligibilityResponse.error' }
    this.vRS('code',exp)
    return issues;
  }
}
/**
 * Valid arguments for the EligibilityResponse type.
 */
export interface EligibilityResponseArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "EligibilityResponse"|undefined;
  /**
   * The Response business identifier.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the response as not currently valid.
   */
  status?: fhir.FhirCode<FmStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  created?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.created
   */
  _created?:fhir.FhirElementArgs;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  requestProvider?: fhir.ReferenceArgs|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  requestOrganization?: fhir.ReferenceArgs|undefined;
  /**
   * Original request resource reference.
   */
  request?: fhir.ReferenceArgs|undefined;
  /**
   * Transaction status: error, complete.
   */
  outcome?: fhir.CodeableConceptArgs|undefined;
  /**
   * A description of the status of the adjudication.
   */
  disposition?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.disposition
   */
  _disposition?:fhir.FhirElementArgs;
  /**
   * The Insurer who produced this adjudicated response.
   */
  insurer?: fhir.ReferenceArgs|undefined;
  /**
   * Flag indicating if the coverage provided is inforce currently  if no service date(s) specified or for the whole duration of the service dates.
   */
  inforce?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: EligibilityResponse.inforce
   */
  _inforce?:fhir.FhirElementArgs;
  /**
   * The insurer may provide both the details for the requested coverage as well as details for additional coverages known to the insurer.
   */
  insurance?: fhir.EligibilityResponseInsuranceArgs[]|undefined;
  /**
   * The form to be used for printing the content.
   */
  form?: fhir.CodeableConceptArgs|undefined;
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  error?: fhir.EligibilityResponseErrorArgs[]|undefined;
}

/**
 * This resource provides eligibility and plan details from the processing of an Eligibility resource.
 */
export class EligibilityResponse extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EligibilityResponse';
  /**
   * Resource Type Name
   */
  public override resourceType: "EligibilityResponse";
  /**
   * The Response business identifier.
   */
  public identifier: fhir.Identifier[];
  /**
   * This element is labeled as a modifier because the status contains codes that mark the response as not currently valid.
   */
  public status?: fhir.FhirCode<FmStatusCodeType>|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  public created?: fhir.FhirDateTime|undefined;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  public requestProvider?: fhir.Reference|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  public requestOrganization?: fhir.Reference|undefined;
  /**
   * Original request resource reference.
   */
  public request?: fhir.Reference|undefined;
  /**
   * Transaction status: error, complete.
   */
  public outcome?: fhir.CodeableConcept|undefined;
  /**
   * A description of the status of the adjudication.
   */
  public disposition?: fhir.FhirString|undefined;
  /**
   * The Insurer who produced this adjudicated response.
   */
  public insurer?: fhir.Reference|undefined;
  /**
   * Flag indicating if the coverage provided is inforce currently  if no service date(s) specified or for the whole duration of the service dates.
   */
  public inforce?: fhir.FhirBoolean|undefined;
  /**
   * The insurer may provide both the details for the requested coverage as well as details for additional coverages known to the insurer.
   */
  public insurance: fhir.EligibilityResponseInsurance[];
  /**
   * The form to be used for printing the content.
   */
  public form?: fhir.CodeableConcept|undefined;
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  public error: fhir.EligibilityResponseError[];
  /**
   * Default constructor for EligibilityResponse - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EligibilityResponseArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'EligibilityResponse';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['status']) { this.status = new fhir.FhirCode<FmStatusCodeType>({value: source.status}); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<FmStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['created']) { this.created = new fhir.FhirDateTime({value: source.created}); }
    if (source['_created']) {
      if (this.created) { this.created.addExtendedProperties(source._created!); }
      else { this.created = new fhir.FhirDateTime(source._created as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['requestProvider']) { this.requestProvider = new fhir.Reference(source.requestProvider); }
    if (source['requestOrganization']) { this.requestOrganization = new fhir.Reference(source.requestOrganization); }
    if (source['request']) { this.request = new fhir.Reference(source.request); }
    if (source['outcome']) { this.outcome = new fhir.CodeableConcept(source.outcome); }
    if (source['disposition']) { this.disposition = new fhir.FhirString({value: source.disposition}); }
    if (source['_disposition']) {
      if (this.disposition) { this.disposition.addExtendedProperties(source._disposition!); }
      else { this.disposition = new fhir.FhirString(source._disposition as Partial<fhir.FhirStringArgs>); }
    }
    if (source['insurer']) { this.insurer = new fhir.Reference(source.insurer); }
    if (source['inforce']) { this.inforce = new fhir.FhirBoolean({value: source.inforce}); }
    if (source['_inforce']) {
      if (this.inforce) { this.inforce.addExtendedProperties(source._inforce!); }
      else { this.inforce = new fhir.FhirBoolean(source._inforce as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['insurance']) { this.insurance = source.insurance.map((x) => new fhir.EligibilityResponseInsurance(x)); }
    else { this.insurance = []; }
    if (source['form']) { this.form = new fhir.CodeableConcept(source.form); }
    if (source['error']) { this.error = source.error.map((x) => new fhir.EligibilityResponseError(x)); }
    else { this.error = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EligibilityResponse' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOSV('status',exp,'FmStatus',FmStatusVsValidation,'r')
    this.vOS('created',exp)
    this.vOS('requestProvider',exp)
    this.vOS('requestOrganization',exp)
    this.vOS('request',exp)
    this.vOSV('outcome',exp,'RemittanceOutcome',RemittanceOutcomeVsValidation,'r')
    this.vOS('disposition',exp)
    this.vOS('insurer',exp)
    this.vOS('inforce',exp)
    this.vOA('insurance',exp)
    this.vOS('form',exp)
    this.vOA('error',exp)
    return issues;
  }
}
