// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Signature

import * as fhir from '../fhir.js';

// @ts-ignore
import { SignatureTypeCodes,  SignatureTypeCodeType } from '../fhirValueSets/SignatureTypeCodes.js';
// @ts-ignore
import { SignatureTypeVsValidation } from '../fhirValueSets/SignatureTypeVsValidation.js';
/**
 * Valid arguments for the Signature type.
 */
export interface SignatureArgs extends fhir.FhirElementArgs {
  /**
   * Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &amp;quot;Commitment Type Indication&amp;quot;.
   */
  type: fhir.CodingArgs[]|null;
  /**
   * This should agree with the information in the signature.
   */
  when: fhir.FhirInstant|string|undefined;
  /**
   * Extended properties for primitive element: Signature.when
   */
  _when?:fhir.FhirElementArgs;
  /**
   * This should agree with the information in the signature.
   */
  who?: fhir.FhirUri|fhir.Reference|undefined;
  /**
   * This should agree with the information in the signature.
   */
  whoUri?: fhir.FhirUri|string|undefined;
  /**
   * This should agree with the information in the signature.
   */
  whoReference?: fhir.ReferenceArgs|undefined;
  /**
   * The party that can't sign. For example a child.
   */
  onBehalfOf?: fhir.FhirUri|fhir.Reference|undefined;
  /**
   * The party that can't sign. For example a child.
   */
  onBehalfOfUri?: fhir.FhirUri|string|undefined;
  /**
   * The party that can't sign. For example a child.
   */
  onBehalfOfReference?: fhir.ReferenceArgs|undefined;
  /**
   * A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jwt for JWT, and image/* for a graphical image of a signature, etc.
   */
  contentType?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: Signature.contentType
   */
  _contentType?:fhir.FhirElementArgs;
  /**
   * Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   */
  blob?: fhir.FhirBase64Binary|string|undefined;
  /**
   * Extended properties for primitive element: Signature.blob
   */
  _blob?:fhir.FhirElementArgs;
}

/**
 * A digital signature along with supporting context. The signature may be electronic/cryptographic in nature, or a graphical image representing a hand-written signature, or a signature process. Different signature approaches have different utilities.
 */
export class Signature extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Signature';
  /**
   * Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &amp;quot;Commitment Type Indication&amp;quot;.
   */
  public type: fhir.Coding[];
  /**
   * This should agree with the information in the signature.
   */
  public when: fhir.FhirInstant|null;
  /**
   * This should agree with the information in the signature.
   */
  public who: (fhir.FhirUri|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element Signature.who[x]
   */
  protected static readonly _fts_whoIsChoice:true = true;
  /**
   * The party that can't sign. For example a child.
   */
  public onBehalfOf?: (fhir.FhirUri|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Signature.onBehalfOf[x]
   */
  protected static readonly _fts_onBehalfOfIsChoice:true = true;
  /**
   * A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jwt for JWT, and image/* for a graphical image of a signature, etc.
   */
  public contentType?: fhir.FhirCode|undefined;
  /**
   * Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   */
  public blob?: fhir.FhirBase64Binary|undefined;
  /**
   * Default constructor for Signature - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SignatureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = source.type.map((x) => new fhir.Coding(x, options)); }
    else { this.type = []; }
    if (source['when'] !== undefined) { this.when = new fhir.FhirInstant({value: source.when}, options); }
    else { this.when = null; }
    if (source['_when']) {
      if (this.when) { this.when.addExtendedProperties(source._when!); }
      else { this.when = new fhir.FhirInstant(source._when as Partial<fhir.FhirInstantArgs>, options); }
    }
    if (source['who']) { this.who = source.who; }
    else if (source['whoUri'] !== undefined) { this.who = new fhir.FhirUri({value: source.whoUri}, options); }
    else if (source['whoReference']) { this.who = new fhir.Reference(source.whoReference, options); }
    else { this.who = null; }
    if (source['onBehalfOf']) { this.onBehalfOf = source.onBehalfOf; }
    else if (source['onBehalfOfUri'] !== undefined) { this.onBehalfOf = new fhir.FhirUri({value: source.onBehalfOfUri}, options); }
    else if (source['onBehalfOfReference']) { this.onBehalfOf = new fhir.Reference(source.onBehalfOfReference, options); }
    if (source['contentType'] !== undefined) { this.contentType = new fhir.FhirCode({value: source.contentType}, options); }
    if (source['_contentType']) {
      if (this.contentType) { this.contentType.addExtendedProperties(source._contentType!); }
      else { this.contentType = new fhir.FhirCode(source._contentType as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['blob'] !== undefined) { this.blob = new fhir.FhirBase64Binary({value: source.blob}, options); }
    if (source['_blob']) {
      if (this.blob) { this.blob.addExtendedProperties(source._blob!); }
      else { this.blob = new fhir.FhirBase64Binary(source._blob as Partial<fhir.FhirBase64BinaryArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Signature' }
    iss.push(...this.vRA('type',exp));
    iss.push(...this.vRS('when',exp));
    iss.push(...this.vRS('who',exp));
    iss.push(...this.vOS('onBehalfOf',exp));
    iss.push(...this.vOS('contentType',exp));
    iss.push(...this.vOS('blob',exp));
    return iss;
  }
}
