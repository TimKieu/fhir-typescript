// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Consent

import * as fhir from '../fhir.js';

// @ts-ignore
import { ConsentDataMeaningCodes,  ConsentDataMeaningCodeType } from '../fhirValueSets/ConsentDataMeaningCodes.js';
// @ts-ignore
import { ConsentDataMeaningVsValidation } from '../fhirValueSets/ConsentDataMeaningVsValidation.js';
// @ts-ignore
import { ConsentExceptTypeCodes,  ConsentExceptTypeCodeType } from '../fhirValueSets/ConsentExceptTypeCodes.js';
// @ts-ignore
import { ConsentExceptTypeVsValidation } from '../fhirValueSets/ConsentExceptTypeVsValidation.js';
// @ts-ignore
import { ConsentActionCodes,  ConsentActionCodeType } from '../fhirValueSets/ConsentActionCodes.js';
// @ts-ignore
import { ConsentActionVsValidation } from '../fhirValueSets/ConsentActionVsValidation.js';
// @ts-ignore
import { SecurityLabelsCodes,  SecurityLabelsCodeType } from '../fhirValueSets/SecurityLabelsCodes.js';
// @ts-ignore
import { SecurityLabelsVsValidation } from '../fhirValueSets/SecurityLabelsVsValidation.js';
// @ts-ignore
import { V3PurposeOfUseCodes,  V3PurposeOfUseCodeType } from '../fhirValueSets/V3PurposeOfUseCodes.js';
// @ts-ignore
import { V3PurposeOfUseVsValidation } from '../fhirValueSets/V3PurposeOfUseVsValidation.js';
// @ts-ignore
import { ConsentContentCodes,  ConsentContentCodeType } from '../fhirValueSets/ConsentContentCodes.js';
// @ts-ignore
import { ConsentContentVsValidation } from '../fhirValueSets/ConsentContentVsValidation.js';
// @ts-ignore
import { ConsentStateCodes,  ConsentStateCodeType } from '../fhirValueSets/ConsentStateCodes.js';
// @ts-ignore
import { ConsentStateVsValidation } from '../fhirValueSets/ConsentStateVsValidation.js';
// @ts-ignore
import { ConsentCategoryCodes,  ConsentCategoryCodeType } from '../fhirValueSets/ConsentCategoryCodes.js';
// @ts-ignore
import { ConsentCategoryVsValidation } from '../fhirValueSets/ConsentCategoryVsValidation.js';
/**
 * Valid arguments for the ConsentActor type.
 */
export interface ConsentActorArgs extends fhir.BackboneElementArgs {
  /**
   * How the individual is involved in the resources content that is described in the consent.
   */
  role: fhir.CodeableConceptArgs|null;
  /**
   * The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * Who or what is controlled by this consent. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
export class ConsentActor extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentActor';
  /**
   * How the individual is involved in the resources content that is described in the consent.
   */
  public role: fhir.CodeableConcept|null;
  /**
   * The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentActor - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentActorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    else { this.role = null; }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.actor' }
    this.vRS('role',exp)
    this.vRS('reference',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ConsentPolicy type.
 */
export interface ConsentPolicyArgs extends fhir.BackboneElementArgs {
  /**
   * Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
   */
  authority?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: Consent.policy.authority
   */
  _authority?:fhir.FhirElementArgs;
  /**
   * This element is for discoverability / documentation, and does not modify or qualify the policy rules.
   */
  uri?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: Consent.policy.uri
   */
  _uri?:fhir.FhirElementArgs;
}

/**
 * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
export class ConsentPolicy extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentPolicy';
  /**
   * Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
   */
  public authority?: fhir.FhirUri|undefined;
  /**
   * This element is for discoverability / documentation, and does not modify or qualify the policy rules.
   */
  public uri?: fhir.FhirUri|undefined;
  /**
   * Default constructor for ConsentPolicy - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentPolicyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['authority']) { this.authority = new fhir.FhirUri({value: source.authority}); }
    if (source['_authority']) {
      if (this.authority) { this.authority.addExtendedProperties(source._authority!); }
      else { this.authority = new fhir.FhirUri(source._authority as Partial<fhir.FhirUriArgs>); }
    }
    if (source['uri']) { this.uri = new fhir.FhirUri({value: source.uri}); }
    if (source['_uri']) {
      if (this.uri) { this.uri.addExtendedProperties(source._uri!); }
      else { this.uri = new fhir.FhirUri(source._uri as Partial<fhir.FhirUriArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.policy' }
    this.vOS('authority',exp)
    this.vOS('uri',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ConsentData type.
 */
export interface ConsentDataArgs extends fhir.BackboneElementArgs {
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  meaning: fhir.FhirCode<ConsentDataMeaningCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Consent.data.meaning
   */
  _meaning?:fhir.FhirElementArgs;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * The resources controlled by this consent, if specific resources are referenced.
 */
export class ConsentData extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentData';
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  public meaning: fhir.FhirCode<ConsentDataMeaningCodeType>|null;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentData - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentDataArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['meaning']) { this.meaning = new fhir.FhirCode<ConsentDataMeaningCodeType>({value: source.meaning}); }
    else { this.meaning = null; }
    if (source['_meaning']) {
      if (this.meaning) { this.meaning.addExtendedProperties(source._meaning!); }
      else { this.meaning = new fhir.FhirCode<ConsentDataMeaningCodeType>(source._meaning as Partial<fhir.FhirCode>); }
    }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.data' }
    this.vRSV('meaning',exp,'ConsentDataMeaning',ConsentDataMeaningVsValidation,'r')
    this.vRS('reference',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ConsentExceptActor type.
 */
export interface ConsentExceptActorArgs extends fhir.BackboneElementArgs {
  /**
   * How the individual is involved in the resources content that is described in the exception.
   */
  role: fhir.CodeableConceptArgs|null;
  /**
   * The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * Who or what is controlled by this Exception. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
export class ConsentExceptActor extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentExceptActor';
  /**
   * How the individual is involved in the resources content that is described in the exception.
   */
  public role: fhir.CodeableConcept|null;
  /**
   * The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentExceptActor - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentExceptActorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    else { this.role = null; }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.except.actor' }
    this.vRS('role',exp)
    this.vRS('reference',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ConsentExceptData type.
 */
export interface ConsentExceptDataArgs extends fhir.BackboneElementArgs {
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  meaning: fhir.FhirCode<ConsentDataMeaningCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Consent.except.data.meaning
   */
  _meaning?:fhir.FhirElementArgs;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * The resources controlled by this exception, if specific resources are referenced.
 */
export class ConsentExceptData extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentExceptData';
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  public meaning: fhir.FhirCode<ConsentDataMeaningCodeType>|null;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentExceptData - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentExceptDataArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['meaning']) { this.meaning = new fhir.FhirCode<ConsentDataMeaningCodeType>({value: source.meaning}); }
    else { this.meaning = null; }
    if (source['_meaning']) {
      if (this.meaning) { this.meaning.addExtendedProperties(source._meaning!); }
      else { this.meaning = new fhir.FhirCode<ConsentDataMeaningCodeType>(source._meaning as Partial<fhir.FhirCode>); }
    }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.except.data' }
    this.vRSV('meaning',exp,'ConsentDataMeaning',ConsentDataMeaningVsValidation,'r')
    this.vRS('reference',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ConsentExcept type.
 */
export interface ConsentExceptArgs extends fhir.BackboneElementArgs {
  /**
   * Action  to take - permit or deny - when the exception conditions are met.
   */
  type: fhir.FhirCode<ConsentExceptTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Consent.except.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * The timeframe in this exception is valid.
   */
  period?: fhir.PeriodArgs|undefined;
  /**
   * Who or what is controlled by this Exception. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  actor?: fhir.ConsentExceptActorArgs[]|undefined;
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  action?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  securityLabel?: fhir.CodingArgs[]|undefined;
  /**
   * E.g. if the purpose is 'research', then the operational context must be research, in order for the consent to apply. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  purpose?: fhir.CodingArgs[]|undefined;
  /**
   * Multiple types are or'ed together. The intention of the contentType element is that the codes refer to profiles or document types defined in a standard or an implementation guide somewhere.
   */
  class?: fhir.CodingArgs[]|undefined;
  /**
   * Typical use of this is a Document code with class = CDA.
   */
  code?: fhir.CodingArgs[]|undefined;
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  dataPeriod?: fhir.PeriodArgs|undefined;
  /**
   * The resources controlled by this exception, if specific resources are referenced.
   */
  data?: fhir.ConsentExceptDataArgs[]|undefined;
}

/**
 * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
 */
export class ConsentExcept extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConsentExcept';
  /**
   * Action  to take - permit or deny - when the exception conditions are met.
   */
  public type: fhir.FhirCode<ConsentExceptTypeCodeType>|null;
  /**
   * The timeframe in this exception is valid.
   */
  public period?: fhir.Period|undefined;
  /**
   * Who or what is controlled by this Exception. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public actor: fhir.ConsentExceptActor[];
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  public action: fhir.CodeableConcept[];
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  public securityLabel: fhir.Coding[];
  /**
   * E.g. if the purpose is 'research', then the operational context must be research, in order for the consent to apply. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  public purpose: fhir.Coding[];
  /**
   * Multiple types are or'ed together. The intention of the contentType element is that the codes refer to profiles or document types defined in a standard or an implementation guide somewhere.
   */
  public class: fhir.Coding[];
  /**
   * Typical use of this is a Document code with class = CDA.
   */
  public code: fhir.Coding[];
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  public dataPeriod?: fhir.Period|undefined;
  /**
   * The resources controlled by this exception, if specific resources are referenced.
   */
  public data: fhir.ConsentExceptData[];
  /**
   * Default constructor for ConsentExcept - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentExceptArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.FhirCode<ConsentExceptTypeCodeType>({value: source.type}); }
    else { this.type = null; }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<ConsentExceptTypeCodeType>(source._type as Partial<fhir.FhirCode>); }
    }
    if (source['period']) { this.period = new fhir.Period(source.period); }
    if (source['actor']) { this.actor = source.actor.map((x) => new fhir.ConsentExceptActor(x)); }
    else { this.actor = []; }
    if (source['action']) { this.action = source.action.map((x) => new fhir.CodeableConcept(x)); }
    else { this.action = []; }
    if (source['securityLabel']) { this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x)); }
    else { this.securityLabel = []; }
    if (source['purpose']) { this.purpose = source.purpose.map((x) => new fhir.Coding(x)); }
    else { this.purpose = []; }
    if (source['class']) { this.class = source.class.map((x) => new fhir.Coding(x)); }
    else { this.class = []; }
    if (source['code']) { this.code = source.code.map((x) => new fhir.Coding(x)); }
    else { this.code = []; }
    if (source['dataPeriod']) { this.dataPeriod = new fhir.Period(source.dataPeriod); }
    if (source['data']) { this.data = source.data.map((x) => new fhir.ConsentExceptData(x)); }
    else { this.data = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent.except' }
    this.vRSV('type',exp,'ConsentExceptType',ConsentExceptTypeVsValidation,'r')
    this.vOS('period',exp)
    this.vOA('actor',exp)
    this.vOA('action',exp)
    this.vOA('securityLabel',exp)
    this.vOA('purpose',exp)
    this.vOA('class',exp)
    this.vOA('code',exp)
    this.vOS('dataPeriod',exp)
    this.vOA('data',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Consent type.
 */
export interface ConsentArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Consent"|undefined;
  /**
   * This identifier is identifies this copy of the consent. Where this identifier is also used elsewhere as the identifier for a consent record (e.g. a CDA consent document) then the consent details are expected to be the same.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes rejected and entered-in-error that mark the Consent as not currently valid.
   */
  status: fhir.FhirCode<ConsentStateCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Consent.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
   */
  category?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Commonly, the patient the consent pertains to is the author, but for young and old people, it may be some other person.
   */
  patient: fhir.ReferenceArgs|null;
  /**
   * This can be a subset of the period of the original statement.
   */
  period?: fhir.PeriodArgs|undefined;
  /**
   * This is not the time of the original consent, but the time that this statement was made or derived.
   */
  dateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Consent.dateTime
   */
  _dateTime?:fhir.FhirElementArgs;
  /**
   * Commonly, the patient the consent pertains to is the consentor, but particularly for young and old people, it may be some other person - e.g. a legal guardian.
   */
  consentingParty?: fhir.ReferenceArgs[]|undefined;
  /**
   * Who or what is controlled by this consent. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  actor?: fhir.ConsentActorArgs[]|undefined;
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  action?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The organization that manages the consent, and the framework within which it is executed.
   */
  organization?: fhir.ReferenceArgs[]|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  source?: fhir.Attachment|fhir.Identifier|fhir.Reference|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  sourceAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  sourceIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  sourceReference?: fhir.ReferenceArgs|undefined;
  /**
   * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
   */
  policy?: fhir.ConsentPolicyArgs[]|undefined;
  /**
   * If the policy reference is not known, the resource cannot be processed. Where the reference is absent, there is no particular policy other than what is expressed directly in the consent resource.
   */
  policyRule?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: Consent.policyRule
   */
  _policyRule?:fhir.FhirElementArgs;
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  securityLabel?: fhir.CodingArgs[]|undefined;
  /**
   * This element is for discoverability / documentation, and does not modify or qualify the policy (e.g. the policy itself describes the purposes for which it applies).
   */
  purpose?: fhir.CodingArgs[]|undefined;
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  dataPeriod?: fhir.PeriodArgs|undefined;
  /**
   * The resources controlled by this consent, if specific resources are referenced.
   */
  data?: fhir.ConsentDataArgs[]|undefined;
  /**
   * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
   */
  except?: fhir.ConsentExceptArgs[]|undefined;
}

/**
 * A record of a healthcare consumer’s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
 */
export class Consent extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Consent';
  /**
   * Resource Type Name
   */
  public override resourceType: "Consent";
  /**
   * This identifier is identifies this copy of the consent. Where this identifier is also used elsewhere as the identifier for a consent record (e.g. a CDA consent document) then the consent details are expected to be the same.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes rejected and entered-in-error that mark the Consent as not currently valid.
   */
  public status: fhir.FhirCode<ConsentStateCodeType>|null;
  /**
   * A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
   */
  public category: fhir.CodeableConcept[];
  /**
   * Commonly, the patient the consent pertains to is the author, but for young and old people, it may be some other person.
   */
  public patient: fhir.Reference|null;
  /**
   * This can be a subset of the period of the original statement.
   */
  public period?: fhir.Period|undefined;
  /**
   * This is not the time of the original consent, but the time that this statement was made or derived.
   */
  public dateTime?: fhir.FhirDateTime|undefined;
  /**
   * Commonly, the patient the consent pertains to is the consentor, but particularly for young and old people, it may be some other person - e.g. a legal guardian.
   */
  public consentingParty: fhir.Reference[];
  /**
   * Who or what is controlled by this consent. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public actor: fhir.ConsentActor[];
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  public action: fhir.CodeableConcept[];
  /**
   * The organization that manages the consent, and the framework within which it is executed.
   */
  public organization: fhir.Reference[];
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  public source?: (fhir.Attachment|fhir.Identifier|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Consent.source[x]
   */
  protected static readonly _fts_sourceIsChoice:true = true;
  /**
   * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
   */
  public policy: fhir.ConsentPolicy[];
  /**
   * If the policy reference is not known, the resource cannot be processed. Where the reference is absent, there is no particular policy other than what is expressed directly in the consent resource.
   */
  public policyRule?: fhir.FhirUri|undefined;
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. Not all of the security labels make sense for use in this element (may define a narrower value set?).
   */
  public securityLabel: fhir.Coding[];
  /**
   * This element is for discoverability / documentation, and does not modify or qualify the policy (e.g. the policy itself describes the purposes for which it applies).
   */
  public purpose: fhir.Coding[];
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  public dataPeriod?: fhir.Period|undefined;
  /**
   * The resources controlled by this consent, if specific resources are referenced.
   */
  public data: fhir.ConsentData[];
  /**
   * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
   */
  public except: fhir.ConsentExcept[];
  /**
   * Default constructor for Consent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Consent';
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['status']) { this.status = new fhir.FhirCode<ConsentStateCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<ConsentStateCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['category']) { this.category = source.category.map((x) => new fhir.CodeableConcept(x)); }
    else { this.category = []; }
    if (source['patient']) { this.patient = new fhir.Reference(source.patient); }
    else { this.patient = null; }
    if (source['period']) { this.period = new fhir.Period(source.period); }
    if (source['dateTime']) { this.dateTime = new fhir.FhirDateTime({value: source.dateTime}); }
    if (source['_dateTime']) {
      if (this.dateTime) { this.dateTime.addExtendedProperties(source._dateTime!); }
      else { this.dateTime = new fhir.FhirDateTime(source._dateTime as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['consentingParty']) { this.consentingParty = source.consentingParty.map((x) => new fhir.Reference(x)); }
    else { this.consentingParty = []; }
    if (source['actor']) { this.actor = source.actor.map((x) => new fhir.ConsentActor(x)); }
    else { this.actor = []; }
    if (source['action']) { this.action = source.action.map((x) => new fhir.CodeableConcept(x)); }
    else { this.action = []; }
    if (source['organization']) { this.organization = source.organization.map((x) => new fhir.Reference(x)); }
    else { this.organization = []; }
    if (source['source']) { this.source = source.source; }
    else if (source['sourceAttachment']) { this.source = new fhir.Attachment(source.sourceAttachment); }
    else if (source['sourceIdentifier']) { this.source = new fhir.Identifier(source.sourceIdentifier); }
    else if (source['sourceReference']) { this.source = new fhir.Reference(source.sourceReference); }
    if (source['policy']) { this.policy = source.policy.map((x) => new fhir.ConsentPolicy(x)); }
    else { this.policy = []; }
    if (source['policyRule']) { this.policyRule = new fhir.FhirUri({value: source.policyRule}); }
    if (source['_policyRule']) {
      if (this.policyRule) { this.policyRule.addExtendedProperties(source._policyRule!); }
      else { this.policyRule = new fhir.FhirUri(source._policyRule as Partial<fhir.FhirUriArgs>); }
    }
    if (source['securityLabel']) { this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x)); }
    else { this.securityLabel = []; }
    if (source['purpose']) { this.purpose = source.purpose.map((x) => new fhir.Coding(x)); }
    else { this.purpose = []; }
    if (source['dataPeriod']) { this.dataPeriod = new fhir.Period(source.dataPeriod); }
    if (source['data']) { this.data = source.data.map((x) => new fhir.ConsentData(x)); }
    else { this.data = []; }
    if (source['except']) { this.except = source.except.map((x) => new fhir.ConsentExcept(x)); }
    else { this.except = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Consent' }
    this.vRS('resourceType',exp)
    this.vOS('identifier',exp)
    this.vRSV('status',exp,'ConsentState',ConsentStateVsValidation,'r')
    this.vOA('category',exp)
    this.vRS('patient',exp)
    this.vOS('period',exp)
    this.vOS('dateTime',exp)
    this.vOA('consentingParty',exp)
    this.vOA('actor',exp)
    this.vOA('action',exp)
    this.vOA('organization',exp)
    this.vOS('source',exp)
    this.vOA('policy',exp)
    this.vOS('policyRule',exp)
    this.vOA('securityLabel',exp)
    this.vOA('purpose',exp)
    this.vOS('dataPeriod',exp)
    this.vOA('data',exp)
    this.vOA('except',exp)
    return issues;
  }
}
