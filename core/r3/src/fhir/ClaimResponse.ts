// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: ClaimResponse

import * as fhir from '../fhir.js';

// @ts-ignore
import { AdjudicationCodes,  AdjudicationCodeType } from '../fhirValueSets/AdjudicationCodes.js';
// @ts-ignore
import { AdjudicationVsValidation } from '../fhirValueSets/AdjudicationVsValidation.js';
// @ts-ignore
import { AdjudicationReasonCodes,  AdjudicationReasonCodeType } from '../fhirValueSets/AdjudicationReasonCodes.js';
// @ts-ignore
import { AdjudicationReasonVsValidation } from '../fhirValueSets/AdjudicationReasonVsValidation.js';
// @ts-ignore
import { ExRevenueCenterCodes,  ExRevenueCenterCodeType } from '../fhirValueSets/ExRevenueCenterCodes.js';
// @ts-ignore
import { ExRevenueCenterVsValidation } from '../fhirValueSets/ExRevenueCenterVsValidation.js';
// @ts-ignore
import { BenefitSubcategoryCodes,  BenefitSubcategoryCodeType } from '../fhirValueSets/BenefitSubcategoryCodes.js';
// @ts-ignore
import { BenefitSubcategoryVsValidation } from '../fhirValueSets/BenefitSubcategoryVsValidation.js';
// @ts-ignore
import { ServiceUsclsCodes,  ServiceUsclsCodeType } from '../fhirValueSets/ServiceUsclsCodes.js';
// @ts-ignore
import { ServiceUsclsVsValidation } from '../fhirValueSets/ServiceUsclsVsValidation.js';
// @ts-ignore
import { ClaimModifiersCodes,  ClaimModifiersCodeType } from '../fhirValueSets/ClaimModifiersCodes.js';
// @ts-ignore
import { ClaimModifiersVsValidation } from '../fhirValueSets/ClaimModifiersVsValidation.js';
// @ts-ignore
import { AdjudicationErrorCodes,  AdjudicationErrorCodeType } from '../fhirValueSets/AdjudicationErrorCodes.js';
// @ts-ignore
import { AdjudicationErrorVsValidation } from '../fhirValueSets/AdjudicationErrorVsValidation.js';
// @ts-ignore
import { ExPaymenttypeCodes,  ExPaymenttypeCodeType } from '../fhirValueSets/ExPaymenttypeCodes.js';
// @ts-ignore
import { ExPaymenttypeVsValidation } from '../fhirValueSets/ExPaymenttypeVsValidation.js';
// @ts-ignore
import { PaymentAdjustmentReasonCodes,  PaymentAdjustmentReasonCodeType } from '../fhirValueSets/PaymentAdjustmentReasonCodes.js';
// @ts-ignore
import { PaymentAdjustmentReasonVsValidation } from '../fhirValueSets/PaymentAdjustmentReasonVsValidation.js';
// @ts-ignore
import { NoteTypeCodes,  NoteTypeCodeType } from '../fhirValueSets/NoteTypeCodes.js';
// @ts-ignore
import { NoteTypeVsValidation } from '../fhirValueSets/NoteTypeVsValidation.js';
// @ts-ignore
import { LanguagesCodes,  LanguagesCodeType } from '../fhirValueSets/LanguagesCodes.js';
// @ts-ignore
import { LanguagesVsValidation } from '../fhirValueSets/LanguagesVsValidation.js';
// @ts-ignore
import { FmStatusCodes,  FmStatusCodeType } from '../fhirValueSets/FmStatusCodes.js';
// @ts-ignore
import { FmStatusVsValidation } from '../fhirValueSets/FmStatusVsValidation.js';
// @ts-ignore
import { RemittanceOutcomeCodes,  RemittanceOutcomeCodeType } from '../fhirValueSets/RemittanceOutcomeCodes.js';
// @ts-ignore
import { RemittanceOutcomeVsValidation } from '../fhirValueSets/RemittanceOutcomeVsValidation.js';
// @ts-ignore
import { PayeetypeCodes,  PayeetypeCodeType } from '../fhirValueSets/PayeetypeCodes.js';
// @ts-ignore
import { PayeetypeVsValidation } from '../fhirValueSets/PayeetypeVsValidation.js';
// @ts-ignore
import { FundsreserveCodes,  FundsreserveCodeType } from '../fhirValueSets/FundsreserveCodes.js';
// @ts-ignore
import { FundsreserveVsValidation } from '../fhirValueSets/FundsreserveVsValidation.js';
// @ts-ignore
import { FormsCodes,  FormsCodeType } from '../fhirValueSets/FormsCodes.js';
// @ts-ignore
import { FormsVsValidation } from '../fhirValueSets/FormsVsValidation.js';
/**
 * Valid arguments for the ClaimResponseItemAdjudication type.
 */
export interface ClaimResponseItemAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  category: fhir.CodeableConceptArgs|null;
  /**
   * Adjudication reason such as limit reached.
   */
  reason?: fhir.CodeableConceptArgs|undefined;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.MoneyArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudication results.
 */
export class ClaimResponseItemAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public category: fhir.CodeableConcept|null;
  /**
   * Adjudication reason such as limit reached.
   */
  public reason?: fhir.CodeableConcept|undefined;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Money|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseItemAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    else { this.category = null; }
    if (source['reason']) { this.reason = new fhir.CodeableConcept(source.reason); }
    if (source['amount']) { this.amount = new fhir.Money(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.adjudication' }
    this.vRS('category',exp)
    this.vOS('reason',exp)
    this.vOS('amount',exp)
    this.vOS('value',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetailSubDetail type.
 */
export interface ClaimResponseItemDetailSubDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.subDetail.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.subDetail.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
}

/**
 * The third tier service adjudications for submitted services.
 */
export class ClaimResponseItemDetailSubDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetailSubDetail';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * Default constructor for ClaimResponseItemDetailSubDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailSubDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail.subDetail' }
    this.vRS('sequenceLinkId',exp)
    this.vOA('noteNumber',exp)
    this.vOA('adjudication',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetail type.
 */
export interface ClaimResponseItemDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
  /**
   * The third tier service adjudications for submitted services.
   */
  subDetail?: fhir.ClaimResponseItemDetailSubDetailArgs[]|undefined;
}

/**
 * The second tier service adjudications for submitted services.
 */
export class ClaimResponseItemDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetail';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * The third tier service adjudications for submitted services.
   */
  public subDetail: fhir.ClaimResponseItemDetailSubDetail[];
  /**
   * Default constructor for ClaimResponseItemDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['subDetail']) { this.subDetail = source.subDetail.map((x) => new fhir.ClaimResponseItemDetailSubDetail(x)); }
    else { this.subDetail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail' }
    this.vRS('sequenceLinkId',exp)
    this.vOA('noteNumber',exp)
    this.vOA('adjudication',exp)
    this.vOA('subDetail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseItem type.
 */
export interface ClaimResponseItemArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudication results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
  /**
   * The second tier service adjudications for submitted services.
   */
  detail?: fhir.ClaimResponseItemDetailArgs[]|undefined;
}

/**
 * The first tier service adjudications for submitted services.
 */
export class ClaimResponseItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItem';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudication results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * The second tier service adjudications for submitted services.
   */
  public detail: fhir.ClaimResponseItemDetail[];
  /**
   * Default constructor for ClaimResponseItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.ClaimResponseItemDetail(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item' }
    this.vRS('sequenceLinkId',exp)
    this.vOA('noteNumber',exp)
    this.vOA('adjudication',exp)
    this.vOA('detail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItemDetail type.
 */
export interface ClaimResponseAddItemDetailArgs extends fhir.BackboneElementArgs {
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  revenue?: fhir.CodeableConceptArgs|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  service?: fhir.CodeableConceptArgs|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  modifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The fee charged for the professional service or product..
   */
  fee?: fhir.MoneyArgs|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.detail.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
}

/**
 * The second tier service adjudications for payor added services.
 */
export class ClaimResponseAddItemDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItemDetail';
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  public revenue?: fhir.CodeableConcept|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  public service?: fhir.CodeableConcept|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  public modifier: fhir.CodeableConcept[];
  /**
   * The fee charged for the professional service or product..
   */
  public fee?: fhir.Money|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * Default constructor for ClaimResponseAddItemDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['revenue']) { this.revenue = new fhir.CodeableConcept(source.revenue); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['service']) { this.service = new fhir.CodeableConcept(source.service); }
    if (source['modifier']) { this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.modifier = []; }
    if (source['fee']) { this.fee = new fhir.Money(source.fee); }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem.detail' }
    this.vOS('revenue',exp)
    this.vOS('category',exp)
    this.vOS('service',exp)
    this.vOA('modifier',exp)
    this.vOS('fee',exp)
    this.vOA('noteNumber',exp)
    this.vOA('adjudication',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItem type.
 */
export interface ClaimResponseAddItemArgs extends fhir.BackboneElementArgs {
  /**
   * List of input service items which this service line is intended to replace.
   */
  sequenceLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.sequenceLinkId
   */
  _sequenceLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  revenue?: fhir.CodeableConceptArgs|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  service?: fhir.CodeableConceptArgs|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  modifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The fee charged for the professional service or product..
   */
  fee?: fhir.MoneyArgs|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
  /**
   * The second tier service adjudications for payor added services.
   */
  detail?: fhir.ClaimResponseAddItemDetailArgs[]|undefined;
}

/**
 * The first tier service adjudications for payor added services.
 */
export class ClaimResponseAddItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItem';
  /**
   * List of input service items which this service line is intended to replace.
   */
  public sequenceLinkId: fhir.FhirPositiveInt[];
  /**
   * The type of reveneu or cost center providing the product and/or service.
   */
  public revenue?: fhir.CodeableConcept|undefined;
  /**
   * Health Care Service Type Codes  to identify the classification of service or benefits.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  public service?: fhir.CodeableConcept|undefined;
  /**
   * Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
   */
  public modifier: fhir.CodeableConcept[];
  /**
   * The fee charged for the professional service or product..
   */
  public fee?: fhir.Money|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * The second tier service adjudications for payor added services.
   */
  public detail: fhir.ClaimResponseAddItemDetail[];
  /**
   * Default constructor for ClaimResponseAddItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = source.sequenceLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.sequenceLinkId = []; }
    if (source['_sequenceLinkId']) {
      source._sequenceLinkId.forEach((x,i) => {
        if (this.sequenceLinkId.length >= i) { if (x) { this.sequenceLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.sequenceLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['revenue']) { this.revenue = new fhir.CodeableConcept(source.revenue); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['service']) { this.service = new fhir.CodeableConcept(source.service); }
    if (source['modifier']) { this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.modifier = []; }
    if (source['fee']) { this.fee = new fhir.Money(source.fee); }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.ClaimResponseAddItemDetail(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem' }
    this.vOA('sequenceLinkId',exp)
    this.vOS('revenue',exp)
    this.vOS('category',exp)
    this.vOS('service',exp)
    this.vOA('modifier',exp)
    this.vOS('fee',exp)
    this.vOA('noteNumber',exp)
    this.vOA('adjudication',exp)
    this.vOA('detail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseError type.
 */
export interface ClaimResponseErrorArgs extends fhir.BackboneElementArgs {
  /**
   * The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
   */
  sequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  detailSequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.detailSequenceLinkId
   */
  _detailSequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  subdetailSequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.subdetailSequenceLinkId
   */
  _subdetailSequenceLinkId?:fhir.FhirElementArgs;
  /**
   * An error code,from a specified code system, which details why the claim could not be adjudicated.
   */
  code: fhir.CodeableConceptArgs|null;
}

/**
 * Mutually exclusive with Services Provided (Item).
 */
export class ClaimResponseError extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseError';
  /**
   * The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
   */
  public sequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  public detailSequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  public subdetailSequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * An error code,from a specified code system, which details why the claim could not be adjudicated.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * Default constructor for ClaimResponseError - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseErrorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['detailSequenceLinkId']) { this.detailSequenceLinkId = new fhir.FhirPositiveInt({value: source.detailSequenceLinkId}); }
    if (source['_detailSequenceLinkId']) {
      if (this.detailSequenceLinkId) { this.detailSequenceLinkId.addExtendedProperties(source._detailSequenceLinkId!); }
      else { this.detailSequenceLinkId = new fhir.FhirPositiveInt(source._detailSequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['subdetailSequenceLinkId']) { this.subdetailSequenceLinkId = new fhir.FhirPositiveInt({value: source.subdetailSequenceLinkId}); }
    if (source['_subdetailSequenceLinkId']) {
      if (this.subdetailSequenceLinkId) { this.subdetailSequenceLinkId.addExtendedProperties(source._subdetailSequenceLinkId!); }
      else { this.subdetailSequenceLinkId = new fhir.FhirPositiveInt(source._subdetailSequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.error' }
    this.vOS('sequenceLinkId',exp)
    this.vOS('detailSequenceLinkId',exp)
    this.vOS('subdetailSequenceLinkId',exp)
    this.vRS('code',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponsePayment type.
 */
export interface ClaimResponsePaymentArgs extends fhir.BackboneElementArgs {
  /**
   * Whether this represents partial or complete payment of the claim.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
   */
  adjustment?: fhir.MoneyArgs|undefined;
  /**
   * Reason for the payment adjustment.
   */
  adjustmentReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * Estimated payment data.
   */
  date?: fhir.FhirDate|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.payment.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Payable less any payment adjustment.
   */
  amount?: fhir.MoneyArgs|undefined;
  /**
   * Payment identifier.
   */
  identifier?: fhir.IdentifierArgs|undefined;
}

/**
 * Payment details for the claim if the claim has been paid.
 */
export class ClaimResponsePayment extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponsePayment';
  /**
   * Whether this represents partial or complete payment of the claim.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
   */
  public adjustment?: fhir.Money|undefined;
  /**
   * Reason for the payment adjustment.
   */
  public adjustmentReason?: fhir.CodeableConcept|undefined;
  /**
   * Estimated payment data.
   */
  public date?: fhir.FhirDate|undefined;
  /**
   * Payable less any payment adjustment.
   */
  public amount?: fhir.Money|undefined;
  /**
   * Payment identifier.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Default constructor for ClaimResponsePayment - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponsePaymentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['adjustment']) { this.adjustment = new fhir.Money(source.adjustment); }
    if (source['adjustmentReason']) { this.adjustmentReason = new fhir.CodeableConcept(source.adjustmentReason); }
    if (source['date']) { this.date = new fhir.FhirDate({value: source.date}); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDate(source._date as Partial<fhir.FhirDateArgs>); }
    }
    if (source['amount']) { this.amount = new fhir.Money(source.amount); }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.payment' }
    this.vOS('type',exp)
    this.vOS('adjustment',exp)
    this.vOS('adjustmentReason',exp)
    this.vOS('date',exp)
    this.vOS('amount',exp)
    this.vOS('identifier',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseProcessNote type.
 */
export interface ClaimResponseProcessNoteArgs extends fhir.BackboneElementArgs {
  /**
   * An integer associated with each note which may be referred to from each service line item.
   */
  number?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.processNote.number
   */
  _number?:fhir.FhirElementArgs;
  /**
   * The note purpose: Print/Display.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The note text.
   */
  text?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.processNote.text
   */
  _text?:fhir.FhirElementArgs;
  /**
   * The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
   */
  language?: fhir.CodeableConceptArgs|undefined;
}

/**
 * Note text.
 */
export class ClaimResponseProcessNote extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseProcessNote';
  /**
   * An integer associated with each note which may be referred to from each service line item.
   */
  public number?: fhir.FhirPositiveInt|undefined;
  /**
   * The note purpose: Print/Display.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The note text.
   */
  public text?: fhir.FhirString|undefined;
  /**
   * The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
   */
  public language?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ClaimResponseProcessNote - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseProcessNoteArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['number']) { this.number = new fhir.FhirPositiveInt({value: source.number}); }
    if (source['_number']) {
      if (this.number) { this.number.addExtendedProperties(source._number!); }
      else { this.number = new fhir.FhirPositiveInt(source._number as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['text']) { this.text = new fhir.FhirString({value: source.text}); }
    if (source['_text']) {
      if (this.text) { this.text.addExtendedProperties(source._text!); }
      else { this.text = new fhir.FhirString(source._text as Partial<fhir.FhirStringArgs>); }
    }
    if (source['language']) { this.language = new fhir.CodeableConcept(source.language); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.processNote' }
    this.vOS('number',exp)
    this.vOSV('type',exp,'NoteType',NoteTypeVsValidation,'r')
    this.vOS('text',exp)
    this.vOS('language',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponseInsurance type.
 */
export interface ClaimResponseInsuranceArgs extends fhir.BackboneElementArgs {
  /**
   * A service line item.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.insurance.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
   */
  focal: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.insurance.focal
   */
  _focal?:fhir.FhirElementArgs;
  /**
   * Reference to the program or plan identification, underwriter or payor.
   */
  coverage: fhir.ReferenceArgs|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  businessArrangement?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.insurance.businessArrangement
   */
  _businessArrangement?:fhir.FhirElementArgs;
  /**
   * A list of references from the Insurer to which these services pertain.
   */
  preAuthRef?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.insurance.preAuthRef
   */
  _preAuthRef?:(fhir.FhirElementArgs|null)[];
  /**
   * The Coverages adjudication details.
   */
  claimResponse?: fhir.ReferenceArgs|undefined;
}

/**
 * Financial instrument by which payment information for health care.
 */
export class ClaimResponseInsurance extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseInsurance';
  /**
   * A service line item.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
   */
  public focal: fhir.FhirBoolean|null;
  /**
   * Reference to the program or plan identification, underwriter or payor.
   */
  public coverage: fhir.Reference|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  public businessArrangement?: fhir.FhirString|undefined;
  /**
   * A list of references from the Insurer to which these services pertain.
   */
  public preAuthRef: fhir.FhirString[];
  /**
   * The Coverages adjudication details.
   */
  public claimResponse?: fhir.Reference|undefined;
  /**
   * Default constructor for ClaimResponseInsurance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseInsuranceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['focal']) { this.focal = new fhir.FhirBoolean({value: source.focal}); }
    else { this.focal = null; }
    if (source['_focal']) {
      if (this.focal) { this.focal.addExtendedProperties(source._focal!); }
      else { this.focal = new fhir.FhirBoolean(source._focal as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['coverage']) { this.coverage = new fhir.Reference(source.coverage); }
    else { this.coverage = null; }
    if (source['businessArrangement']) { this.businessArrangement = new fhir.FhirString({value: source.businessArrangement}); }
    if (source['_businessArrangement']) {
      if (this.businessArrangement) { this.businessArrangement.addExtendedProperties(source._businessArrangement!); }
      else { this.businessArrangement = new fhir.FhirString(source._businessArrangement as Partial<fhir.FhirStringArgs>); }
    }
    if (source['preAuthRef']) { this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({value: x})); }
    else { this.preAuthRef = []; }
    if (source['_preAuthRef']) {
      source._preAuthRef.forEach((x,i) => {
        if (this.preAuthRef.length >= i) { if (x) { this.preAuthRef[i].addExtendedProperties(x); } }
        else { if (x) { this.preAuthRef.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['claimResponse']) { this.claimResponse = new fhir.Reference(source.claimResponse); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.insurance' }
    this.vRS('sequence',exp)
    this.vRS('focal',exp)
    this.vRS('coverage',exp)
    this.vOS('businessArrangement',exp)
    this.vOA('preAuthRef',exp)
    this.vOS('claimResponse',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ClaimResponse type.
 */
export interface ClaimResponseArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "ClaimResponse"|undefined;
  /**
   * The Response business identifier.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains the code cancelled and entered-in-error that mark the response as not currently valid.
   */
  status?: fhir.FhirCode<FmStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * Patient Resource.
   */
  patient?: fhir.ReferenceArgs|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  created?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.created
   */
  _created?:fhir.FhirElementArgs;
  /**
   * The Insurer who produced this adjudicated response.
   */
  insurer?: fhir.ReferenceArgs|undefined;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  requestProvider?: fhir.ReferenceArgs|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  requestOrganization?: fhir.ReferenceArgs|undefined;
  /**
   * Original request resource referrence.
   */
  request?: fhir.ReferenceArgs|undefined;
  /**
   * Processing outcome errror, partial or complete processing.
   */
  outcome?: fhir.CodeableConceptArgs|undefined;
  /**
   * A description of the status of the adjudication.
   */
  disposition?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.disposition
   */
  _disposition?:fhir.FhirElementArgs;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  payeeType?: fhir.CodeableConceptArgs|undefined;
  /**
   * The first tier service adjudications for submitted services.
   */
  item?: fhir.ClaimResponseItemArgs[]|undefined;
  /**
   * The first tier service adjudications for payor added services.
   */
  addItem?: fhir.ClaimResponseAddItemArgs[]|undefined;
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  error?: fhir.ClaimResponseErrorArgs[]|undefined;
  /**
   * The total cost of the services reported.
   */
  totalCost?: fhir.MoneyArgs|undefined;
  /**
   * The amount of deductible applied which was not allocated to any particular service line.
   */
  unallocDeductable?: fhir.MoneyArgs|undefined;
  /**
   * Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
   */
  totalBenefit?: fhir.MoneyArgs|undefined;
  /**
   * Payment details for the claim if the claim has been paid.
   */
  payment?: fhir.ClaimResponsePaymentArgs|undefined;
  /**
   * Status of funds reservation (For provider, for Patient, None).
   */
  reserved?: fhir.CodingArgs|undefined;
  /**
   * The form to be used for printing the content.
   */
  form?: fhir.CodeableConceptArgs|undefined;
  /**
   * Note text.
   */
  processNote?: fhir.ClaimResponseProcessNoteArgs[]|undefined;
  /**
   * Request for additional supporting or authorizing information, such as: documents, images or resources.
   */
  communicationRequest?: fhir.ReferenceArgs[]|undefined;
  /**
   * Financial instrument by which payment information for health care.
   */
  insurance?: fhir.ClaimResponseInsuranceArgs[]|undefined;
}

/**
 * This resource provides the adjudication details from the processing of a Claim resource.
 */
export class ClaimResponse extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponse';
  /**
   * Resource Type Name
   */
  public override resourceType: "ClaimResponse";
  /**
   * The Response business identifier.
   */
  public identifier: fhir.Identifier[];
  /**
   * This element is labeled as a modifier because the status contains the code cancelled and entered-in-error that mark the response as not currently valid.
   */
  public status?: fhir.FhirCode<FmStatusCodeType>|undefined;
  /**
   * Patient Resource.
   */
  public patient?: fhir.Reference|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  public created?: fhir.FhirDateTime|undefined;
  /**
   * The Insurer who produced this adjudicated response.
   */
  public insurer?: fhir.Reference|undefined;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  public requestProvider?: fhir.Reference|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  public requestOrganization?: fhir.Reference|undefined;
  /**
   * Original request resource referrence.
   */
  public request?: fhir.Reference|undefined;
  /**
   * Processing outcome errror, partial or complete processing.
   */
  public outcome?: fhir.CodeableConcept|undefined;
  /**
   * A description of the status of the adjudication.
   */
  public disposition?: fhir.FhirString|undefined;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  public payeeType?: fhir.CodeableConcept|undefined;
  /**
   * The first tier service adjudications for submitted services.
   */
  public item: fhir.ClaimResponseItem[];
  /**
   * The first tier service adjudications for payor added services.
   */
  public addItem: fhir.ClaimResponseAddItem[];
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  public error: fhir.ClaimResponseError[];
  /**
   * The total cost of the services reported.
   */
  public totalCost?: fhir.Money|undefined;
  /**
   * The amount of deductible applied which was not allocated to any particular service line.
   */
  public unallocDeductable?: fhir.Money|undefined;
  /**
   * Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
   */
  public totalBenefit?: fhir.Money|undefined;
  /**
   * Payment details for the claim if the claim has been paid.
   */
  public payment?: fhir.ClaimResponsePayment|undefined;
  /**
   * Status of funds reservation (For provider, for Patient, None).
   */
  public reserved?: fhir.Coding|undefined;
  /**
   * The form to be used for printing the content.
   */
  public form?: fhir.CodeableConcept|undefined;
  /**
   * Note text.
   */
  public processNote: fhir.ClaimResponseProcessNote[];
  /**
   * Request for additional supporting or authorizing information, such as: documents, images or resources.
   */
  public communicationRequest: fhir.Reference[];
  /**
   * Financial instrument by which payment information for health care.
   */
  public insurance: fhir.ClaimResponseInsurance[];
  /**
   * Default constructor for ClaimResponse - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'ClaimResponse';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['status']) { this.status = new fhir.FhirCode<FmStatusCodeType>({value: source.status}); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<FmStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['patient']) { this.patient = new fhir.Reference(source.patient); }
    if (source['created']) { this.created = new fhir.FhirDateTime({value: source.created}); }
    if (source['_created']) {
      if (this.created) { this.created.addExtendedProperties(source._created!); }
      else { this.created = new fhir.FhirDateTime(source._created as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['insurer']) { this.insurer = new fhir.Reference(source.insurer); }
    if (source['requestProvider']) { this.requestProvider = new fhir.Reference(source.requestProvider); }
    if (source['requestOrganization']) { this.requestOrganization = new fhir.Reference(source.requestOrganization); }
    if (source['request']) { this.request = new fhir.Reference(source.request); }
    if (source['outcome']) { this.outcome = new fhir.CodeableConcept(source.outcome); }
    if (source['disposition']) { this.disposition = new fhir.FhirString({value: source.disposition}); }
    if (source['_disposition']) {
      if (this.disposition) { this.disposition.addExtendedProperties(source._disposition!); }
      else { this.disposition = new fhir.FhirString(source._disposition as Partial<fhir.FhirStringArgs>); }
    }
    if (source['payeeType']) { this.payeeType = new fhir.CodeableConcept(source.payeeType); }
    if (source['item']) { this.item = source.item.map((x) => new fhir.ClaimResponseItem(x)); }
    else { this.item = []; }
    if (source['addItem']) { this.addItem = source.addItem.map((x) => new fhir.ClaimResponseAddItem(x)); }
    else { this.addItem = []; }
    if (source['error']) { this.error = source.error.map((x) => new fhir.ClaimResponseError(x)); }
    else { this.error = []; }
    if (source['totalCost']) { this.totalCost = new fhir.Money(source.totalCost); }
    if (source['unallocDeductable']) { this.unallocDeductable = new fhir.Money(source.unallocDeductable); }
    if (source['totalBenefit']) { this.totalBenefit = new fhir.Money(source.totalBenefit); }
    if (source['payment']) { this.payment = new fhir.ClaimResponsePayment(source.payment); }
    if (source['reserved']) { this.reserved = new fhir.Coding(source.reserved); }
    if (source['form']) { this.form = new fhir.CodeableConcept(source.form); }
    if (source['processNote']) { this.processNote = source.processNote.map((x) => new fhir.ClaimResponseProcessNote(x)); }
    else { this.processNote = []; }
    if (source['communicationRequest']) { this.communicationRequest = source.communicationRequest.map((x) => new fhir.Reference(x)); }
    else { this.communicationRequest = []; }
    if (source['insurance']) { this.insurance = source.insurance.map((x) => new fhir.ClaimResponseInsurance(x)); }
    else { this.insurance = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOSV('status',exp,'FmStatus',FmStatusVsValidation,'r')
    this.vOS('patient',exp)
    this.vOS('created',exp)
    this.vOS('insurer',exp)
    this.vOS('requestProvider',exp)
    this.vOS('requestOrganization',exp)
    this.vOS('request',exp)
    this.vOS('outcome',exp)
    this.vOS('disposition',exp)
    this.vOS('payeeType',exp)
    this.vOA('item',exp)
    this.vOA('addItem',exp)
    this.vOA('error',exp)
    this.vOS('totalCost',exp)
    this.vOS('unallocDeductable',exp)
    this.vOS('totalBenefit',exp)
    this.vOS('payment',exp)
    this.vOS('reserved',exp)
    this.vOS('form',exp)
    this.vOA('processNote',exp)
    this.vOA('communicationRequest',exp)
    this.vOA('insurance',exp)
    return issues;
  }
}
