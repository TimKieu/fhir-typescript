// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: ExpansionProfile

import * as fhir from '../fhir.js';

// @ts-ignore
import { SystemVersionProcessingModeCodes,  SystemVersionProcessingModeCodeType } from '../fhirValueSets/SystemVersionProcessingModeCodes.js';
// @ts-ignore
import { SystemVersionProcessingModeVsValidation } from '../fhirValueSets/SystemVersionProcessingModeVsValidation.js';
// @ts-ignore
import { LanguagesCodes,  LanguagesCodeType } from '../fhirValueSets/LanguagesCodes.js';
// @ts-ignore
import { LanguagesVsValidation } from '../fhirValueSets/LanguagesVsValidation.js';
// @ts-ignore
import { DesignationUseCodes,  DesignationUseCodeType } from '../fhirValueSets/DesignationUseCodes.js';
// @ts-ignore
import { DesignationUseVsValidation } from '../fhirValueSets/DesignationUseVsValidation.js';
// @ts-ignore
import { PublicationStatusCodes,  PublicationStatusCodeType } from '../fhirValueSets/PublicationStatusCodes.js';
// @ts-ignore
import { PublicationStatusVsValidation } from '../fhirValueSets/PublicationStatusVsValidation.js';
// @ts-ignore
import { JurisdictionCodes,  JurisdictionCodeType } from '../fhirValueSets/JurisdictionCodes.js';
// @ts-ignore
import { JurisdictionVsValidation } from '../fhirValueSets/JurisdictionVsValidation.js';
/**
 * Valid arguments for the ExpansionProfileFixedVersion type.
 */
export interface ExpansionProfileFixedVersionArgs extends fhir.BackboneElementArgs {
  /**
   * See ''Coding.system'' for further documentation.
   */
  system: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.fixedVersion.system
   */
  _system?:fhir.FhirElementArgs;
  /**
   * The version of the code system from which codes in the expansion should be included.
   */
  version: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.fixedVersion.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * How to manage the intersection between a fixed version in a value set, and this fixed version of the system in the expansion profile.
   */
  mode: fhir.FhirCode<SystemVersionProcessingModeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.fixedVersion.mode
   */
  _mode?:fhir.FhirElementArgs;
}

/**
 * Fix use of a particular code system to a particular version.
 */
export class ExpansionProfileFixedVersion extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileFixedVersion';
  /**
   * See ''Coding.system'' for further documentation.
   */
  public system: fhir.FhirUri|null;
  /**
   * The version of the code system from which codes in the expansion should be included.
   */
  public version: fhir.FhirString|null;
  /**
   * How to manage the intersection between a fixed version in a value set, and this fixed version of the system in the expansion profile.
   */
  public mode: fhir.FhirCode<SystemVersionProcessingModeCodeType>|null;
  /**
   * Default constructor for ExpansionProfileFixedVersion - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileFixedVersionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['system'] !== undefined) { this.system = new fhir.FhirUri({value: source.system}, options); }
    else { this.system = null; }
    if (source['_system']) {
      if (this.system) { this.system.addExtendedProperties(source._system!); }
      else { this.system = new fhir.FhirUri(source._system as Partial<fhir.FhirUriArgs>, options); }
    }
    if (source['version'] !== undefined) { this.version = new fhir.FhirString({value: source.version}, options); }
    else { this.version = null; }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['mode'] !== undefined) { this.mode = new fhir.FhirCode<SystemVersionProcessingModeCodeType>({value: source.mode}, options); }
    else { this.mode = null; }
    if (source['_mode']) {
      if (this.mode) { this.mode.addExtendedProperties(source._mode!); }
      else { this.mode = new fhir.FhirCode<SystemVersionProcessingModeCodeType>(source._mode as Partial<fhir.FhirCode>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.fixedVersion' }
    iss.push(...this.vRS('system',exp));
    iss.push(...this.vRS('version',exp));
    iss.push(...this.vRSV('mode',exp,'SystemVersionProcessingMode',SystemVersionProcessingModeVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileExcludedSystem type.
 */
export interface ExpansionProfileExcludedSystemArgs extends fhir.BackboneElementArgs {
  /**
   * See ''Coding.system'' for further documentation.
   */
  system: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.excludedSystem.system
   */
  _system?:fhir.FhirElementArgs;
  /**
   * This is used to apply version specifc exclusion contraints. If no version is specified, then all codes from the code system present in the expansion (prior to application of the expansion profile) will be excluded.
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.excludedSystem.version
   */
  _version?:fhir.FhirElementArgs;
}

/**
 * When a system is excluded, and this makes a material difference to the expansion, the exclusion SHALL  be noted in the expansion parameters using a parameter 'excluded'.
 */
export class ExpansionProfileExcludedSystem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileExcludedSystem';
  /**
   * See ''Coding.system'' for further documentation.
   */
  public system: fhir.FhirUri|null;
  /**
   * This is used to apply version specifc exclusion contraints. If no version is specified, then all codes from the code system present in the expansion (prior to application of the expansion profile) will be excluded.
   */
  public version?: fhir.FhirString|undefined;
  /**
   * Default constructor for ExpansionProfileExcludedSystem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileExcludedSystemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['system'] !== undefined) { this.system = new fhir.FhirUri({value: source.system}, options); }
    else { this.system = null; }
    if (source['_system']) {
      if (this.system) { this.system.addExtendedProperties(source._system!); }
      else { this.system = new fhir.FhirUri(source._system as Partial<fhir.FhirUriArgs>, options); }
    }
    if (source['version'] !== undefined) { this.version = new fhir.FhirString({value: source.version}, options); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.excludedSystem' }
    iss.push(...this.vRS('system',exp));
    iss.push(...this.vOS('version',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileDesignationIncludeDesignation type.
 */
export interface ExpansionProfileDesignationIncludeDesignationArgs extends fhir.BackboneElementArgs {
  /**
   * In the absence of a language, all designations are retained which match the designation.use parameter for this include.designation.
   */
  language?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.designation.include.designation.language
   */
  _language?:fhir.FhirElementArgs;
  /**
   * In the absence of a use, all designations are retained which match the designation.language parameter for this include.designation element.
   */
  use?: fhir.CodingArgs|undefined;
}

/**
 * At least one of designation.language or designation.use must be provided for each include.designation element.
 */
export class ExpansionProfileDesignationIncludeDesignation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileDesignationIncludeDesignation';
  /**
   * In the absence of a language, all designations are retained which match the designation.use parameter for this include.designation.
   */
  public language?: fhir.FhirCode|undefined;
  /**
   * In the absence of a use, all designations are retained which match the designation.language parameter for this include.designation element.
   */
  public use?: fhir.Coding|undefined;
  /**
   * Default constructor for ExpansionProfileDesignationIncludeDesignation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileDesignationIncludeDesignationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['language'] !== undefined) { this.language = new fhir.FhirCode({value: source.language}, options); }
    if (source['_language']) {
      if (this.language) { this.language.addExtendedProperties(source._language!); }
      else { this.language = new fhir.FhirCode(source._language as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['use']) { this.use = new fhir.Coding(source.use, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.designation.include.designation' }
    iss.push(...this.vOS('language',exp));
    iss.push(...this.vOSV('use',exp,'DesignationUse',DesignationUseVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileDesignationInclude type.
 */
export interface ExpansionProfileDesignationIncludeArgs extends fhir.BackboneElementArgs {
  /**
   * At least one of designation.language or designation.use must be provided for each include.designation element.
   */
  designation?: fhir.ExpansionProfileDesignationIncludeDesignationArgs[]|undefined;
}

/**
 * Designations to be included.
 */
export class ExpansionProfileDesignationInclude extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileDesignationInclude';
  /**
   * At least one of designation.language or designation.use must be provided for each include.designation element.
   */
  public designation: fhir.ExpansionProfileDesignationIncludeDesignation[];
  /**
   * Default constructor for ExpansionProfileDesignationInclude - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileDesignationIncludeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['designation']) { this.designation = source.designation.map((x) => new fhir.ExpansionProfileDesignationIncludeDesignation(x, options)); }
    else { this.designation = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.designation.include' }
    iss.push(...this.vOA('designation',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileDesignationExcludeDesignation type.
 */
export interface ExpansionProfileDesignationExcludeDesignationArgs extends fhir.BackboneElementArgs {
  /**
   * In the absence of a language, all designations are excluded which match the designation.use parameter for this exclude.designation element.
   */
  language?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.designation.exclude.designation.language
   */
  _language?:fhir.FhirElementArgs;
  /**
   * In the absence of a use, all designations are retained which match the designation.language parameter for this exclude.designation element.
   */
  use?: fhir.CodingArgs|undefined;
}

/**
 * At least one of designation.language or designation.use must be provided for each exclude.designation element.
 */
export class ExpansionProfileDesignationExcludeDesignation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileDesignationExcludeDesignation';
  /**
   * In the absence of a language, all designations are excluded which match the designation.use parameter for this exclude.designation element.
   */
  public language?: fhir.FhirCode|undefined;
  /**
   * In the absence of a use, all designations are retained which match the designation.language parameter for this exclude.designation element.
   */
  public use?: fhir.Coding|undefined;
  /**
   * Default constructor for ExpansionProfileDesignationExcludeDesignation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileDesignationExcludeDesignationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['language'] !== undefined) { this.language = new fhir.FhirCode({value: source.language}, options); }
    if (source['_language']) {
      if (this.language) { this.language.addExtendedProperties(source._language!); }
      else { this.language = new fhir.FhirCode(source._language as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['use']) { this.use = new fhir.Coding(source.use, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.designation.exclude.designation' }
    iss.push(...this.vOS('language',exp));
    iss.push(...this.vOSV('use',exp,'DesignationUse',DesignationUseVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileDesignationExclude type.
 */
export interface ExpansionProfileDesignationExcludeArgs extends fhir.BackboneElementArgs {
  /**
   * At least one of designation.language or designation.use must be provided for each exclude.designation element.
   */
  designation?: fhir.ExpansionProfileDesignationExcludeDesignationArgs[]|undefined;
}

/**
 * Designations to be excluded.
 */
export class ExpansionProfileDesignationExclude extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileDesignationExclude';
  /**
   * At least one of designation.language or designation.use must be provided for each exclude.designation element.
   */
  public designation: fhir.ExpansionProfileDesignationExcludeDesignation[];
  /**
   * Default constructor for ExpansionProfileDesignationExclude - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileDesignationExcludeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['designation']) { this.designation = source.designation.map((x) => new fhir.ExpansionProfileDesignationExcludeDesignation(x, options)); }
    else { this.designation = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.designation.exclude' }
    iss.push(...this.vOA('designation',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfileDesignation type.
 */
export interface ExpansionProfileDesignationArgs extends fhir.BackboneElementArgs {
  /**
   * Designations to be included.
   */
  include?: fhir.ExpansionProfileDesignationIncludeArgs|undefined;
  /**
   * Designations to be excluded.
   */
  exclude?: fhir.ExpansionProfileDesignationExcludeArgs|undefined;
}

/**
 * A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations.
 */
export class ExpansionProfileDesignation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfileDesignation';
  /**
   * Designations to be included.
   */
  public include?: fhir.ExpansionProfileDesignationInclude|undefined;
  /**
   * Designations to be excluded.
   */
  public exclude?: fhir.ExpansionProfileDesignationExclude|undefined;
  /**
   * Default constructor for ExpansionProfileDesignation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileDesignationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['include']) { this.include = new fhir.ExpansionProfileDesignationInclude(source.include, options); }
    if (source['exclude']) { this.exclude = new fhir.ExpansionProfileDesignationExclude(source.exclude, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile.designation' }
    iss.push(...this.vOS('include',exp));
    iss.push(...this.vOS('exclude',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ExpansionProfile type.
 */
export interface ExpansionProfileArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "ExpansionProfile"|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
   */
  url?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this expansion profile outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * There may be different expansion profile instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the expansion profile with the format [url]|[version].
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Allows filtering of expansion profiles that are appropriate for use vs. not.  
   * This is labeled as "Is Modifier" because applications should not use a retired expansion profile without due consideration.
   */
  status: fhir.FhirCode<PublicationStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * Allows filtering of expansion profile that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental expansion profile in production.
   */
  experimental?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.experimental
   */
  _experimental?:fhir.FhirElementArgs;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the expansion profile. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Usually an organization, but may be an individual. The publisher (or steward) of the expansion profile is the organization or individual primarily responsible for the maintenance and upkeep of the expansion profile. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the expansion profile. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.publisher
   */
  _publisher?:fhir.FhirElementArgs;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  contact?: fhir.ContactDetailArgs[]|undefined;
  /**
   * This description can be used to capture details such as why the expansion profile was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the expansion profile as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
   */
  description?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
   */
  useContext?: fhir.UsageContextArgs[]|undefined;
  /**
   * It may be possible for the expansion profile to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  jurisdiction?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Fix use of a particular code system to a particular version.
   */
  fixedVersion?: fhir.ExpansionProfileFixedVersionArgs[]|undefined;
  /**
   * When a system is excluded, and this makes a material difference to the expansion, the exclusion SHALL  be noted in the expansion parameters using a parameter 'excluded'.
   */
  excludedSystem?: fhir.ExpansionProfileExcludedSystemArgs|undefined;
  /**
   * ExpansionProfile.designation.include and ExpansionProfile.designation.exclude are only evaluated if includeDesignations is present and set to "true". If includeDesignations is present with a value of "true" and both ExpansionProfile.designation.include and ExpansionProfile.designation.exclude are absent, then all designations are returned in the expansion.
   */
  includeDesignations?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.includeDesignations
   */
  _includeDesignations?:fhir.FhirElementArgs;
  /**
   * A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations.
   */
  designation?: fhir.ExpansionProfileDesignationArgs|undefined;
  /**
   * The ValueSet defintion refers to all fields in the ValueSet definition apart from  ValueSet.contains. The definition is only included if includeDefinition is present and has a value of "true".
   */
  includeDefinition?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.includeDefinition
   */
  _includeDefinition?:fhir.FhirElementArgs;
  /**
   * Inactive codes are included if activeOnly is present and has a value of "true". Note that if the value set explicitly specifies that inactive codes are included, this property can still remove them from a specific expansion, but this parameter cannot include them if the value set excludes them.
   */
  activeOnly?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.activeOnly
   */
  _activeOnly?:fhir.FhirElementArgs;
  /**
   * Nesting of codes is excluded if excludeNested is present and has a value of "true".
   */
  excludeNested?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.excludeNested
   */
  _excludeNested?:fhir.FhirElementArgs;
  /**
   * Codes which cannot be used in user interfaces will be excluded if excludeNotForUI is present and has a value of "true".
   */
  excludeNotForUI?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.excludeNotForUI
   */
  _excludeNotForUI?:fhir.FhirElementArgs;
  /**
   * Post coordinated codes are excluded if excludePostCoordinated is present and has a value of "true".
   */
  excludePostCoordinated?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.excludePostCoordinated
   */
  _excludePostCoordinated?:fhir.FhirElementArgs;
  /**
   * Specifies the language to be used for description in the expansions i.e. the language to be used for ValueSet.expansion.contains.display.
   */
  displayLanguage?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.displayLanguage
   */
  _displayLanguage?:fhir.FhirElementArgs;
  /**
   * This field overides the default behaviour (which is to return an error). This does not apply to expansions which are unbounded. Clients SHALL process the extension [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html) correctly if limitedExpansion = true.
   */
  limitedExpansion?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ExpansionProfile.limitedExpansion
   */
  _limitedExpansion?:fhir.FhirElementArgs;
}

/**
 * Resource to define constraints on the Expansion of a FHIR ValueSet.
 */
export class ExpansionProfile extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ExpansionProfile';
  /**
   * Resource Type Name
   */
  public override resourceType: "ExpansionProfile";
  /**
   * Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
   */
  public url?: fhir.FhirUri|undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this expansion profile outside of FHIR, where it is not possible to use the logical URI.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * There may be different expansion profile instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the expansion profile with the format [url]|[version].
   */
  public version?: fhir.FhirString|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Allows filtering of expansion profiles that are appropriate for use vs. not.  
   * This is labeled as "Is Modifier" because applications should not use a retired expansion profile without due consideration.
   */
  public status: fhir.FhirCode<PublicationStatusCodeType>|null;
  /**
   * Allows filtering of expansion profile that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental expansion profile in production.
   */
  public experimental?: fhir.FhirBoolean|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the expansion profile. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Usually an organization, but may be an individual. The publisher (or steward) of the expansion profile is the organization or individual primarily responsible for the maintenance and upkeep of the expansion profile. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the expansion profile. This item SHOULD be populated unless the information is available from context.
   */
  public publisher?: fhir.FhirString|undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  public contact: fhir.ContactDetail[];
  /**
   * This description can be used to capture details such as why the expansion profile was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the expansion profile as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
   */
  public description?: fhir.FhirMarkdown|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
   */
  public useContext: fhir.UsageContext[];
  /**
   * It may be possible for the expansion profile to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  public jurisdiction: fhir.CodeableConcept[];
  /**
   * Fix use of a particular code system to a particular version.
   */
  public fixedVersion: fhir.ExpansionProfileFixedVersion[];
  /**
   * When a system is excluded, and this makes a material difference to the expansion, the exclusion SHALL  be noted in the expansion parameters using a parameter 'excluded'.
   */
  public excludedSystem?: fhir.ExpansionProfileExcludedSystem|undefined;
  /**
   * ExpansionProfile.designation.include and ExpansionProfile.designation.exclude are only evaluated if includeDesignations is present and set to "true". If includeDesignations is present with a value of "true" and both ExpansionProfile.designation.include and ExpansionProfile.designation.exclude are absent, then all designations are returned in the expansion.
   */
  public includeDesignations?: fhir.FhirBoolean|undefined;
  /**
   * A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations.
   */
  public designation?: fhir.ExpansionProfileDesignation|undefined;
  /**
   * The ValueSet defintion refers to all fields in the ValueSet definition apart from  ValueSet.contains. The definition is only included if includeDefinition is present and has a value of "true".
   */
  public includeDefinition?: fhir.FhirBoolean|undefined;
  /**
   * Inactive codes are included if activeOnly is present and has a value of "true". Note that if the value set explicitly specifies that inactive codes are included, this property can still remove them from a specific expansion, but this parameter cannot include them if the value set excludes them.
   */
  public activeOnly?: fhir.FhirBoolean|undefined;
  /**
   * Nesting of codes is excluded if excludeNested is present and has a value of "true".
   */
  public excludeNested?: fhir.FhirBoolean|undefined;
  /**
   * Codes which cannot be used in user interfaces will be excluded if excludeNotForUI is present and has a value of "true".
   */
  public excludeNotForUI?: fhir.FhirBoolean|undefined;
  /**
   * Post coordinated codes are excluded if excludePostCoordinated is present and has a value of "true".
   */
  public excludePostCoordinated?: fhir.FhirBoolean|undefined;
  /**
   * Specifies the language to be used for description in the expansions i.e. the language to be used for ValueSet.expansion.contains.display.
   */
  public displayLanguage?: fhir.FhirCode|undefined;
  /**
   * This field overides the default behaviour (which is to return an error). This does not apply to expansions which are unbounded. Clients SHALL process the extension [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html) correctly if limitedExpansion = true.
   */
  public limitedExpansion?: fhir.FhirBoolean|undefined;
  /**
   * Default constructor for ExpansionProfile - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ExpansionProfileArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'ExpansionProfile';
    if (source['url'] !== undefined) { this.url = new fhir.FhirUri({value: source.url}, options); }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>, options); }
    }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['version'] !== undefined) { this.version = new fhir.FhirString({value: source.version}, options); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['status'] !== undefined) { this.status = new fhir.FhirCode<PublicationStatusCodeType>({value: source.status}, options); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<PublicationStatusCodeType>(source._status as Partial<fhir.FhirCode>, options); }
    }
    if (source['experimental'] !== undefined) { this.experimental = new fhir.FhirBoolean({value: source.experimental}, options); }
    if (source['_experimental']) {
      if (this.experimental) { this.experimental.addExtendedProperties(source._experimental!); }
      else { this.experimental = new fhir.FhirBoolean(source._experimental as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['date'] !== undefined) { this.date = new fhir.FhirDateTime({value: source.date}, options); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>, options); }
    }
    if (source['publisher'] !== undefined) { this.publisher = new fhir.FhirString({value: source.publisher}, options); }
    if (source['_publisher']) {
      if (this.publisher) { this.publisher.addExtendedProperties(source._publisher!); }
      else { this.publisher = new fhir.FhirString(source._publisher as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.ContactDetail(x, options)); }
    else { this.contact = []; }
    if (source['description'] !== undefined) { this.description = new fhir.FhirMarkdown({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirMarkdown(source._description as Partial<fhir.FhirMarkdownArgs>, options); }
    }
    if (source['useContext']) { this.useContext = source.useContext.map((x) => new fhir.UsageContext(x, options)); }
    else { this.useContext = []; }
    if (source['jurisdiction']) { this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x, options)); }
    else { this.jurisdiction = []; }
    if (source['fixedVersion']) { this.fixedVersion = source.fixedVersion.map((x) => new fhir.ExpansionProfileFixedVersion(x, options)); }
    else { this.fixedVersion = []; }
    if (source['excludedSystem']) { this.excludedSystem = new fhir.ExpansionProfileExcludedSystem(source.excludedSystem, options); }
    if (source['includeDesignations'] !== undefined) { this.includeDesignations = new fhir.FhirBoolean({value: source.includeDesignations}, options); }
    if (source['_includeDesignations']) {
      if (this.includeDesignations) { this.includeDesignations.addExtendedProperties(source._includeDesignations!); }
      else { this.includeDesignations = new fhir.FhirBoolean(source._includeDesignations as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['designation']) { this.designation = new fhir.ExpansionProfileDesignation(source.designation, options); }
    if (source['includeDefinition'] !== undefined) { this.includeDefinition = new fhir.FhirBoolean({value: source.includeDefinition}, options); }
    if (source['_includeDefinition']) {
      if (this.includeDefinition) { this.includeDefinition.addExtendedProperties(source._includeDefinition!); }
      else { this.includeDefinition = new fhir.FhirBoolean(source._includeDefinition as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['activeOnly'] !== undefined) { this.activeOnly = new fhir.FhirBoolean({value: source.activeOnly}, options); }
    if (source['_activeOnly']) {
      if (this.activeOnly) { this.activeOnly.addExtendedProperties(source._activeOnly!); }
      else { this.activeOnly = new fhir.FhirBoolean(source._activeOnly as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['excludeNested'] !== undefined) { this.excludeNested = new fhir.FhirBoolean({value: source.excludeNested}, options); }
    if (source['_excludeNested']) {
      if (this.excludeNested) { this.excludeNested.addExtendedProperties(source._excludeNested!); }
      else { this.excludeNested = new fhir.FhirBoolean(source._excludeNested as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['excludeNotForUI'] !== undefined) { this.excludeNotForUI = new fhir.FhirBoolean({value: source.excludeNotForUI}, options); }
    if (source['_excludeNotForUI']) {
      if (this.excludeNotForUI) { this.excludeNotForUI.addExtendedProperties(source._excludeNotForUI!); }
      else { this.excludeNotForUI = new fhir.FhirBoolean(source._excludeNotForUI as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['excludePostCoordinated'] !== undefined) { this.excludePostCoordinated = new fhir.FhirBoolean({value: source.excludePostCoordinated}, options); }
    if (source['_excludePostCoordinated']) {
      if (this.excludePostCoordinated) { this.excludePostCoordinated.addExtendedProperties(source._excludePostCoordinated!); }
      else { this.excludePostCoordinated = new fhir.FhirBoolean(source._excludePostCoordinated as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['displayLanguage'] !== undefined) { this.displayLanguage = new fhir.FhirCode({value: source.displayLanguage}, options); }
    if (source['_displayLanguage']) {
      if (this.displayLanguage) { this.displayLanguage.addExtendedProperties(source._displayLanguage!); }
      else { this.displayLanguage = new fhir.FhirCode(source._displayLanguage as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['limitedExpansion'] !== undefined) { this.limitedExpansion = new fhir.FhirBoolean({value: source.limitedExpansion}, options); }
    if (source['_limitedExpansion']) {
      if (this.limitedExpansion) { this.limitedExpansion.addExtendedProperties(source._limitedExpansion!); }
      else { this.limitedExpansion = new fhir.FhirBoolean(source._limitedExpansion as Partial<fhir.FhirBooleanArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ExpansionProfile' }
    iss.push(...this.vOS('url',exp));
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOS('version',exp));
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vRSV('status',exp,'PublicationStatus',PublicationStatusVsValidation,'r'));
    iss.push(...this.vOS('experimental',exp));
    iss.push(...this.vOS('date',exp));
    iss.push(...this.vOS('publisher',exp));
    iss.push(...this.vOA('contact',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOA('useContext',exp));
    iss.push(...this.vOA('jurisdiction',exp));
    iss.push(...this.vOA('fixedVersion',exp));
    iss.push(...this.vOS('excludedSystem',exp));
    iss.push(...this.vOS('includeDesignations',exp));
    iss.push(...this.vOS('designation',exp));
    iss.push(...this.vOS('includeDefinition',exp));
    iss.push(...this.vOS('activeOnly',exp));
    iss.push(...this.vOS('excludeNested',exp));
    iss.push(...this.vOS('excludeNotForUI',exp));
    iss.push(...this.vOS('excludePostCoordinated',exp));
    iss.push(...this.vOS('displayLanguage',exp));
    iss.push(...this.vOS('limitedExpansion',exp));
    return iss;
  }
}
