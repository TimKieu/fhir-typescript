// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: MeasureReport

import * as fhir from '../fhir.js';

// @ts-ignore
import { MeasurePopulationCodes,  MeasurePopulationCodeType } from '../fhirValueSets/MeasurePopulationCodes.js';
// @ts-ignore
import { MeasurePopulationVsValidation } from '../fhirValueSets/MeasurePopulationVsValidation.js';
// @ts-ignore
import { MeasureReportStatusCodes,  MeasureReportStatusCodeType } from '../fhirValueSets/MeasureReportStatusCodes.js';
// @ts-ignore
import { MeasureReportStatusVsValidation } from '../fhirValueSets/MeasureReportStatusVsValidation.js';
// @ts-ignore
import { MeasureReportTypeCodes,  MeasureReportTypeCodeType } from '../fhirValueSets/MeasureReportTypeCodes.js';
// @ts-ignore
import { MeasureReportTypeVsValidation } from '../fhirValueSets/MeasureReportTypeVsValidation.js';
/**
 * Valid arguments for the MeasureReportGroupPopulation type.
 */
export interface MeasureReportGroupPopulationArgs extends fhir.BackboneElementArgs {
  /**
   * The identifier of the population being reported, as defined by the population element of the measure.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * The type of the population.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * The number of members of the population.
   */
  count?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.group.population.count
   */
  _count?:fhir.FhirElementArgs;
  /**
   * This element refers to a List of patient level MeasureReport resources, one for each patient in this population.
   */
  patients?: fhir.ReferenceArgs|undefined;
}

/**
 * The populations that make up the population group, one for each type of population appropriate for the measure.
 */
export class MeasureReportGroupPopulation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReportGroupPopulation';
  /**
   * The identifier of the population being reported, as defined by the population element of the measure.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The type of the population.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * The number of members of the population.
   */
  public count?: fhir.FhirInteger|undefined;
  /**
   * This element refers to a List of patient level MeasureReport resources, one for each patient in this population.
   */
  public patients?: fhir.Reference|undefined;
  /**
   * Default constructor for MeasureReportGroupPopulation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportGroupPopulationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code, options); }
    if (source['count'] !== undefined) { this.count = new fhir.FhirInteger({value: source.count}, options); }
    if (source['_count']) {
      if (this.count) { this.count.addExtendedProperties(source._count!); }
      else { this.count = new fhir.FhirInteger(source._count as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['patients']) { this.patients = new fhir.Reference(source.patients, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport.group.population' }
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOS('code',exp));
    iss.push(...this.vOS('count',exp));
    iss.push(...this.vOS('patients',exp));
    return iss;
  }
}
/**
 * Valid arguments for the MeasureReportGroupStratifierStratumPopulation type.
 */
export interface MeasureReportGroupStratifierStratumPopulationArgs extends fhir.BackboneElementArgs {
  /**
   * The identifier of the population being reported, as defined by the population element of the measure.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * The type of the population.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * The number of members of the population in this stratum.
   */
  count?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.group.stratifier.stratum.population.count
   */
  _count?:fhir.FhirElementArgs;
  /**
   * This element refers to a List of patient level MeasureReport resources, one for each patient in this population in this stratum.
   */
  patients?: fhir.ReferenceArgs|undefined;
}

/**
 * The populations that make up the stratum, one for each type of population appropriate to the measure.
 */
export class MeasureReportGroupStratifierStratumPopulation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReportGroupStratifierStratumPopulation';
  /**
   * The identifier of the population being reported, as defined by the population element of the measure.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The type of the population.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * The number of members of the population in this stratum.
   */
  public count?: fhir.FhirInteger|undefined;
  /**
   * This element refers to a List of patient level MeasureReport resources, one for each patient in this population in this stratum.
   */
  public patients?: fhir.Reference|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifierStratumPopulation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportGroupStratifierStratumPopulationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code, options); }
    if (source['count'] !== undefined) { this.count = new fhir.FhirInteger({value: source.count}, options); }
    if (source['_count']) {
      if (this.count) { this.count.addExtendedProperties(source._count!); }
      else { this.count = new fhir.FhirInteger(source._count as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['patients']) { this.patients = new fhir.Reference(source.patients, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport.group.stratifier.stratum.population' }
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOS('code',exp));
    iss.push(...this.vOS('count',exp));
    iss.push(...this.vOS('patients',exp));
    return iss;
  }
}
/**
 * Valid arguments for the MeasureReportGroupStratifierStratum type.
 */
export interface MeasureReportGroupStratifierStratumArgs extends fhir.BackboneElementArgs {
  /**
   * The value for this stratum, expressed as a string. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
   */
  value: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.group.stratifier.stratum.value
   */
  _value?:fhir.FhirElementArgs;
  /**
   * The populations that make up the stratum, one for each type of population appropriate to the measure.
   */
  population?: fhir.MeasureReportGroupStratifierStratumPopulationArgs[]|undefined;
  /**
   * The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
   */
  measureScore?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.group.stratifier.stratum.measureScore
   */
  _measureScore?:fhir.FhirElementArgs;
}

/**
 * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
 */
export class MeasureReportGroupStratifierStratum extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReportGroupStratifierStratum';
  /**
   * The value for this stratum, expressed as a string. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
   */
  public value: fhir.FhirString|null;
  /**
   * The populations that make up the stratum, one for each type of population appropriate to the measure.
   */
  public population: fhir.MeasureReportGroupStratifierStratumPopulation[];
  /**
   * The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
   */
  public measureScore?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifierStratum - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportGroupStratifierStratumArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['value'] !== undefined) { this.value = new fhir.FhirString({value: source.value}, options); }
    else { this.value = null; }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirString(source._value as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['population']) { this.population = source.population.map((x) => new fhir.MeasureReportGroupStratifierStratumPopulation(x, options)); }
    else { this.population = []; }
    if (source['measureScore'] !== undefined) { this.measureScore = new fhir.FhirDecimal({value: source.measureScore}, options); }
    if (source['_measureScore']) {
      if (this.measureScore) { this.measureScore.addExtendedProperties(source._measureScore!); }
      else { this.measureScore = new fhir.FhirDecimal(source._measureScore as Partial<fhir.FhirDecimalArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport.group.stratifier.stratum' }
    iss.push(...this.vRS('value',exp));
    iss.push(...this.vOA('population',exp));
    iss.push(...this.vOS('measureScore',exp));
    return iss;
  }
}
/**
 * Valid arguments for the MeasureReportGroupStratifier type.
 */
export interface MeasureReportGroupStratifierArgs extends fhir.BackboneElementArgs {
  /**
   * The identifier of this stratifier, as defined in the measure definition.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
   */
  stratum?: fhir.MeasureReportGroupStratifierStratumArgs[]|undefined;
}

/**
 * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
 */
export class MeasureReportGroupStratifier extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReportGroupStratifier';
  /**
   * The identifier of this stratifier, as defined in the measure definition.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
   */
  public stratum: fhir.MeasureReportGroupStratifierStratum[];
  /**
   * Default constructor for MeasureReportGroupStratifier - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportGroupStratifierArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['stratum']) { this.stratum = source.stratum.map((x) => new fhir.MeasureReportGroupStratifierStratum(x, options)); }
    else { this.stratum = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport.group.stratifier' }
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOA('stratum',exp));
    return iss;
  }
}
/**
 * Valid arguments for the MeasureReportGroup type.
 */
export interface MeasureReportGroupArgs extends fhir.BackboneElementArgs {
  /**
   * The identifier of the population group as defined in the measure definition.
   */
  identifier: fhir.IdentifierArgs|null;
  /**
   * The populations that make up the population group, one for each type of population appropriate for the measure.
   */
  population?: fhir.MeasureReportGroupPopulationArgs[]|undefined;
  /**
   * The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
   */
  measureScore?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.group.measureScore
   */
  _measureScore?:fhir.FhirElementArgs;
  /**
   * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
   */
  stratifier?: fhir.MeasureReportGroupStratifierArgs[]|undefined;
}

/**
 * The results of the calculation, one for each population group in the measure.
 */
export class MeasureReportGroup extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReportGroup';
  /**
   * The identifier of the population group as defined in the measure definition.
   */
  public identifier: fhir.Identifier|null;
  /**
   * The populations that make up the population group, one for each type of population appropriate for the measure.
   */
  public population: fhir.MeasureReportGroupPopulation[];
  /**
   * The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
   */
  public measureScore?: fhir.FhirDecimal|undefined;
  /**
   * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
   */
  public stratifier: fhir.MeasureReportGroupStratifier[];
  /**
   * Default constructor for MeasureReportGroup - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportGroupArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    else { this.identifier = null; }
    if (source['population']) { this.population = source.population.map((x) => new fhir.MeasureReportGroupPopulation(x, options)); }
    else { this.population = []; }
    if (source['measureScore'] !== undefined) { this.measureScore = new fhir.FhirDecimal({value: source.measureScore}, options); }
    if (source['_measureScore']) {
      if (this.measureScore) { this.measureScore.addExtendedProperties(source._measureScore!); }
      else { this.measureScore = new fhir.FhirDecimal(source._measureScore as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['stratifier']) { this.stratifier = source.stratifier.map((x) => new fhir.MeasureReportGroupStratifier(x, options)); }
    else { this.stratifier = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport.group' }
    iss.push(...this.vRS('identifier',exp));
    iss.push(...this.vOA('population',exp));
    iss.push(...this.vOS('measureScore',exp));
    iss.push(...this.vOA('stratifier',exp));
    return iss;
  }
}
/**
 * Valid arguments for the MeasureReport type.
 */
export interface MeasureReportArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "MeasureReport"|undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 v3 II data type - e.g. to identify this {{title}} outside of FHIR, where the logical URL is not possible to use.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * The report status. No data will be available until the report status is complete.
   */
  status: fhir.FhirCode<MeasureReportStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  type: fhir.FhirCode<MeasureReportTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * A reference to the Measure that was evaluated to produce this report.
   */
  measure: fhir.ReferenceArgs|null;
  /**
   * Optional Patient if the report was requested for a single patient.
   */
  patient?: fhir.ReferenceArgs|undefined;
  /**
   * The date this measure report was generated.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: MeasureReport.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Reporting Organization.
   */
  reportingOrganization?: fhir.ReferenceArgs|undefined;
  /**
   * The reporting period for which the report was calculated.
   */
  period: fhir.PeriodArgs|null;
  /**
   * The results of the calculation, one for each population group in the measure.
   */
  group?: fhir.MeasureReportGroupArgs[]|undefined;
  /**
   * A reference to a Bundle containing the Resources that were used in the evaluation of this report.
   */
  evaluatedResources?: fhir.ReferenceArgs|undefined;
}

/**
 * The MeasureReport resource contains the results of evaluating a measure.
 */
export class MeasureReport extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'MeasureReport';
  /**
   * Resource Type Name
   */
  public override resourceType: "MeasureReport";
  /**
   * Typically, this is used for identifiers that can go in an HL7 v3 II data type - e.g. to identify this {{title}} outside of FHIR, where the logical URL is not possible to use.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The report status. No data will be available until the report status is complete.
   */
  public status: fhir.FhirCode<MeasureReportStatusCodeType>|null;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  public type: fhir.FhirCode<MeasureReportTypeCodeType>|null;
  /**
   * A reference to the Measure that was evaluated to produce this report.
   */
  public measure: fhir.Reference|null;
  /**
   * Optional Patient if the report was requested for a single patient.
   */
  public patient?: fhir.Reference|undefined;
  /**
   * The date this measure report was generated.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Reporting Organization.
   */
  public reportingOrganization?: fhir.Reference|undefined;
  /**
   * The reporting period for which the report was calculated.
   */
  public period: fhir.Period|null;
  /**
   * The results of the calculation, one for each population group in the measure.
   */
  public group: fhir.MeasureReportGroup[];
  /**
   * A reference to a Bundle containing the Resources that were used in the evaluation of this report.
   */
  public evaluatedResources?: fhir.Reference|undefined;
  /**
   * Default constructor for MeasureReport - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<MeasureReportArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'MeasureReport';
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['status'] !== undefined) { this.status = new fhir.FhirCode<MeasureReportStatusCodeType>({value: source.status}, options); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<MeasureReportStatusCodeType>(source._status as Partial<fhir.FhirCode>, options); }
    }
    if (source['type'] !== undefined) { this.type = new fhir.FhirCode<MeasureReportTypeCodeType>({value: source.type}, options); }
    else { this.type = null; }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<MeasureReportTypeCodeType>(source._type as Partial<fhir.FhirCode>, options); }
    }
    if (source['measure']) { this.measure = new fhir.Reference(source.measure, options); }
    else { this.measure = null; }
    if (source['patient']) { this.patient = new fhir.Reference(source.patient, options); }
    if (source['date'] !== undefined) { this.date = new fhir.FhirDateTime({value: source.date}, options); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>, options); }
    }
    if (source['reportingOrganization']) { this.reportingOrganization = new fhir.Reference(source.reportingOrganization, options); }
    if (source['period']) { this.period = new fhir.Period(source.period, options); }
    else { this.period = null; }
    if (source['group']) { this.group = source.group.map((x) => new fhir.MeasureReportGroup(x, options)); }
    else { this.group = []; }
    if (source['evaluatedResources']) { this.evaluatedResources = new fhir.Reference(source.evaluatedResources, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'MeasureReport' }
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vRSV('status',exp,'MeasureReportStatus',MeasureReportStatusVsValidation,'r'));
    iss.push(...this.vRSV('type',exp,'MeasureReportType',MeasureReportTypeVsValidation,'r'));
    iss.push(...this.vRS('measure',exp));
    iss.push(...this.vOS('patient',exp));
    iss.push(...this.vOS('date',exp));
    iss.push(...this.vOS('reportingOrganization',exp));
    iss.push(...this.vRS('period',exp));
    iss.push(...this.vOA('group',exp));
    iss.push(...this.vOS('evaluatedResources',exp));
    return iss;
  }
}
