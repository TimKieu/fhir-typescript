// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Procedure

import * as fhir from '../fhir.js';

// @ts-ignore
import { PerformerRoleCodes,  PerformerRoleCodeType } from '../fhirValueSets/PerformerRoleCodes.js';
// @ts-ignore
import { PerformerRoleVsValidation } from '../fhirValueSets/PerformerRoleVsValidation.js';
// @ts-ignore
import { DeviceActionCodes,  DeviceActionCodeType } from '../fhirValueSets/DeviceActionCodes.js';
// @ts-ignore
import { DeviceActionVsValidation } from '../fhirValueSets/DeviceActionVsValidation.js';
// @ts-ignore
import { EventStatusCodes,  EventStatusCodeType } from '../fhirValueSets/EventStatusCodes.js';
// @ts-ignore
import { EventStatusVsValidation } from '../fhirValueSets/EventStatusVsValidation.js';
// @ts-ignore
import { ProcedureNotPerformedReasonCodes,  ProcedureNotPerformedReasonCodeType } from '../fhirValueSets/ProcedureNotPerformedReasonCodes.js';
// @ts-ignore
import { ProcedureNotPerformedReasonVsValidation } from '../fhirValueSets/ProcedureNotPerformedReasonVsValidation.js';
// @ts-ignore
import { ProcedureCategoryCodes,  ProcedureCategoryCodeType } from '../fhirValueSets/ProcedureCategoryCodes.js';
// @ts-ignore
import { ProcedureCategoryVsValidation } from '../fhirValueSets/ProcedureCategoryVsValidation.js';
// @ts-ignore
import { ProcedureCodes,  ProcedureCodeType } from '../fhirValueSets/ProcedureCodes.js';
// @ts-ignore
import { ProcedureVsValidation } from '../fhirValueSets/ProcedureVsValidation.js';
// @ts-ignore
import { ProcedureReasonCodes,  ProcedureReasonCodeType } from '../fhirValueSets/ProcedureReasonCodes.js';
// @ts-ignore
import { ProcedureReasonVsValidation } from '../fhirValueSets/ProcedureReasonVsValidation.js';
// @ts-ignore
import { BodySiteCodes,  BodySiteCodeType } from '../fhirValueSets/BodySiteCodes.js';
// @ts-ignore
import { BodySiteVsValidation } from '../fhirValueSets/BodySiteVsValidation.js';
// @ts-ignore
import { ProcedureOutcomeCodes,  ProcedureOutcomeCodeType } from '../fhirValueSets/ProcedureOutcomeCodes.js';
// @ts-ignore
import { ProcedureOutcomeVsValidation } from '../fhirValueSets/ProcedureOutcomeVsValidation.js';
// @ts-ignore
import { ConditionCodes,  ConditionCodeType } from '../fhirValueSets/ConditionCodes.js';
// @ts-ignore
import { ConditionVsValidation } from '../fhirValueSets/ConditionVsValidation.js';
// @ts-ignore
import { ProcedureFollowupCodes,  ProcedureFollowupCodeType } from '../fhirValueSets/ProcedureFollowupCodes.js';
// @ts-ignore
import { ProcedureFollowupVsValidation } from '../fhirValueSets/ProcedureFollowupVsValidation.js';
// @ts-ignore
import { DeviceKindCodes,  DeviceKindCodeType } from '../fhirValueSets/DeviceKindCodes.js';
// @ts-ignore
import { DeviceKindVsValidation } from '../fhirValueSets/DeviceKindVsValidation.js';
/**
 * Valid arguments for the ProcedurePerformer type.
 */
export interface ProcedurePerformerArgs extends fhir.BackboneElementArgs {
  /**
   * For example: surgeon, anaethetist, endoscopist.
   */
  role?: fhir.CodeableConceptArgs|undefined;
  /**
   * The practitioner who was involved in the procedure.
   */
  actor: fhir.ReferenceArgs|null;
  /**
   * The organization the device or practitioner was acting on behalf of.
   */
  onBehalfOf?: fhir.ReferenceArgs|undefined;
}

/**
 * Limited to 'real' people rather than equipment.
 */
export class ProcedurePerformer extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ProcedurePerformer';
  /**
   * For example: surgeon, anaethetist, endoscopist.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * The practitioner who was involved in the procedure.
   */
  public actor: fhir.Reference|null;
  /**
   * The organization the device or practitioner was acting on behalf of.
   */
  public onBehalfOf?: fhir.Reference|undefined;
  /**
   * Default constructor for ProcedurePerformer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ProcedurePerformerArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    if (source['actor']) { this.actor = new fhir.Reference(source.actor); }
    else { this.actor = null; }
    if (source['onBehalfOf']) { this.onBehalfOf = new fhir.Reference(source.onBehalfOf); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Procedure.performer' }
    this.vOS('role',exp)
    this.vRS('actor',exp)
    this.vOS('onBehalfOf',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ProcedureFocalDevice type.
 */
export interface ProcedureFocalDeviceArgs extends fhir.BackboneElementArgs {
  /**
   * The kind of change that happened to the device during the procedure.
   */
  action?: fhir.CodeableConceptArgs|undefined;
  /**
   * The device that was manipulated (changed) during the procedure.
   */
  manipulated: fhir.ReferenceArgs|null;
}

/**
 * A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
 */
export class ProcedureFocalDevice extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ProcedureFocalDevice';
  /**
   * The kind of change that happened to the device during the procedure.
   */
  public action?: fhir.CodeableConcept|undefined;
  /**
   * The device that was manipulated (changed) during the procedure.
   */
  public manipulated: fhir.Reference|null;
  /**
   * Default constructor for ProcedureFocalDevice - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ProcedureFocalDeviceArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['action']) { this.action = new fhir.CodeableConcept(source.action); }
    if (source['manipulated']) { this.manipulated = new fhir.Reference(source.manipulated); }
    else { this.manipulated = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Procedure.focalDevice' }
    this.vOS('action',exp)
    this.vRS('manipulated',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Procedure type.
 */
export interface ProcedureArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Procedure"|undefined;
  /**
   * This records identifiers associated with this procedure that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * A protocol, guideline, orderset or other definition that was adhered to in whole or in part by this procedure.
   */
  definition?: fhir.ReferenceArgs[]|undefined;
  /**
   * A reference to a resource that contains details of the request for this procedure.
   */
  basedOn?: fhir.ReferenceArgs[]|undefined;
  /**
   * The MedicationAdministration has a partOf reference to Procedure, but this is not a circular reference.  For a surgical procedure, the anesthesia related medicationAdministration is part of the procedure.  For an IV medication administration,  the procedure to insert the IV port is part of the medication administration.
   */
  partOf?: fhir.ReferenceArgs[]|undefined;
  /**
   * The unknown code is not to be used to convey other statuses.  The unknown code should be used when one of the statuses applies, but the authoring system doesn't know the current state of the procedure.
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  status: fhir.FhirCode<EventStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Procedure.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * If true, it means the procedure did not occur as described.  Typically it would be accompanied by attributes describing the type of activity.  It might also be accompanied by body site information or time information (i.e. no procedure was done to the left arm or no procedure was done in this 2-year period).  Specifying additional information such as performer, outcome, etc. is generally inappropriate.  For example, it's not that useful to say "There was no appendectomy done at 12:03pm June 6th by Dr. Smith with a successful outcome" as it implies that there *could* have been an appendectomy done at any other time, by any other clinician or with any other outcome.
   * This element is labeled as a modifier because it indicates that a procedure didn't happen.
   */
  notDone?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Procedure.notDone
   */
  _notDone?:fhir.FhirElementArgs;
  /**
   * A code indicating why the procedure was not performed.
   */
  notDoneReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * The person, animal or group on which the procedure was performed.
   */
  subject: fhir.ReferenceArgs|null;
  /**
   * The encounter during which the procedure was performed.
   */
  context?: fhir.ReferenceArgs|undefined;
  /**
   * The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
   */
  performed?: fhir.FhirDateTime|fhir.Period|undefined;
  /**
   * The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
   */
  performedDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
   */
  performedPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Limited to 'real' people rather than equipment.
   */
  performer?: fhir.ProcedurePerformerArgs[]|undefined;
  /**
   * The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
   */
  location?: fhir.ReferenceArgs|undefined;
  /**
   * The coded reason why the procedure was performed. This may be coded entity of some type, or may simply be present as text.
   */
  reasonCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * e.g. endoscopy for dilatation and biopsy, combination diagnosis and therapeutic.
   */
  reasonReference?: fhir.ReferenceArgs[]|undefined;
  /**
   * Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
   */
  bodySite?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * If outcome contains narrative text only, it can be captured using the CodeableConcept.text.
   */
  outcome?: fhir.CodeableConceptArgs|undefined;
  /**
   * There could potentially be multiple reports - e.g. if this was a procedure which took multiple biopsies resulting in a number of anatomical pathology reports.
   */
  report?: fhir.ReferenceArgs[]|undefined;
  /**
   * If complications are only expressed by the narrative text, they can be captured using the CodeableConcept.text.
   */
  complication?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Any complications that occurred during the procedure, or in the immediate post-performance period.
   */
  complicationDetail?: fhir.ReferenceArgs[]|undefined;
  /**
   * If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or could potentially be more complex in which case the CarePlan resource can be used.
   */
  followUp?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Any other notes about the procedure.  E.g. the operative notes.
   */
  note?: fhir.AnnotationArgs[]|undefined;
  /**
   * A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
   */
  focalDevice?: fhir.ProcedureFocalDeviceArgs[]|undefined;
  /**
   * For devices actually implanted or removed, use Procedure.device.
   */
  usedReference?: fhir.ReferenceArgs[]|undefined;
  /**
   * For devices actually implanted or removed, use Procedure.device.
   */
  usedCode?: fhir.CodeableConceptArgs[]|undefined;
}

/**
 * An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
 */
export class Procedure extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Procedure';
  /**
   * Resource Type Name
   */
  public override resourceType: "Procedure";
  /**
   * This records identifiers associated with this procedure that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
   */
  public identifier: fhir.Identifier[];
  /**
   * A protocol, guideline, orderset or other definition that was adhered to in whole or in part by this procedure.
   */
  public definition: fhir.Reference[];
  /**
   * A reference to a resource that contains details of the request for this procedure.
   */
  public basedOn: fhir.Reference[];
  /**
   * The MedicationAdministration has a partOf reference to Procedure, but this is not a circular reference.  For a surgical procedure, the anesthesia related medicationAdministration is part of the procedure.  For an IV medication administration,  the procedure to insert the IV port is part of the medication administration.
   */
  public partOf: fhir.Reference[];
  /**
   * The unknown code is not to be used to convey other statuses.  The unknown code should be used when one of the statuses applies, but the authoring system doesn't know the current state of the procedure.
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  public status: fhir.FhirCode<EventStatusCodeType>|null;
  /**
   * If true, it means the procedure did not occur as described.  Typically it would be accompanied by attributes describing the type of activity.  It might also be accompanied by body site information or time information (i.e. no procedure was done to the left arm or no procedure was done in this 2-year period).  Specifying additional information such as performer, outcome, etc. is generally inappropriate.  For example, it's not that useful to say "There was no appendectomy done at 12:03pm June 6th by Dr. Smith with a successful outcome" as it implies that there *could* have been an appendectomy done at any other time, by any other clinician or with any other outcome.
   * This element is labeled as a modifier because it indicates that a procedure didn't happen.
   */
  public notDone?: fhir.FhirBoolean|undefined;
  /**
   * A code indicating why the procedure was not performed.
   */
  public notDoneReason?: fhir.CodeableConcept|undefined;
  /**
   * A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * The person, animal or group on which the procedure was performed.
   */
  public subject: fhir.Reference|null;
  /**
   * The encounter during which the procedure was performed.
   */
  public context?: fhir.Reference|undefined;
  /**
   * The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
   */
  public performed?: (fhir.FhirDateTime|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Procedure.performed[x]
   */
  protected static readonly _fts_performedIsChoice:true = true;
  /**
   * Limited to 'real' people rather than equipment.
   */
  public performer: fhir.ProcedurePerformer[];
  /**
   * The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
   */
  public location?: fhir.Reference|undefined;
  /**
   * The coded reason why the procedure was performed. This may be coded entity of some type, or may simply be present as text.
   */
  public reasonCode: fhir.CodeableConcept[];
  /**
   * e.g. endoscopy for dilatation and biopsy, combination diagnosis and therapeutic.
   */
  public reasonReference: fhir.Reference[];
  /**
   * Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
   */
  public bodySite: fhir.CodeableConcept[];
  /**
   * If outcome contains narrative text only, it can be captured using the CodeableConcept.text.
   */
  public outcome?: fhir.CodeableConcept|undefined;
  /**
   * There could potentially be multiple reports - e.g. if this was a procedure which took multiple biopsies resulting in a number of anatomical pathology reports.
   */
  public report: fhir.Reference[];
  /**
   * If complications are only expressed by the narrative text, they can be captured using the CodeableConcept.text.
   */
  public complication: fhir.CodeableConcept[];
  /**
   * Any complications that occurred during the procedure, or in the immediate post-performance period.
   */
  public complicationDetail: fhir.Reference[];
  /**
   * If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or could potentially be more complex in which case the CarePlan resource can be used.
   */
  public followUp: fhir.CodeableConcept[];
  /**
   * Any other notes about the procedure.  E.g. the operative notes.
   */
  public note: fhir.Annotation[];
  /**
   * A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
   */
  public focalDevice: fhir.ProcedureFocalDevice[];
  /**
   * For devices actually implanted or removed, use Procedure.device.
   */
  public usedReference: fhir.Reference[];
  /**
   * For devices actually implanted or removed, use Procedure.device.
   */
  public usedCode: fhir.CodeableConcept[];
  /**
   * Default constructor for Procedure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ProcedureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Procedure';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['definition']) { this.definition = source.definition.map((x) => new fhir.Reference(x)); }
    else { this.definition = []; }
    if (source['basedOn']) { this.basedOn = source.basedOn.map((x) => new fhir.Reference(x)); }
    else { this.basedOn = []; }
    if (source['partOf']) { this.partOf = source.partOf.map((x) => new fhir.Reference(x)); }
    else { this.partOf = []; }
    if (source['status']) { this.status = new fhir.FhirCode<EventStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<EventStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['notDone']) { this.notDone = new fhir.FhirBoolean({value: source.notDone}); }
    if (source['_notDone']) {
      if (this.notDone) { this.notDone.addExtendedProperties(source._notDone!); }
      else { this.notDone = new fhir.FhirBoolean(source._notDone as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['notDoneReason']) { this.notDoneReason = new fhir.CodeableConcept(source.notDoneReason); }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['subject']) { this.subject = new fhir.Reference(source.subject); }
    else { this.subject = null; }
    if (source['context']) { this.context = new fhir.Reference(source.context); }
    if (source['performed']) { this.performed = source.performed; }
    else if (source['performedDateTime']) { this.performed = new fhir.FhirDateTime({value: source.performedDateTime}); }
    else if (source['performedPeriod']) { this.performed = new fhir.Period(source.performedPeriod); }
    if (source['performer']) { this.performer = source.performer.map((x) => new fhir.ProcedurePerformer(x)); }
    else { this.performer = []; }
    if (source['location']) { this.location = new fhir.Reference(source.location); }
    if (source['reasonCode']) { this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.reasonCode = []; }
    if (source['reasonReference']) { this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x)); }
    else { this.reasonReference = []; }
    if (source['bodySite']) { this.bodySite = source.bodySite.map((x) => new fhir.CodeableConcept(x)); }
    else { this.bodySite = []; }
    if (source['outcome']) { this.outcome = new fhir.CodeableConcept(source.outcome); }
    if (source['report']) { this.report = source.report.map((x) => new fhir.Reference(x)); }
    else { this.report = []; }
    if (source['complication']) { this.complication = source.complication.map((x) => new fhir.CodeableConcept(x)); }
    else { this.complication = []; }
    if (source['complicationDetail']) { this.complicationDetail = source.complicationDetail.map((x) => new fhir.Reference(x)); }
    else { this.complicationDetail = []; }
    if (source['followUp']) { this.followUp = source.followUp.map((x) => new fhir.CodeableConcept(x)); }
    else { this.followUp = []; }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
    if (source['focalDevice']) { this.focalDevice = source.focalDevice.map((x) => new fhir.ProcedureFocalDevice(x)); }
    else { this.focalDevice = []; }
    if (source['usedReference']) { this.usedReference = source.usedReference.map((x) => new fhir.Reference(x)); }
    else { this.usedReference = []; }
    if (source['usedCode']) { this.usedCode = source.usedCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.usedCode = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Procedure' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOA('definition',exp)
    this.vOA('basedOn',exp)
    this.vOA('partOf',exp)
    this.vRSV('status',exp,'EventStatus',EventStatusVsValidation,'r')
    this.vOS('notDone',exp)
    this.vOS('notDoneReason',exp)
    this.vOS('category',exp)
    this.vOS('code',exp)
    this.vRS('subject',exp)
    this.vOS('context',exp)
    this.vOS('performed',exp)
    this.vOA('performer',exp)
    this.vOS('location',exp)
    this.vOA('reasonCode',exp)
    this.vOA('reasonReference',exp)
    this.vOA('bodySite',exp)
    this.vOS('outcome',exp)
    this.vOA('report',exp)
    this.vOA('complication',exp)
    this.vOA('complicationDetail',exp)
    this.vOA('followUp',exp)
    this.vOA('note',exp)
    this.vOA('focalDevice',exp)
    this.vOA('usedReference',exp)
    this.vOA('usedCode',exp)
    return issues;
  }
}
