// <auto-generated/>
// Contents of: hl7.fhir.r4b.core version: 4.3.0
// Minimum TypeScript Version: 3.7
// FHIR Resource: SubscriptionStatus

import * as fhir from '../fhir.js';

// @ts-ignore
import { SubscriptionStatusCodes,  SubscriptionStatusCodeType } from '../fhirValueSets/SubscriptionStatusCodes.js';
// @ts-ignore
import { SubscriptionStatusVsValidation } from '../fhirValueSets/SubscriptionStatusVsValidation.js';
// @ts-ignore
import { SubscriptionNotificationTypeCodes,  SubscriptionNotificationTypeCodeType } from '../fhirValueSets/SubscriptionNotificationTypeCodes.js';
// @ts-ignore
import { SubscriptionNotificationTypeVsValidation } from '../fhirValueSets/SubscriptionNotificationTypeVsValidation.js';
// @ts-ignore
import { SubscriptionErrorCodes,  SubscriptionErrorCodeType } from '../fhirValueSets/SubscriptionErrorCodes.js';
// @ts-ignore
import { SubscriptionErrorVsValidation } from '../fhirValueSets/SubscriptionErrorVsValidation.js';
/**
 * Valid arguments for the SubscriptionStatusNotificationEvent type.
 */
export interface SubscriptionStatusNotificationEventArgs extends fhir.BackboneElementArgs {
  /**
   * The sequential number of this event in this subscription context. Note that this value is a 64-bit integer value, encoded as a string.
   */
  eventNumber: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.notificationEvent.eventNumber
   */
  _eventNumber?:fhir.FhirElementArgs;
  /**
   * The actual time this event occured on the server.
   */
  timestamp?: fhir.FhirInstant|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.notificationEvent.timestamp
   */
  _timestamp?:fhir.FhirElementArgs;
  /**
   * The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object.
   */
  focus?: fhir.ReferenceArgs|undefined;
  /**
   * Additional context information for this event. Generally, this will contain references to additional resources included with the event (e.g., the Patient relevant to an Encounter), however it MAY refer to non-FHIR objects.
   */
  additionalContext?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Detailed information about events relevant to this subscription notification.
 */
export class SubscriptionStatusNotificationEvent extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubscriptionStatusNotificationEvent';
  /**
   * The sequential number of this event in this subscription context. Note that this value is a 64-bit integer value, encoded as a string.
   */
  public eventNumber: fhir.FhirString|null;
  /**
   * The actual time this event occured on the server.
   */
  public timestamp?: fhir.FhirInstant|undefined;
  /**
   * The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object.
   */
  public focus?: fhir.Reference|undefined;
  /**
   * Additional context information for this event. Generally, this will contain references to additional resources included with the event (e.g., the Patient relevant to an Encounter), however it MAY refer to non-FHIR objects.
   */
  public additionalContext: fhir.Reference[];
  /**
   * Default constructor for SubscriptionStatusNotificationEvent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubscriptionStatusNotificationEventArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['eventNumber']) { this.eventNumber = new fhir.FhirString({value: source.eventNumber}); }
    else { this.eventNumber = null; }
    if (source['_eventNumber']) {
      if (this.eventNumber) { this.eventNumber.addExtendedProperties(source._eventNumber!); }
      else { this.eventNumber = new fhir.FhirString(source._eventNumber as Partial<fhir.FhirStringArgs>); }
    }
    if (source['timestamp']) { this.timestamp = new fhir.FhirInstant({value: source.timestamp}); }
    if (source['_timestamp']) {
      if (this.timestamp) { this.timestamp.addExtendedProperties(source._timestamp!); }
      else { this.timestamp = new fhir.FhirInstant(source._timestamp as Partial<fhir.FhirInstantArgs>); }
    }
    if (source['focus']) { this.focus = new fhir.Reference(source.focus); }
    if (source['additionalContext']) { this.additionalContext = source.additionalContext.map((x) => new fhir.Reference(x)); }
    else { this.additionalContext = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubscriptionStatus.notificationEvent' }
    iss.push(...this.vRS('eventNumber',exp));
    iss.push(...this.vOS('timestamp',exp));
    iss.push(...this.vOS('focus',exp));
    iss.push(...this.vOA('additionalContext',exp));
    return iss;
  }
}
/**
 * Valid arguments for the SubscriptionStatus type.
 */
export interface SubscriptionStatusArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "SubscriptionStatus"|undefined;
  /**
   * The status of the subscription, which marks the server state for managing the subscription.
   */
  status?: fhir.FhirCode<SubscriptionStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * The type of event being conveyed with this notificaiton.
   */
  type: fhir.FhirCode<SubscriptionNotificationTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
   */
  eventsSinceSubscriptionStart?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.eventsSinceSubscriptionStart
   */
  _eventsSinceSubscriptionStart?:fhir.FhirElementArgs;
  /**
   * Detailed information about events relevant to this subscription notification.
   */
  notificationEvent?: fhir.SubscriptionStatusNotificationEventArgs[]|undefined;
  /**
   * The reference to the Subscription which generated this notification.
   */
  subscription: fhir.ReferenceArgs|null;
  /**
   * This value SHOULD NOT be present when using `empty` payloads, MAY be present when using `id-only` payloads, and SHOULD be present when using `full-resource` payloads.
   */
  topic?: fhir.FhirCanonical|string|undefined;
  /**
   * Extended properties for primitive element: SubscriptionStatus.topic
   */
  _topic?:fhir.FhirElementArgs;
  /**
   * Recommended practice: clear errors when status is updated.
   */
  error?: fhir.CodeableConceptArgs[]|undefined;
}

/**
 * The SubscriptionStatus resource describes the state of a Subscription during notifications.
 */
export class SubscriptionStatus extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubscriptionStatus';
  /**
   * Resource Type Name
   */
  public override resourceType: "SubscriptionStatus";
  /**
   * The status of the subscription, which marks the server state for managing the subscription.
   */
  public status?: fhir.FhirCode<SubscriptionStatusCodeType>|undefined;
  /**
   * The type of event being conveyed with this notificaiton.
   */
  public type: fhir.FhirCode<SubscriptionNotificationTypeCodeType>|null;
  /**
   * The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
   */
  public eventsSinceSubscriptionStart?: fhir.FhirString|undefined;
  /**
   * Detailed information about events relevant to this subscription notification.
   */
  public notificationEvent: fhir.SubscriptionStatusNotificationEvent[];
  /**
   * The reference to the Subscription which generated this notification.
   */
  public subscription: fhir.Reference|null;
  /**
   * This value SHOULD NOT be present when using `empty` payloads, MAY be present when using `id-only` payloads, and SHOULD be present when using `full-resource` payloads.
   */
  public topic?: fhir.FhirCanonical|undefined;
  /**
   * Recommended practice: clear errors when status is updated.
   */
  public error: fhir.CodeableConcept[];
  /**
   * Default constructor for SubscriptionStatus - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubscriptionStatusArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'SubscriptionStatus';
    if (source['status']) { this.status = new fhir.FhirCode<SubscriptionStatusCodeType>({value: source.status}); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<SubscriptionStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['type']) { this.type = new fhir.FhirCode<SubscriptionNotificationTypeCodeType>({value: source.type}); }
    else { this.type = null; }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<SubscriptionNotificationTypeCodeType>(source._type as Partial<fhir.FhirCode>); }
    }
    if (source['eventsSinceSubscriptionStart']) { this.eventsSinceSubscriptionStart = new fhir.FhirString({value: source.eventsSinceSubscriptionStart}); }
    if (source['_eventsSinceSubscriptionStart']) {
      if (this.eventsSinceSubscriptionStart) { this.eventsSinceSubscriptionStart.addExtendedProperties(source._eventsSinceSubscriptionStart!); }
      else { this.eventsSinceSubscriptionStart = new fhir.FhirString(source._eventsSinceSubscriptionStart as Partial<fhir.FhirStringArgs>); }
    }
    if (source['notificationEvent']) { this.notificationEvent = source.notificationEvent.map((x) => new fhir.SubscriptionStatusNotificationEvent(x)); }
    else { this.notificationEvent = []; }
    if (source['subscription']) { this.subscription = new fhir.Reference(source.subscription); }
    else { this.subscription = null; }
    if (source['topic']) { this.topic = new fhir.FhirCanonical({value: source.topic}); }
    if (source['_topic']) {
      if (this.topic) { this.topic.addExtendedProperties(source._topic!); }
      else { this.topic = new fhir.FhirCanonical(source._topic as Partial<fhir.FhirCanonicalArgs>); }
    }
    if (source['error']) { this.error = source.error.map((x) => new fhir.CodeableConcept(x)); }
    else { this.error = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubscriptionStatus' }
    iss.push(...this.vRPS('resourceType',exp));
    iss.push(...this.vOSV('status',exp,'SubscriptionStatus',SubscriptionStatusVsValidation,'r'));
    iss.push(...this.vRSV('type',exp,'SubscriptionNotificationType',SubscriptionNotificationTypeVsValidation,'r'));
    iss.push(...this.vOS('eventsSinceSubscriptionStart',exp));
    iss.push(...this.vOA('notificationEvent',exp));
    iss.push(...this.vRS('subscription',exp));
    iss.push(...this.vOS('topic',exp));
    iss.push(...this.vOA('error',exp));
    return iss;
  }
}
