// <auto-generated/>
// Contents of: hl7.fhir.r4b.core version: 4.3.0
// Minimum TypeScript Version: 3.7
// FHIR Resource: SubstanceDefinition

import * as fhir from '../fhir.js';

// @ts-ignore
import { SubstanceStereochemistryCodes,  SubstanceStereochemistryCodeType } from '../fhirValueSets/SubstanceStereochemistryCodes.js';
// @ts-ignore
import { SubstanceStereochemistryVsValidation } from '../fhirValueSets/SubstanceStereochemistryVsValidation.js';
// @ts-ignore
import { SubstanceOpticalActivityCodes,  SubstanceOpticalActivityCodeType } from '../fhirValueSets/SubstanceOpticalActivityCodes.js';
// @ts-ignore
import { SubstanceOpticalActivityVsValidation } from '../fhirValueSets/SubstanceOpticalActivityVsValidation.js';
// @ts-ignore
import { SubstanceAmountTypeCodes,  SubstanceAmountTypeCodeType } from '../fhirValueSets/SubstanceAmountTypeCodes.js';
// @ts-ignore
import { SubstanceAmountTypeVsValidation } from '../fhirValueSets/SubstanceAmountTypeVsValidation.js';
// @ts-ignore
import { SubstanceWeightMethodCodes,  SubstanceWeightMethodCodeType } from '../fhirValueSets/SubstanceWeightMethodCodes.js';
// @ts-ignore
import { SubstanceWeightMethodVsValidation } from '../fhirValueSets/SubstanceWeightMethodVsValidation.js';
// @ts-ignore
import { SubstanceWeightTypeCodes,  SubstanceWeightTypeCodeType } from '../fhirValueSets/SubstanceWeightTypeCodes.js';
// @ts-ignore
import { SubstanceWeightTypeVsValidation } from '../fhirValueSets/SubstanceWeightTypeVsValidation.js';
// @ts-ignore
import { SubstanceRepresentationTypeCodes,  SubstanceRepresentationTypeCodeType } from '../fhirValueSets/SubstanceRepresentationTypeCodes.js';
// @ts-ignore
import { SubstanceRepresentationTypeVsValidation } from '../fhirValueSets/SubstanceRepresentationTypeVsValidation.js';
// @ts-ignore
import { SubstanceRepresentationFormatCodes,  SubstanceRepresentationFormatCodeType } from '../fhirValueSets/SubstanceRepresentationFormatCodes.js';
// @ts-ignore
import { SubstanceRepresentationFormatVsValidation } from '../fhirValueSets/SubstanceRepresentationFormatVsValidation.js';
// @ts-ignore
import { SubstanceStructureTechniqueCodes,  SubstanceStructureTechniqueCodeType } from '../fhirValueSets/SubstanceStructureTechniqueCodes.js';
// @ts-ignore
import { SubstanceStructureTechniqueVsValidation } from '../fhirValueSets/SubstanceStructureTechniqueVsValidation.js';
// @ts-ignore
import { PublicationStatusCodes,  PublicationStatusCodeType } from '../fhirValueSets/PublicationStatusCodes.js';
// @ts-ignore
import { PublicationStatusVsValidation } from '../fhirValueSets/PublicationStatusVsValidation.js';
// @ts-ignore
import { SubstanceNameAuthorityCodes,  SubstanceNameAuthorityCodeType } from '../fhirValueSets/SubstanceNameAuthorityCodes.js';
// @ts-ignore
import { SubstanceNameAuthorityVsValidation } from '../fhirValueSets/SubstanceNameAuthorityVsValidation.js';
// @ts-ignore
import { SubstanceNameTypeCodes,  SubstanceNameTypeCodeType } from '../fhirValueSets/SubstanceNameTypeCodes.js';
// @ts-ignore
import { SubstanceNameTypeVsValidation } from '../fhirValueSets/SubstanceNameTypeVsValidation.js';
// @ts-ignore
import { LanguagesCodes,  LanguagesCodeType } from '../fhirValueSets/LanguagesCodes.js';
// @ts-ignore
import { LanguagesVsValidation } from '../fhirValueSets/LanguagesVsValidation.js';
// @ts-ignore
import { SubstanceNameDomainCodes,  SubstanceNameDomainCodeType } from '../fhirValueSets/SubstanceNameDomainCodes.js';
// @ts-ignore
import { SubstanceNameDomainVsValidation } from '../fhirValueSets/SubstanceNameDomainVsValidation.js';
// @ts-ignore
import { JurisdictionCodes,  JurisdictionCodeType } from '../fhirValueSets/JurisdictionCodes.js';
// @ts-ignore
import { JurisdictionVsValidation } from '../fhirValueSets/JurisdictionVsValidation.js';
// @ts-ignore
import { SubstanceRelationshipTypeCodes,  SubstanceRelationshipTypeCodeType } from '../fhirValueSets/SubstanceRelationshipTypeCodes.js';
// @ts-ignore
import { SubstanceRelationshipTypeVsValidation } from '../fhirValueSets/SubstanceRelationshipTypeVsValidation.js';
// @ts-ignore
import { SubstanceSourceMaterialTypeCodes,  SubstanceSourceMaterialTypeCodeType } from '../fhirValueSets/SubstanceSourceMaterialTypeCodes.js';
// @ts-ignore
import { SubstanceSourceMaterialTypeVsValidation } from '../fhirValueSets/SubstanceSourceMaterialTypeVsValidation.js';
// @ts-ignore
import { SubstanceSourceMaterialGenusCodes,  SubstanceSourceMaterialGenusCodeType } from '../fhirValueSets/SubstanceSourceMaterialGenusCodes.js';
// @ts-ignore
import { SubstanceSourceMaterialGenusVsValidation } from '../fhirValueSets/SubstanceSourceMaterialGenusVsValidation.js';
// @ts-ignore
import { SubstanceSourceMaterialSpeciesCodes,  SubstanceSourceMaterialSpeciesCodeType } from '../fhirValueSets/SubstanceSourceMaterialSpeciesCodes.js';
// @ts-ignore
import { SubstanceSourceMaterialSpeciesVsValidation } from '../fhirValueSets/SubstanceSourceMaterialSpeciesVsValidation.js';
// @ts-ignore
import { SubstanceSourceMaterialPartCodes,  SubstanceSourceMaterialPartCodeType } from '../fhirValueSets/SubstanceSourceMaterialPartCodes.js';
// @ts-ignore
import { SubstanceSourceMaterialPartVsValidation } from '../fhirValueSets/SubstanceSourceMaterialPartVsValidation.js';
// @ts-ignore
import { CountryCodes,  CountryCodeType } from '../fhirValueSets/CountryCodes.js';
// @ts-ignore
import { CountryVsValidation } from '../fhirValueSets/CountryVsValidation.js';
// @ts-ignore
import { MedicinalProductDomainCodes,  MedicinalProductDomainCodeType } from '../fhirValueSets/MedicinalProductDomainCodes.js';
// @ts-ignore
import { MedicinalProductDomainVsValidation } from '../fhirValueSets/MedicinalProductDomainVsValidation.js';
// @ts-ignore
import { SubstanceGradeCodes,  SubstanceGradeCodeType } from '../fhirValueSets/SubstanceGradeCodes.js';
// @ts-ignore
import { SubstanceGradeVsValidation } from '../fhirValueSets/SubstanceGradeVsValidation.js';
/**
 * Valid arguments for the SubstanceDefinitionMoiety type.
 */
export interface SubstanceDefinitionMoietyArgs extends fhir.BackboneElementArgs {
  /**
   * Role that the moiety is playing.
   */
  role?: fhir.CodeableConceptArgs|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * Textual name for this moiety substance.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.moiety.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.CodeableConceptArgs|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.CodeableConceptArgs|undefined;
  /**
   * Molecular formula for this moiety of this substance, typically using the Hill system.
   */
  molecularFormula?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.moiety.molecularFormula
   */
  _molecularFormula?:fhir.FhirElementArgs;
  /**
   * Quantitative value for this moiety.
   */
  amount?: fhir.Quantity|fhir.FhirString|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amountQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amountString?: fhir.FhirString|string|undefined;
  /**
   * The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
   */
  measurementType?: fhir.CodeableConceptArgs|undefined;
}

/**
 * Moiety, for structural modifications.
 */
export class SubstanceDefinitionMoiety extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionMoiety';
  /**
   * Role that the moiety is playing.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Textual name for this moiety substance.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Molecular formula for this moiety of this substance, typically using the Hill system.
   */
  public molecularFormula?: fhir.FhirString|undefined;
  /**
   * Quantitative value for this moiety.
   */
  public amount?: (fhir.Quantity|fhir.FhirString)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceDefinition.moiety.amount[x]
   */
  protected static readonly _fts_amountIsChoice:true = true;
  /**
   * The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
   */
  public measurementType?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceDefinitionMoiety - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionMoietyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['stereochemistry']) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry); }
    if (source['opticalActivity']) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity); }
    if (source['molecularFormula']) { this.molecularFormula = new fhir.FhirString({value: source.molecularFormula}); }
    if (source['_molecularFormula']) {
      if (this.molecularFormula) { this.molecularFormula.addExtendedProperties(source._molecularFormula!); }
      else { this.molecularFormula = new fhir.FhirString(source._molecularFormula as Partial<fhir.FhirStringArgs>); }
    }
    if (source['amount']) { this.amount = source.amount; }
    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }
    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }
    if (source['measurementType']) { this.measurementType = new fhir.CodeableConcept(source.measurementType); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.moiety' }
    this.vOS('role',exp)
    this.vOS('identifier',exp)
    this.vOS('name',exp)
    this.vOS('stereochemistry',exp)
    this.vOS('opticalActivity',exp)
    this.vOS('molecularFormula',exp)
    this.vOS('amount',exp)
    this.vOS('measurementType',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionProperty type.
 */
export interface SubstanceDefinitionPropertyArgs extends fhir.BackboneElementArgs {
  /**
   * A code expressing the type of property.
   */
  type: fhir.CodeableConceptArgs|null;
  /**
   * A value for the property.
   */
  value?: fhir.CodeableConcept|fhir.Quantity|fhir.FhirDate|fhir.FhirBoolean|fhir.Attachment|undefined;
  /**
   * A value for the property.
   */
  valueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * A value for the property.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * A value for the property.
   */
  valueDate?: fhir.FhirDate|string|undefined;
  /**
   * A value for the property.
   */
  valueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * A value for the property.
   */
  valueAttachment?: fhir.AttachmentArgs|undefined;
}

/**
 * General specifications for this substance.
 */
export class SubstanceDefinitionProperty extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionProperty';
  /**
   * A code expressing the type of property.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * A value for the property.
   */
  public value?: (fhir.CodeableConcept|fhir.Quantity|fhir.FhirDate|fhir.FhirBoolean|fhir.Attachment)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceDefinition.property.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * Default constructor for SubstanceDefinitionProperty - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionPropertyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    else { this.type = null; }
    if (source['value']) { this.value = source.value; }
    else if (source['valueCodeableConcept']) { this.value = new fhir.CodeableConcept(source.valueCodeableConcept); }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueDate']) { this.value = new fhir.FhirDate({value: source.valueDate}); }
    else if (source['valueBoolean']) { this.value = new fhir.FhirBoolean({value: source.valueBoolean}); }
    else if (source['valueAttachment']) { this.value = new fhir.Attachment(source.valueAttachment); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.property' }
    this.vRS('type',exp)
    this.vOS('value',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionMolecularWeight type.
 */
export interface SubstanceDefinitionMolecularWeightArgs extends fhir.BackboneElementArgs {
  /**
   * The method by which the molecular weight was determined.
   */
  method?: fhir.CodeableConceptArgs|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  amount: fhir.QuantityArgs|null;
}

/**
 * The molecular weight or weight range (for proteins, polymers or nucleic acids).
 */
export class SubstanceDefinitionMolecularWeight extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionMolecularWeight';
  /**
   * The method by which the molecular weight was determined.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  public amount: fhir.Quantity|null;
  /**
   * Default constructor for SubstanceDefinitionMolecularWeight - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionMolecularWeightArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['method']) { this.method = new fhir.CodeableConcept(source.method); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    else { this.amount = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.molecularWeight' }
    this.vOS('method',exp)
    this.vOS('type',exp)
    this.vRS('amount',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionStructureRepresentation type.
 */
export interface SubstanceDefinitionStructureRepresentationArgs extends fhir.BackboneElementArgs {
  /**
   * The kind of structural representation (e.g. full, partial).
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The structural representation or characterization as a text string in a standard format.
   */
  representation?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.structure.representation.representation
   */
  _representation?:fhir.FhirElementArgs;
  /**
   * The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
   */
  format?: fhir.CodeableConceptArgs|undefined;
  /**
   * An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
   */
  document?: fhir.ReferenceArgs|undefined;
}

/**
 * A depiction of the structure or characterization of the substance.
 */
export class SubstanceDefinitionStructureRepresentation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionStructureRepresentation';
  /**
   * The kind of structural representation (e.g. full, partial).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The structural representation or characterization as a text string in a standard format.
   */
  public representation?: fhir.FhirString|undefined;
  /**
   * The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
   */
  public format?: fhir.CodeableConcept|undefined;
  /**
   * An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
   */
  public document?: fhir.Reference|undefined;
  /**
   * Default constructor for SubstanceDefinitionStructureRepresentation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionStructureRepresentationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['representation']) { this.representation = new fhir.FhirString({value: source.representation}); }
    if (source['_representation']) {
      if (this.representation) { this.representation.addExtendedProperties(source._representation!); }
      else { this.representation = new fhir.FhirString(source._representation as Partial<fhir.FhirStringArgs>); }
    }
    if (source['format']) { this.format = new fhir.CodeableConcept(source.format); }
    if (source['document']) { this.document = new fhir.Reference(source.document); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.structure.representation' }
    this.vOS('type',exp)
    this.vOS('representation',exp)
    this.vOS('format',exp)
    this.vOS('document',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionStructure type.
 */
export interface SubstanceDefinitionStructureArgs extends fhir.BackboneElementArgs {
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.CodeableConceptArgs|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.CodeableConceptArgs|undefined;
  /**
   * Molecular formula of this substance, typically using the Hill system.
   */
  molecularFormula?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.structure.molecularFormula
   */
  _molecularFormula?:fhir.FhirElementArgs;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  molecularFormulaByMoiety?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.structure.molecularFormulaByMoiety
   */
  _molecularFormulaByMoiety?:fhir.FhirElementArgs;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.SubstanceDefinitionMolecularWeightArgs|undefined;
  /**
   * The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.
   */
  technique?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The source of information about the structure.
   */
  sourceDocument?: fhir.ReferenceArgs[]|undefined;
  /**
   * A depiction of the structure or characterization of the substance.
   */
  representation?: fhir.SubstanceDefinitionStructureRepresentationArgs[]|undefined;
}

/**
 * Structural information.
 */
export class SubstanceDefinitionStructure extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionStructure';
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Molecular formula of this substance, typically using the Hill system.
   */
  public molecularFormula?: fhir.FhirString|undefined;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  public molecularFormulaByMoiety?: fhir.FhirString|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceDefinitionMolecularWeight|undefined;
  /**
   * The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.
   */
  public technique: fhir.CodeableConcept[];
  /**
   * The source of information about the structure.
   */
  public sourceDocument: fhir.Reference[];
  /**
   * A depiction of the structure or characterization of the substance.
   */
  public representation: fhir.SubstanceDefinitionStructureRepresentation[];
  /**
   * Default constructor for SubstanceDefinitionStructure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionStructureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['stereochemistry']) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry); }
    if (source['opticalActivity']) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity); }
    if (source['molecularFormula']) { this.molecularFormula = new fhir.FhirString({value: source.molecularFormula}); }
    if (source['_molecularFormula']) {
      if (this.molecularFormula) { this.molecularFormula.addExtendedProperties(source._molecularFormula!); }
      else { this.molecularFormula = new fhir.FhirString(source._molecularFormula as Partial<fhir.FhirStringArgs>); }
    }
    if (source['molecularFormulaByMoiety']) { this.molecularFormulaByMoiety = new fhir.FhirString({value: source.molecularFormulaByMoiety}); }
    if (source['_molecularFormulaByMoiety']) {
      if (this.molecularFormulaByMoiety) { this.molecularFormulaByMoiety.addExtendedProperties(source._molecularFormulaByMoiety!); }
      else { this.molecularFormulaByMoiety = new fhir.FhirString(source._molecularFormulaByMoiety as Partial<fhir.FhirStringArgs>); }
    }
    if (source['molecularWeight']) { this.molecularWeight = new fhir.SubstanceDefinitionMolecularWeight(source.molecularWeight); }
    if (source['technique']) { this.technique = source.technique.map((x) => new fhir.CodeableConcept(x)); }
    else { this.technique = []; }
    if (source['sourceDocument']) { this.sourceDocument = source.sourceDocument.map((x) => new fhir.Reference(x)); }
    else { this.sourceDocument = []; }
    if (source['representation']) { this.representation = source.representation.map((x) => new fhir.SubstanceDefinitionStructureRepresentation(x)); }
    else { this.representation = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.structure' }
    this.vOS('stereochemistry',exp)
    this.vOS('opticalActivity',exp)
    this.vOS('molecularFormula',exp)
    this.vOS('molecularFormulaByMoiety',exp)
    this.vOS('molecularWeight',exp)
    this.vOA('technique',exp)
    this.vOA('sourceDocument',exp)
    this.vOA('representation',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionCode type.
 */
export interface SubstanceDefinitionCodeArgs extends fhir.BackboneElementArgs {
  /**
   * The specific code.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * Status of the code assignment, for example 'provisional', 'approved'.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * The date at which the code status was changed as part of the terminology maintenance.
   */
  statusDate?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.code.statusDate
   */
  _statusDate?:fhir.FhirElementArgs;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  note?: fhir.AnnotationArgs[]|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Codes associated with the substance.
 */
export class SubstanceDefinitionCode extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionCode';
  /**
   * The specific code.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Status of the code assignment, for example 'provisional', 'approved'.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * The date at which the code status was changed as part of the terminology maintenance.
   */
  public statusDate?: fhir.FhirDateTime|undefined;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  public note: fhir.Annotation[];
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceDefinitionCode - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionCodeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['statusDate']) { this.statusDate = new fhir.FhirDateTime({value: source.statusDate}); }
    if (source['_statusDate']) {
      if (this.statusDate) { this.statusDate.addExtendedProperties(source._statusDate!); }
      else { this.statusDate = new fhir.FhirDateTime(source._statusDate as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.code' }
    this.vOS('code',exp)
    this.vOS('status',exp)
    this.vOS('statusDate',exp)
    this.vOA('note',exp)
    this.vOA('source',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionNameOfficial type.
 */
export interface SubstanceDefinitionNameOfficialArgs extends fhir.BackboneElementArgs {
  /**
   * Which authority uses this official name.
   */
  authority?: fhir.CodeableConceptArgs|undefined;
  /**
   * The status of the official name, for example 'draft', 'active', 'retired'.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * Date of the official name change.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.name.official.date
   */
  _date?:fhir.FhirElementArgs;
}

/**
 * Details of the official nature of this name.
 */
export class SubstanceDefinitionNameOfficial extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionNameOfficial';
  /**
   * Which authority uses this official name.
   */
  public authority?: fhir.CodeableConcept|undefined;
  /**
   * The status of the official name, for example 'draft', 'active', 'retired'.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * Date of the official name change.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Default constructor for SubstanceDefinitionNameOfficial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionNameOfficialArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['authority']) { this.authority = new fhir.CodeableConcept(source.authority); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.name.official' }
    this.vOS('authority',exp)
    this.vOS('status',exp)
    this.vOS('date',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionName type.
 */
export interface SubstanceDefinitionNameArgs extends fhir.BackboneElementArgs {
  /**
   * The actual name.
   */
  name: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.name.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Name type, for example 'systematic',  'scientific, 'brand'.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The status of the name, for example 'current', 'proposed'.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  preferred?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.name.preferred
   */
  _preferred?:fhir.FhirElementArgs;
  /**
   * Human language that the name is written in.
   */
  language?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  domain?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The jurisdiction where this name applies.
   */
  jurisdiction?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * A synonym of this particular name, by which the substance is also known.
   */
  synonym?: fhir.SubstanceDefinitionNameArgs[]|undefined;
  /**
   * A translation for this name into another human language.
   */
  translation?: fhir.SubstanceDefinitionNameArgs[]|undefined;
  /**
   * Details of the official nature of this name.
   */
  official?: fhir.SubstanceDefinitionNameOfficialArgs[]|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Names applicable to this substance.
 */
export class SubstanceDefinitionName extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionName';
  /**
   * The actual name.
   */
  public name: fhir.FhirString|null;
  /**
   * Name type, for example 'systematic',  'scientific, 'brand'.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The status of the name, for example 'current', 'proposed'.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  public preferred?: fhir.FhirBoolean|undefined;
  /**
   * Human language that the name is written in.
   */
  public language: fhir.CodeableConcept[];
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  public domain: fhir.CodeableConcept[];
  /**
   * The jurisdiction where this name applies.
   */
  public jurisdiction: fhir.CodeableConcept[];
  /**
   * A synonym of this particular name, by which the substance is also known.
   */
  public synonym: fhir.SubstanceDefinitionName[];
  /**
   * A translation for this name into another human language.
   */
  public translation: fhir.SubstanceDefinitionName[];
  /**
   * Details of the official nature of this name.
   */
  public official: fhir.SubstanceDefinitionNameOfficial[];
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceDefinitionName - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionNameArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    else { this.name = null; }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['preferred']) { this.preferred = new fhir.FhirBoolean({value: source.preferred}); }
    if (source['_preferred']) {
      if (this.preferred) { this.preferred.addExtendedProperties(source._preferred!); }
      else { this.preferred = new fhir.FhirBoolean(source._preferred as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['language']) { this.language = source.language.map((x) => new fhir.CodeableConcept(x)); }
    else { this.language = []; }
    if (source['domain']) { this.domain = source.domain.map((x) => new fhir.CodeableConcept(x)); }
    else { this.domain = []; }
    if (source['jurisdiction']) { this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x)); }
    else { this.jurisdiction = []; }
    if (source['synonym']) { this.synonym = source.synonym.map((x) => new fhir.SubstanceDefinitionName(x)); }
    else { this.synonym = []; }
    if (source['translation']) { this.translation = source.translation.map((x) => new fhir.SubstanceDefinitionName(x)); }
    else { this.translation = []; }
    if (source['official']) { this.official = source.official.map((x) => new fhir.SubstanceDefinitionNameOfficial(x)); }
    else { this.official = []; }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.name' }
    this.vRS('name',exp)
    this.vOS('type',exp)
    this.vOS('status',exp)
    this.vOS('preferred',exp)
    this.vOA('language',exp)
    this.vOA('domain',exp)
    this.vOA('jurisdiction',exp)
    this.vOA('synonym',exp)
    this.vOA('translation',exp)
    this.vOA('official',exp)
    this.vOA('source',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionRelationship type.
 */
export interface SubstanceDefinitionRelationshipArgs extends fhir.BackboneElementArgs {
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceDefinition?: fhir.Reference|fhir.CodeableConcept|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceDefinitionReference?: fhir.ReferenceArgs|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceDefinitionCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
   */
  type: fhir.CodeableConceptArgs|null;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  isDefining?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.relationship.isDefining
   */
  _isDefining?:fhir.FhirElementArgs;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amount?: fhir.Quantity|fhir.Ratio|fhir.FhirString|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountQuantity?: fhir.QuantityArgs|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRatio?: fhir.RatioArgs|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountString?: fhir.FhirString|string|undefined;
  /**
   * For use when the numeric has an uncertain range.
   */
  ratioHighLimitAmount?: fhir.RatioArgs|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  comparator?: fhir.CodeableConceptArgs|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * A link between this substance and another, with details of the relationship.
 */
export class SubstanceDefinitionRelationship extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionRelationship';
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  public substanceDefinition?: (fhir.Reference|fhir.CodeableConcept)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceDefinition.relationship.substanceDefinition[x]
   */
  protected static readonly _fts_substanceDefinitionIsChoice:true = true;
  /**
   * For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
   */
  public type: fhir.CodeableConcept|null;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  public isDefining?: fhir.FhirBoolean|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amount?: (fhir.Quantity|fhir.Ratio|fhir.FhirString)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceDefinition.relationship.amount[x]
   */
  protected static readonly _fts_amountIsChoice:true = true;
  /**
   * For use when the numeric has an uncertain range.
   */
  public ratioHighLimitAmount?: fhir.Ratio|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  public comparator?: fhir.CodeableConcept|undefined;
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceDefinitionRelationship - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionRelationshipArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['substanceDefinition']) { this.substanceDefinition = source.substanceDefinition; }
    else if (source['substanceDefinitionReference']) { this.substanceDefinition = new fhir.Reference(source.substanceDefinitionReference); }
    else if (source['substanceDefinitionCodeableConcept']) { this.substanceDefinition = new fhir.CodeableConcept(source.substanceDefinitionCodeableConcept); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    else { this.type = null; }
    if (source['isDefining']) { this.isDefining = new fhir.FhirBoolean({value: source.isDefining}); }
    if (source['_isDefining']) {
      if (this.isDefining) { this.isDefining.addExtendedProperties(source._isDefining!); }
      else { this.isDefining = new fhir.FhirBoolean(source._isDefining as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['amount']) { this.amount = source.amount; }
    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }
    else if (source['amountRatio']) { this.amount = new fhir.Ratio(source.amountRatio); }
    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }
    if (source['ratioHighLimitAmount']) { this.ratioHighLimitAmount = new fhir.Ratio(source.ratioHighLimitAmount); }
    if (source['comparator']) { this.comparator = new fhir.CodeableConcept(source.comparator); }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.relationship' }
    this.vOS('substanceDefinition',exp)
    this.vRS('type',exp)
    this.vOS('isDefining',exp)
    this.vOS('amount',exp)
    this.vOS('ratioHighLimitAmount',exp)
    this.vOS('comparator',exp)
    this.vOA('source',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinitionSourceMaterial type.
 */
export interface SubstanceDefinitionSourceMaterialArgs extends fhir.BackboneElementArgs {
  /**
   * A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
   */
  genus?: fhir.CodeableConceptArgs|undefined;
  /**
   * The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
   */
  species?: fhir.CodeableConceptArgs|undefined;
  /**
   * An anatomical origin of the source material within an organism.
   */
  part?: fhir.CodeableConceptArgs|undefined;
  /**
   * The country or countries where the material is harvested.
   */
  countryOfOrigin?: fhir.CodeableConceptArgs[]|undefined;
}

/**
 * Material or taxonomic/anatomical source for the substance.
 */
export class SubstanceDefinitionSourceMaterial extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinitionSourceMaterial';
  /**
   * A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
   */
  public genus?: fhir.CodeableConcept|undefined;
  /**
   * The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
   */
  public species?: fhir.CodeableConcept|undefined;
  /**
   * An anatomical origin of the source material within an organism.
   */
  public part?: fhir.CodeableConcept|undefined;
  /**
   * The country or countries where the material is harvested.
   */
  public countryOfOrigin: fhir.CodeableConcept[];
  /**
   * Default constructor for SubstanceDefinitionSourceMaterial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionSourceMaterialArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['genus']) { this.genus = new fhir.CodeableConcept(source.genus); }
    if (source['species']) { this.species = new fhir.CodeableConcept(source.species); }
    if (source['part']) { this.part = new fhir.CodeableConcept(source.part); }
    if (source['countryOfOrigin']) { this.countryOfOrigin = source.countryOfOrigin.map((x) => new fhir.CodeableConcept(x)); }
    else { this.countryOfOrigin = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition.sourceMaterial' }
    this.vOS('type',exp)
    this.vOS('genus',exp)
    this.vOS('species',exp)
    this.vOS('part',exp)
    this.vOAV('countryOfOrigin',exp,'Country',CountryVsValidation,'r')
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceDefinition type.
 */
export interface SubstanceDefinitionArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "SubstanceDefinition"|undefined;
  /**
   * Identifier by which this substance is known.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * A business level version identifier of the substance.
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * Status of substance within the catalogue e.g. active, retired.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
   */
  classification?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * If the substance applies to human or veterinary use.
   */
  domain?: fhir.CodeableConceptArgs|undefined;
  /**
   * The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
   */
  grade?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Textual description of the substance.
   */
  description?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: SubstanceDefinition.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Supporting literature.
   */
  informationSource?: fhir.ReferenceArgs[]|undefined;
  /**
   * Textual comment about the substance's catalogue or registry record.
   */
  note?: fhir.AnnotationArgs[]|undefined;
  /**
   * The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
   */
  manufacturer?: fhir.ReferenceArgs[]|undefined;
  /**
   * An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
   */
  supplier?: fhir.ReferenceArgs[]|undefined;
  /**
   * Moiety, for structural modifications.
   */
  moiety?: fhir.SubstanceDefinitionMoietyArgs[]|undefined;
  /**
   * General specifications for this substance.
   */
  property?: fhir.SubstanceDefinitionPropertyArgs[]|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.SubstanceDefinitionMolecularWeightArgs[]|undefined;
  /**
   * Structural information.
   */
  structure?: fhir.SubstanceDefinitionStructureArgs|undefined;
  /**
   * Codes associated with the substance.
   */
  code?: fhir.SubstanceDefinitionCodeArgs[]|undefined;
  /**
   * Names applicable to this substance.
   */
  name?: fhir.SubstanceDefinitionNameArgs[]|undefined;
  /**
   * A link between this substance and another, with details of the relationship.
   */
  relationship?: fhir.SubstanceDefinitionRelationshipArgs[]|undefined;
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  sourceMaterial?: fhir.SubstanceDefinitionSourceMaterialArgs|undefined;
}

/**
 * The detailed description of a substance, typically at a level beyond what is used for prescribing.
 */
export class SubstanceDefinition extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceDefinition';
  /**
   * Resource Type Name
   */
  public override resourceType: "SubstanceDefinition";
  /**
   * Identifier by which this substance is known.
   */
  public identifier: fhir.Identifier[];
  /**
   * A business level version identifier of the substance.
   */
  public version?: fhir.FhirString|undefined;
  /**
   * Status of substance within the catalogue e.g. active, retired.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
   */
  public classification: fhir.CodeableConcept[];
  /**
   * If the substance applies to human or veterinary use.
   */
  public domain?: fhir.CodeableConcept|undefined;
  /**
   * The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
   */
  public grade: fhir.CodeableConcept[];
  /**
   * Textual description of the substance.
   */
  public description?: fhir.FhirMarkdown|undefined;
  /**
   * Supporting literature.
   */
  public informationSource: fhir.Reference[];
  /**
   * Textual comment about the substance's catalogue or registry record.
   */
  public note: fhir.Annotation[];
  /**
   * The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
   */
  public manufacturer: fhir.Reference[];
  /**
   * An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
   */
  public supplier: fhir.Reference[];
  /**
   * Moiety, for structural modifications.
   */
  public moiety: fhir.SubstanceDefinitionMoiety[];
  /**
   * General specifications for this substance.
   */
  public property: fhir.SubstanceDefinitionProperty[];
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight: fhir.SubstanceDefinitionMolecularWeight[];
  /**
   * Structural information.
   */
  public structure?: fhir.SubstanceDefinitionStructure|undefined;
  /**
   * Codes associated with the substance.
   */
  public code: fhir.SubstanceDefinitionCode[];
  /**
   * Names applicable to this substance.
   */
  public name: fhir.SubstanceDefinitionName[];
  /**
   * A link between this substance and another, with details of the relationship.
   */
  public relationship: fhir.SubstanceDefinitionRelationship[];
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  public sourceMaterial?: fhir.SubstanceDefinitionSourceMaterial|undefined;
  /**
   * Default constructor for SubstanceDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceDefinitionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'SubstanceDefinition';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['version']) { this.version = new fhir.FhirString({value: source.version}); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>); }
    }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['classification']) { this.classification = source.classification.map((x) => new fhir.CodeableConcept(x)); }
    else { this.classification = []; }
    if (source['domain']) { this.domain = new fhir.CodeableConcept(source.domain); }
    if (source['grade']) { this.grade = source.grade.map((x) => new fhir.CodeableConcept(x)); }
    else { this.grade = []; }
    if (source['description']) { this.description = new fhir.FhirMarkdown({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirMarkdown(source._description as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['informationSource']) { this.informationSource = source.informationSource.map((x) => new fhir.Reference(x)); }
    else { this.informationSource = []; }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
    if (source['manufacturer']) { this.manufacturer = source.manufacturer.map((x) => new fhir.Reference(x)); }
    else { this.manufacturer = []; }
    if (source['supplier']) { this.supplier = source.supplier.map((x) => new fhir.Reference(x)); }
    else { this.supplier = []; }
    if (source['moiety']) { this.moiety = source.moiety.map((x) => new fhir.SubstanceDefinitionMoiety(x)); }
    else { this.moiety = []; }
    if (source['property']) { this.property = source.property.map((x) => new fhir.SubstanceDefinitionProperty(x)); }
    else { this.property = []; }
    if (source['molecularWeight']) { this.molecularWeight = source.molecularWeight.map((x) => new fhir.SubstanceDefinitionMolecularWeight(x)); }
    else { this.molecularWeight = []; }
    if (source['structure']) { this.structure = new fhir.SubstanceDefinitionStructure(source.structure); }
    if (source['code']) { this.code = source.code.map((x) => new fhir.SubstanceDefinitionCode(x)); }
    else { this.code = []; }
    if (source['name']) { this.name = source.name.map((x) => new fhir.SubstanceDefinitionName(x)); }
    else { this.name = []; }
    if (source['relationship']) { this.relationship = source.relationship.map((x) => new fhir.SubstanceDefinitionRelationship(x)); }
    else { this.relationship = []; }
    if (source['sourceMaterial']) { this.sourceMaterial = new fhir.SubstanceDefinitionSourceMaterial(source.sourceMaterial); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'SubstanceDefinition' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOS('version',exp)
    this.vOS('status',exp)
    this.vOA('classification',exp)
    this.vOS('domain',exp)
    this.vOA('grade',exp)
    this.vOS('description',exp)
    this.vOA('informationSource',exp)
    this.vOA('note',exp)
    this.vOA('manufacturer',exp)
    this.vOA('supplier',exp)
    this.vOA('moiety',exp)
    this.vOA('property',exp)
    this.vOA('molecularWeight',exp)
    this.vOS('structure',exp)
    this.vOA('code',exp)
    this.vOA('name',exp)
    this.vOA('relationship',exp)
    this.vOS('sourceMaterial',exp)
    return issues;
  }
}
