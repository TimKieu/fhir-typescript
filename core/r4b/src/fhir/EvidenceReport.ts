// <auto-generated/>
// Contents of: hl7.fhir.r4b.core version: 4.3.0
// Minimum TypeScript Version: 3.7
// FHIR Resource: EvidenceReport

import * as fhir from '../fhir.js';

// @ts-ignore
import { FocusCharacteristicCodes,  FocusCharacteristicCodeType } from '../fhirValueSets/FocusCharacteristicCodes.js';
// @ts-ignore
import { FocusCharacteristicVsValidation } from '../fhirValueSets/FocusCharacteristicVsValidation.js';
// @ts-ignore
import { ReportRelationTypeCodes,  ReportRelationTypeCodeType } from '../fhirValueSets/ReportRelationTypeCodes.js';
// @ts-ignore
import { ReportRelationTypeVsValidation } from '../fhirValueSets/ReportRelationTypeVsValidation.js';
// @ts-ignore
import { EvidenceReportSectionCodes,  EvidenceReportSectionCodeType } from '../fhirValueSets/EvidenceReportSectionCodes.js';
// @ts-ignore
import { EvidenceReportSectionVsValidation } from '../fhirValueSets/EvidenceReportSectionVsValidation.js';
// @ts-ignore
import { ListModeCodes,  ListModeCodeType } from '../fhirValueSets/ListModeCodes.js';
// @ts-ignore
import { ListModeVsValidation } from '../fhirValueSets/ListModeVsValidation.js';
// @ts-ignore
import { ListOrderCodes,  ListOrderCodeType } from '../fhirValueSets/ListOrderCodes.js';
// @ts-ignore
import { ListOrderVsValidation } from '../fhirValueSets/ListOrderVsValidation.js';
// @ts-ignore
import { EvidenceClassifierCodes,  EvidenceClassifierCodeType } from '../fhirValueSets/EvidenceClassifierCodes.js';
// @ts-ignore
import { EvidenceClassifierVsValidation } from '../fhirValueSets/EvidenceClassifierVsValidation.js';
// @ts-ignore
import { ListEmptyReasonCodes,  ListEmptyReasonCodeType } from '../fhirValueSets/ListEmptyReasonCodes.js';
// @ts-ignore
import { ListEmptyReasonVsValidation } from '../fhirValueSets/ListEmptyReasonVsValidation.js';
// @ts-ignore
import { PublicationStatusCodes,  PublicationStatusCodeType } from '../fhirValueSets/PublicationStatusCodes.js';
// @ts-ignore
import { PublicationStatusVsValidation } from '../fhirValueSets/PublicationStatusVsValidation.js';
// @ts-ignore
import { EvidenceReportTypeCodes,  EvidenceReportTypeCodeType } from '../fhirValueSets/EvidenceReportTypeCodes.js';
// @ts-ignore
import { EvidenceReportTypeVsValidation } from '../fhirValueSets/EvidenceReportTypeVsValidation.js';
/**
 * Valid arguments for the EvidenceReportSubjectCharacteristic type.
 */
export interface EvidenceReportSubjectCharacteristicArgs extends fhir.BackboneElementArgs {
  /**
   * Example 1 is a Citation. Example 2 is a type of outcome. Example 3 is a specific outcome.
   */
  code: fhir.CodeableConceptArgs|null;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  value?: fhir.Reference|fhir.CodeableConcept|fhir.FhirBoolean|fhir.Quantity|fhir.Range|undefined;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  valueReference?: fhir.ReferenceArgs|undefined;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  valueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  valueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  valueRange?: fhir.RangeArgs|undefined;
  /**
   * Is used to express not the characteristic.
   */
  exclude?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.subject.characteristic.exclude
   */
  _exclude?:fhir.FhirElementArgs;
  /**
   * Timeframe for the characteristic.
   */
  period?: fhir.PeriodArgs|undefined;
}

/**
 * Characteristic.
 */
export class EvidenceReportSubjectCharacteristic extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EvidenceReportSubjectCharacteristic';
  /**
   * Example 1 is a Citation. Example 2 is a type of outcome. Example 3 is a specific outcome.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
   */
  public value: (fhir.Reference|fhir.CodeableConcept|fhir.FhirBoolean|fhir.Quantity|fhir.Range)|null;
  /**
   * Internal flag to properly serialize choice-type element EvidenceReport.subject.characteristic.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * Is used to express not the characteristic.
   */
  public exclude?: fhir.FhirBoolean|undefined;
  /**
   * Timeframe for the characteristic.
   */
  public period?: fhir.Period|undefined;
  /**
   * Default constructor for EvidenceReportSubjectCharacteristic - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EvidenceReportSubjectCharacteristicArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
    if (source['value']) { this.value = source.value; }
    else if (source['valueReference']) { this.value = new fhir.Reference(source.valueReference); }
    else if (source['valueCodeableConcept']) { this.value = new fhir.CodeableConcept(source.valueCodeableConcept); }
    else if (source['valueBoolean']) { this.value = new fhir.FhirBoolean({value: source.valueBoolean}); }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueRange']) { this.value = new fhir.Range(source.valueRange); }
    else { this.value = null; }
    if (source['exclude']) { this.exclude = new fhir.FhirBoolean({value: source.exclude}); }
    if (source['_exclude']) {
      if (this.exclude) { this.exclude.addExtendedProperties(source._exclude!); }
      else { this.exclude = new fhir.FhirBoolean(source._exclude as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['period']) { this.period = new fhir.Period(source.period); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EvidenceReport.subject.characteristic' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vRS('value',exp));
    iss.push(...this.vOS('exclude',exp));
    iss.push(...this.vOS('period',exp));
    return iss;
  }
}
/**
 * Valid arguments for the EvidenceReportSubject type.
 */
export interface EvidenceReportSubjectArgs extends fhir.BackboneElementArgs {
  /**
   * Characteristic.
   */
  characteristic?: fhir.EvidenceReportSubjectCharacteristicArgs[]|undefined;
  /**
   * Used for general notes and annotations not coded elsewhere.
   */
  note?: fhir.AnnotationArgs[]|undefined;
}

/**
 * May be used as an expression for search queries and search results
 */
export class EvidenceReportSubject extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EvidenceReportSubject';
  /**
   * Characteristic.
   */
  public characteristic: fhir.EvidenceReportSubjectCharacteristic[];
  /**
   * Used for general notes and annotations not coded elsewhere.
   */
  public note: fhir.Annotation[];
  /**
   * Default constructor for EvidenceReportSubject - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EvidenceReportSubjectArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['characteristic']) { this.characteristic = source.characteristic.map((x) => new fhir.EvidenceReportSubjectCharacteristic(x)); }
    else { this.characteristic = []; }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EvidenceReport.subject' }
    iss.push(...this.vOA('characteristic',exp));
    iss.push(...this.vOA('note',exp));
    return iss;
  }
}
/**
 * Valid arguments for the EvidenceReportRelatesTo type.
 */
export interface EvidenceReportRelatesToArgs extends fhir.BackboneElementArgs {
  /**
   * If this document appends another document, then the document cannot be fully understood without also accessing the referenced document.
   */
  code: fhir.FhirCode<ReportRelationTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.relatesTo.code
   */
  _code?:fhir.FhirElementArgs;
  /**
   * The target composition/document of this relationship.
   */
  target?: fhir.Identifier|fhir.Reference|undefined;
  /**
   * The target composition/document of this relationship.
   */
  targetIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * The target composition/document of this relationship.
   */
  targetReference?: fhir.ReferenceArgs|undefined;
}

/**
 * A document is a version specific composition.
 */
export class EvidenceReportRelatesTo extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EvidenceReportRelatesTo';
  /**
   * If this document appends another document, then the document cannot be fully understood without also accessing the referenced document.
   */
  public code: fhir.FhirCode<ReportRelationTypeCodeType>|null;
  /**
   * The target composition/document of this relationship.
   */
  public target: (fhir.Identifier|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element EvidenceReport.relatesTo.target[x]
   */
  protected static readonly _fts_targetIsChoice:true = true;
  /**
   * Default constructor for EvidenceReportRelatesTo - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EvidenceReportRelatesToArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.FhirCode<ReportRelationTypeCodeType>({value: source.code}); }
    else { this.code = null; }
    if (source['_code']) {
      if (this.code) { this.code.addExtendedProperties(source._code!); }
      else { this.code = new fhir.FhirCode<ReportRelationTypeCodeType>(source._code as Partial<fhir.FhirCode>); }
    }
    if (source['target']) { this.target = source.target; }
    else if (source['targetIdentifier']) { this.target = new fhir.Identifier(source.targetIdentifier); }
    else if (source['targetReference']) { this.target = new fhir.Reference(source.targetReference); }
    else { this.target = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EvidenceReport.relatesTo' }
    iss.push(...this.vRSV('code',exp,'ReportRelationType',ReportRelationTypeVsValidation,'r'));
    iss.push(...this.vRS('target',exp));
    return iss;
  }
}
/**
 * Valid arguments for the EvidenceReportSection type.
 */
export interface EvidenceReportSectionArgs extends fhir.BackboneElementArgs {
  /**
   * The title identifies the section for a human reader. The title must be consistent with the narrative of the resource that is the target of the section.content reference. Generally, sections SHOULD have titles, but in some documents, it is unnecessary or inappropriate. Typically, this is where a section has subsections that have their own adequately distinguishing title,  or documents that only have a single section.
   */
  title?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.section.title
   */
  _title?:fhir.FhirElementArgs;
  /**
   * The code identifies the section for an automated processor of the document. This is particularly relevant when using profiles to control the structure of the document.   
   * If the section has content (instead of sub-sections), the section.code does not change the meaning or interpretation of the resource that is the content of the section in the comments for the section.code.
   */
  focus?: fhir.CodeableConceptArgs|undefined;
  /**
   * A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title.
   */
  focusReference?: fhir.ReferenceArgs|undefined;
  /**
   * Identifies who is responsible for the information in this section, not necessarily who typed it in.
   */
  author?: fhir.ReferenceArgs[]|undefined;
  /**
   * Document profiles may define what content should be represented in the narrative.
   */
  text?: fhir.NarrativeArgs|undefined;
  /**
   * This element is labeled as a modifier because a change list must not be misunderstood as a complete list.
   */
  mode?: fhir.FhirCode<ListModeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.section.mode
   */
  _mode?:fhir.FhirElementArgs;
  /**
   * Applications SHOULD render ordered lists in the order provided, but MAY allow users to re-order based on their own preferences as well. If there is no order specified, the order is unknown, though there may still be some order.
   */
  orderedBy?: fhir.CodeableConceptArgs|undefined;
  /**
   * Specifies any type of classification of the evidence report.
   */
  entryClassifier?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * If there are no entries in the list, an emptyReason SHOULD be provided.
   */
  entryReference?: fhir.ReferenceArgs[]|undefined;
  /**
   * Quantity as content.
   */
  entryQuantity?: fhir.QuantityArgs[]|undefined;
  /**
   * The various reasons for an empty section make a significant interpretation to its interpretation. Note that this code is for use when the entire section content has been suppressed, and not for when individual items are omitted - implementers may consider using a text note or a flag on an entry in these cases.
   */
  emptyReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * Nested sections are primarily used to help human readers navigate to particular portions of the document.
   */
  section?: fhir.EvidenceReportSectionArgs[]|undefined;
}

/**
 * The root of the sections that make up the composition.
 */
export class EvidenceReportSection extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EvidenceReportSection';
  /**
   * The title identifies the section for a human reader. The title must be consistent with the narrative of the resource that is the target of the section.content reference. Generally, sections SHOULD have titles, but in some documents, it is unnecessary or inappropriate. Typically, this is where a section has subsections that have their own adequately distinguishing title,  or documents that only have a single section.
   */
  public title?: fhir.FhirString|undefined;
  /**
   * The code identifies the section for an automated processor of the document. This is particularly relevant when using profiles to control the structure of the document.   
   * If the section has content (instead of sub-sections), the section.code does not change the meaning or interpretation of the resource that is the content of the section in the comments for the section.code.
   */
  public focus?: fhir.CodeableConcept|undefined;
  /**
   * A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title.
   */
  public focusReference?: fhir.Reference|undefined;
  /**
   * Identifies who is responsible for the information in this section, not necessarily who typed it in.
   */
  public author: fhir.Reference[];
  /**
   * Document profiles may define what content should be represented in the narrative.
   */
  public text?: fhir.Narrative|undefined;
  /**
   * This element is labeled as a modifier because a change list must not be misunderstood as a complete list.
   */
  public mode?: fhir.FhirCode<ListModeCodeType>|undefined;
  /**
   * Applications SHOULD render ordered lists in the order provided, but MAY allow users to re-order based on their own preferences as well. If there is no order specified, the order is unknown, though there may still be some order.
   */
  public orderedBy?: fhir.CodeableConcept|undefined;
  /**
   * Specifies any type of classification of the evidence report.
   */
  public entryClassifier: fhir.CodeableConcept[];
  /**
   * If there are no entries in the list, an emptyReason SHOULD be provided.
   */
  public entryReference: fhir.Reference[];
  /**
   * Quantity as content.
   */
  public entryQuantity: fhir.Quantity[];
  /**
   * The various reasons for an empty section make a significant interpretation to its interpretation. Note that this code is for use when the entire section content has been suppressed, and not for when individual items are omitted - implementers may consider using a text note or a flag on an entry in these cases.
   */
  public emptyReason?: fhir.CodeableConcept|undefined;
  /**
   * Nested sections are primarily used to help human readers navigate to particular portions of the document.
   */
  public section: fhir.EvidenceReportSection[];
  /**
   * Default constructor for EvidenceReportSection - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EvidenceReportSectionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['title']) { this.title = new fhir.FhirString({value: source.title}); }
    if (source['_title']) {
      if (this.title) { this.title.addExtendedProperties(source._title!); }
      else { this.title = new fhir.FhirString(source._title as Partial<fhir.FhirStringArgs>); }
    }
    if (source['focus']) { this.focus = new fhir.CodeableConcept(source.focus); }
    if (source['focusReference']) { this.focusReference = new fhir.Reference(source.focusReference); }
    if (source['author']) { this.author = source.author.map((x) => new fhir.Reference(x)); }
    else { this.author = []; }
    if (source['text']) { this.text = new fhir.Narrative(source.text); }
    if (source['mode']) { this.mode = new fhir.FhirCode<ListModeCodeType>({value: source.mode}); }
    if (source['_mode']) {
      if (this.mode) { this.mode.addExtendedProperties(source._mode!); }
      else { this.mode = new fhir.FhirCode<ListModeCodeType>(source._mode as Partial<fhir.FhirCode>); }
    }
    if (source['orderedBy']) { this.orderedBy = new fhir.CodeableConcept(source.orderedBy); }
    if (source['entryClassifier']) { this.entryClassifier = source.entryClassifier.map((x) => new fhir.CodeableConcept(x)); }
    else { this.entryClassifier = []; }
    if (source['entryReference']) { this.entryReference = source.entryReference.map((x) => new fhir.Reference(x)); }
    else { this.entryReference = []; }
    if (source['entryQuantity']) { this.entryQuantity = source.entryQuantity.map((x) => new fhir.Quantity(x)); }
    else { this.entryQuantity = []; }
    if (source['emptyReason']) { this.emptyReason = new fhir.CodeableConcept(source.emptyReason); }
    if (source['section']) { this.section = source.section.map((x) => new fhir.EvidenceReportSection(x)); }
    else { this.section = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EvidenceReport.section' }
    iss.push(...this.vOS('title',exp));
    iss.push(...this.vOS('focus',exp));
    iss.push(...this.vOS('focusReference',exp));
    iss.push(...this.vOA('author',exp));
    iss.push(...this.vOS('text',exp));
    iss.push(...this.vOSV('mode',exp,'ListMode',ListModeVsValidation,'r'));
    iss.push(...this.vOS('orderedBy',exp));
    iss.push(...this.vOA('entryClassifier',exp));
    iss.push(...this.vOA('entryReference',exp));
    iss.push(...this.vOA('entryQuantity',exp));
    iss.push(...this.vOS('emptyReason',exp));
    iss.push(...this.vOA('section',exp));
    return iss;
  }
}
/**
 * Valid arguments for the EvidenceReport type.
 */
export interface EvidenceReportArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "EvidenceReport"|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred. Multiple instances may share the same URL if they have a distinct version.
   */
  url?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * Allows filtering of summaries that are appropriate for use versus not.
   */
  status: fhir.FhirCode<PublicationStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: fhir.UsageContextArgs[]|undefined;
  /**
   * This element will contain unique identifiers that support de-duplication of EvidenceReports. This identifier can be valid for only one EvidenceReport resource.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * May include trial registry identifiers, e.g. NCT04372602 from clinicaltrials.gov. This identifier can be valid for multiple EvidenceReport resources.
   */
  relatedIdentifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * used for reports for which external citation is expected, such as use in support of scholarly publications.
   */
  citeAs?: fhir.Reference|fhir.FhirMarkdown|undefined;
  /**
   * used for reports for which external citation is expected, such as use in support of scholarly publications.
   */
  citeAsReference?: fhir.ReferenceArgs|undefined;
  /**
   * used for reports for which external citation is expected, such as use in support of scholarly publications.
   */
  citeAsMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Used for footnotes and annotations.
   */
  note?: fhir.AnnotationArgs[]|undefined;
  /**
   * Link, description or reference to artifact associated with the report.
   */
  relatedArtifact?: fhir.RelatedArtifactArgs[]|undefined;
  /**
   * May be used as an expression for search queries and search results
   */
  subject: fhir.EvidenceReportSubjectArgs|null;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the evidence report is the organization or individual primarily responsible for the maintenance and upkeep of the evidence report. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the evidence report. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: EvidenceReport.publisher
   */
  _publisher?:fhir.FhirElementArgs;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  contact?: fhir.ContactDetailArgs[]|undefined;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  author?: fhir.ContactDetailArgs[]|undefined;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  editor?: fhir.ContactDetailArgs[]|undefined;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  reviewer?: fhir.ContactDetailArgs[]|undefined;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  endorser?: fhir.ContactDetailArgs[]|undefined;
  /**
   * A document is a version specific composition.
   */
  relatesTo?: fhir.EvidenceReportRelatesToArgs[]|undefined;
  /**
   * The root of the sections that make up the composition.
   */
  section?: fhir.EvidenceReportSectionArgs[]|undefined;
}

/**
 * The EvidenceReport Resource is a specialized container for a collection of resources and codable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts.
 */
export class EvidenceReport extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'EvidenceReport';
  /**
   * Resource Type Name
   */
  public override resourceType: "EvidenceReport";
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred. Multiple instances may share the same URL if they have a distinct version.
   */
  public url?: fhir.FhirUri|undefined;
  /**
   * Allows filtering of summaries that are appropriate for use versus not.
   */
  public status: fhir.FhirCode<PublicationStatusCodeType>|null;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  public useContext: fhir.UsageContext[];
  /**
   * This element will contain unique identifiers that support de-duplication of EvidenceReports. This identifier can be valid for only one EvidenceReport resource.
   */
  public identifier: fhir.Identifier[];
  /**
   * May include trial registry identifiers, e.g. NCT04372602 from clinicaltrials.gov. This identifier can be valid for multiple EvidenceReport resources.
   */
  public relatedIdentifier: fhir.Identifier[];
  /**
   * used for reports for which external citation is expected, such as use in support of scholarly publications.
   */
  public citeAs?: (fhir.Reference|fhir.FhirMarkdown)|undefined;
  /**
   * Internal flag to properly serialize choice-type element EvidenceReport.citeAs[x]
   */
  protected static readonly _fts_citeAsIsChoice:true = true;
  /**
   * Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Used for footnotes and annotations.
   */
  public note: fhir.Annotation[];
  /**
   * Link, description or reference to artifact associated with the report.
   */
  public relatedArtifact: fhir.RelatedArtifact[];
  /**
   * May be used as an expression for search queries and search results
   */
  public subject: fhir.EvidenceReportSubject|null;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the evidence report is the organization or individual primarily responsible for the maintenance and upkeep of the evidence report. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the evidence report. This item SHOULD be populated unless the information is available from context.
   */
  public publisher?: fhir.FhirString|undefined;
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  public contact: fhir.ContactDetail[];
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  public author: fhir.ContactDetail[];
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  public editor: fhir.ContactDetail[];
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  public reviewer: fhir.ContactDetail[];
  /**
   * Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
   */
  public endorser: fhir.ContactDetail[];
  /**
   * A document is a version specific composition.
   */
  public relatesTo: fhir.EvidenceReportRelatesTo[];
  /**
   * The root of the sections that make up the composition.
   */
  public section: fhir.EvidenceReportSection[];
  /**
   * Default constructor for EvidenceReport - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<EvidenceReportArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'EvidenceReport';
    if (source['url']) { this.url = new fhir.FhirUri({value: source.url}); }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>); }
    }
    if (source['status']) { this.status = new fhir.FhirCode<PublicationStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<PublicationStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['useContext']) { this.useContext = source.useContext.map((x) => new fhir.UsageContext(x)); }
    else { this.useContext = []; }
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['relatedIdentifier']) { this.relatedIdentifier = source.relatedIdentifier.map((x) => new fhir.Identifier(x)); }
    else { this.relatedIdentifier = []; }
    if (source['citeAs']) { this.citeAs = source.citeAs; }
    else if (source['citeAsReference']) { this.citeAs = new fhir.Reference(source.citeAsReference); }
    else if (source['citeAsMarkdown']) { this.citeAs = new fhir.FhirMarkdown({value: source.citeAsMarkdown}); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
    if (source['relatedArtifact']) { this.relatedArtifact = source.relatedArtifact.map((x) => new fhir.RelatedArtifact(x)); }
    else { this.relatedArtifact = []; }
    if (source['subject']) { this.subject = new fhir.EvidenceReportSubject(source.subject); }
    else { this.subject = null; }
    if (source['publisher']) { this.publisher = new fhir.FhirString({value: source.publisher}); }
    if (source['_publisher']) {
      if (this.publisher) { this.publisher.addExtendedProperties(source._publisher!); }
      else { this.publisher = new fhir.FhirString(source._publisher as Partial<fhir.FhirStringArgs>); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.ContactDetail(x)); }
    else { this.contact = []; }
    if (source['author']) { this.author = source.author.map((x) => new fhir.ContactDetail(x)); }
    else { this.author = []; }
    if (source['editor']) { this.editor = source.editor.map((x) => new fhir.ContactDetail(x)); }
    else { this.editor = []; }
    if (source['reviewer']) { this.reviewer = source.reviewer.map((x) => new fhir.ContactDetail(x)); }
    else { this.reviewer = []; }
    if (source['endorser']) { this.endorser = source.endorser.map((x) => new fhir.ContactDetail(x)); }
    else { this.endorser = []; }
    if (source['relatesTo']) { this.relatesTo = source.relatesTo.map((x) => new fhir.EvidenceReportRelatesTo(x)); }
    else { this.relatesTo = []; }
    if (source['section']) { this.section = source.section.map((x) => new fhir.EvidenceReportSection(x)); }
    else { this.section = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'EvidenceReport' }
    iss.push(...this.vRPS('resourceType',exp));
    iss.push(...this.vOS('url',exp));
    iss.push(...this.vRSV('status',exp,'PublicationStatus',PublicationStatusVsValidation,'r'));
    iss.push(...this.vOA('useContext',exp));
    iss.push(...this.vOA('identifier',exp));
    iss.push(...this.vOA('relatedIdentifier',exp));
    iss.push(...this.vOS('citeAs',exp));
    iss.push(...this.vOS('type',exp));
    iss.push(...this.vOA('note',exp));
    iss.push(...this.vOA('relatedArtifact',exp));
    iss.push(...this.vRS('subject',exp));
    iss.push(...this.vOS('publisher',exp));
    iss.push(...this.vOA('contact',exp));
    iss.push(...this.vOA('author',exp));
    iss.push(...this.vOA('editor',exp));
    iss.push(...this.vOA('reviewer',exp));
    iss.push(...this.vOA('endorser',exp));
    iss.push(...this.vOA('relatesTo',exp));
    iss.push(...this.vOA('section',exp));
    return iss;
  }
}
