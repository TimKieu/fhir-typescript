// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: ConceptMap

import * as fhir from '../fhir.js';

// @ts-ignore
import { ConceptMapEquivalenceCodes,  ConceptMapEquivalenceCodeType } from '../fhirValueSets/ConceptMapEquivalenceCodes.js';
// @ts-ignore
import { ConceptMapEquivalenceVsValidation } from '../fhirValueSets/ConceptMapEquivalenceVsValidation.js';
// @ts-ignore
import { ConformanceResourceStatusCodes,  ConformanceResourceStatusCodeType } from '../fhirValueSets/ConformanceResourceStatusCodes.js';
// @ts-ignore
import { ConformanceResourceStatusVsValidation } from '../fhirValueSets/ConformanceResourceStatusVsValidation.js';
/**
 * Valid arguments for the ConceptMapContact type.
 */
export interface ConceptMapContactArgs extends fhir.BackboneElementArgs {
  /**
   * The name of an individual to contact regarding the concept map.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.contact.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Contact details for individual (if a name was provided) or the publisher.
   */
  telecom?: fhir.ContactPointArgs[]|undefined;
}

/**
 * Contacts to assist a user in finding and communicating with the publisher.
 */
export class ConceptMapContact extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConceptMapContact';
  /**
   * The name of an individual to contact regarding the concept map.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Contact details for individual (if a name was provided) or the publisher.
   */
  public telecom: fhir.ContactPoint[];
  /**
   * Default constructor for ConceptMapContact - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConceptMapContactArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['telecom']) { this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x)); }
    else { this.telecom = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ConceptMap.contact' }
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOA('telecom',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ConceptMapElementTargetDependsOn type.
 */
export interface ConceptMapElementTargetDependsOnArgs extends fhir.BackboneElementArgs {
  /**
   * A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. HL7 v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
   */
  element: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.dependsOn.element
   */
  _element?:fhir.FhirElementArgs;
  /**
   * An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
   */
  codeSystem: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.dependsOn.codeSystem
   */
  _codeSystem?:fhir.FhirElementArgs;
  /**
   * Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
   */
  code: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.dependsOn.code
   */
  _code?:fhir.FhirElementArgs;
}

/**
 * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
 */
export class ConceptMapElementTargetDependsOn extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConceptMapElementTargetDependsOn';
  /**
   * A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. HL7 v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
   */
  public element: fhir.FhirUri|null;
  /**
   * An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
   */
  public codeSystem: fhir.FhirUri|null;
  /**
   * Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
   */
  public code: fhir.FhirString|null;
  /**
   * Default constructor for ConceptMapElementTargetDependsOn - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConceptMapElementTargetDependsOnArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['element']) { this.element = new fhir.FhirUri({value: source.element}); }
    else { this.element = null; }
    if (source['_element']) {
      if (this.element) { this.element.addExtendedProperties(source._element!); }
      else { this.element = new fhir.FhirUri(source._element as Partial<fhir.FhirUriArgs>); }
    }
    if (source['codeSystem']) { this.codeSystem = new fhir.FhirUri({value: source.codeSystem}); }
    else { this.codeSystem = null; }
    if (source['_codeSystem']) {
      if (this.codeSystem) { this.codeSystem.addExtendedProperties(source._codeSystem!); }
      else { this.codeSystem = new fhir.FhirUri(source._codeSystem as Partial<fhir.FhirUriArgs>); }
    }
    if (source['code']) { this.code = new fhir.FhirString({value: source.code}); }
    else { this.code = null; }
    if (source['_code']) {
      if (this.code) { this.code.addExtendedProperties(source._code!); }
      else { this.code = new fhir.FhirString(source._code as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ConceptMap.element.target.dependsOn' }
    iss.push(...this.vRS('element',exp));
    iss.push(...this.vRS('codeSystem',exp));
    iss.push(...this.vRS('code',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ConceptMapElementTarget type.
 */
export interface ConceptMapElementTargetArgs extends fhir.BackboneElementArgs {
  /**
   * An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
   */
  codeSystem?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.codeSystem
   */
  _codeSystem?:fhir.FhirElementArgs;
  /**
   * Identity (code or path) or the element/item that the map refers to.
   */
  code?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.code
   */
  _code?:fhir.FhirElementArgs;
  /**
   * The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
   */
  equivalence: fhir.FhirCode<ConceptMapEquivalenceCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.equivalence
   */
  _equivalence?:fhir.FhirElementArgs;
  /**
   * A description of status/issues in mapping that conveys additional information not represented in  the structured data.
   */
  comments?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.target.comments
   */
  _comments?:fhir.FhirElementArgs;
  /**
   * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
   */
  dependsOn?: fhir.ConceptMapElementTargetDependsOnArgs[]|undefined;
  /**
   * A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
   */
  product?: fhir.ConceptMapElementTargetDependsOnArgs[]|undefined;
}

/**
 * A concept from the target value set that this concept maps to.
 */
export class ConceptMapElementTarget extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConceptMapElementTarget';
  /**
   * An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
   */
  public codeSystem?: fhir.FhirUri|undefined;
  /**
   * Identity (code or path) or the element/item that the map refers to.
   */
  public code?: fhir.FhirCode|undefined;
  /**
   * The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
   */
  public equivalence: fhir.FhirCode<ConceptMapEquivalenceCodeType>|null;
  /**
   * A description of status/issues in mapping that conveys additional information not represented in  the structured data.
   */
  public comments?: fhir.FhirString|undefined;
  /**
   * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
   */
  public dependsOn: fhir.ConceptMapElementTargetDependsOn[];
  /**
   * A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
   */
  public product: fhir.ConceptMapElementTargetDependsOn[];
  /**
   * Default constructor for ConceptMapElementTarget - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConceptMapElementTargetArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['codeSystem']) { this.codeSystem = new fhir.FhirUri({value: source.codeSystem}); }
    if (source['_codeSystem']) {
      if (this.codeSystem) { this.codeSystem.addExtendedProperties(source._codeSystem!); }
      else { this.codeSystem = new fhir.FhirUri(source._codeSystem as Partial<fhir.FhirUriArgs>); }
    }
    if (source['code']) { this.code = new fhir.FhirCode({value: source.code}); }
    if (source['_code']) {
      if (this.code) { this.code.addExtendedProperties(source._code!); }
      else { this.code = new fhir.FhirCode(source._code as Partial<fhir.FhirCodeArgs>); }
    }
    if (source['equivalence']) { this.equivalence = new fhir.FhirCode<ConceptMapEquivalenceCodeType>({value: source.equivalence}); }
    else { this.equivalence = null; }
    if (source['_equivalence']) {
      if (this.equivalence) { this.equivalence.addExtendedProperties(source._equivalence!); }
      else { this.equivalence = new fhir.FhirCode<ConceptMapEquivalenceCodeType>(source._equivalence as Partial<fhir.FhirCode>); }
    }
    if (source['comments']) { this.comments = new fhir.FhirString({value: source.comments}); }
    if (source['_comments']) {
      if (this.comments) { this.comments.addExtendedProperties(source._comments!); }
      else { this.comments = new fhir.FhirString(source._comments as Partial<fhir.FhirStringArgs>); }
    }
    if (source['dependsOn']) { this.dependsOn = source.dependsOn.map((x) => new fhir.ConceptMapElementTargetDependsOn(x)); }
    else { this.dependsOn = []; }
    if (source['product']) { this.product = source.product.map((x) => new fhir.ConceptMapElementTargetDependsOn(x)); }
    else { this.product = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ConceptMap.element.target' }
    iss.push(...this.vOS('codeSystem',exp));
    iss.push(...this.vOS('code',exp));
    iss.push(...this.vRSV('equivalence',exp,'ConceptMapEquivalence',ConceptMapEquivalenceVsValidation,'r'));
    iss.push(...this.vOS('comments',exp));
    iss.push(...this.vOA('dependsOn',exp));
    iss.push(...this.vOA('product',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ConceptMapElement type.
 */
export interface ConceptMapElementArgs extends fhir.BackboneElementArgs {
  /**
   * An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
   */
  codeSystem?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.codeSystem
   */
  _codeSystem?:fhir.FhirElementArgs;
  /**
   * Identity (code or path) or the element/item being mapped.
   */
  code?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.element.code
   */
  _code?:fhir.FhirElementArgs;
  /**
   * A concept from the target value set that this concept maps to.
   */
  target?: fhir.ConceptMapElementTargetArgs[]|undefined;
}

/**
 * Mappings for an individual concept in the source to one or more concepts in the target.
 */
export class ConceptMapElement extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConceptMapElement';
  /**
   * An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
   */
  public codeSystem?: fhir.FhirUri|undefined;
  /**
   * Identity (code or path) or the element/item being mapped.
   */
  public code?: fhir.FhirCode|undefined;
  /**
   * A concept from the target value set that this concept maps to.
   */
  public target: fhir.ConceptMapElementTarget[];
  /**
   * Default constructor for ConceptMapElement - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConceptMapElementArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['codeSystem']) { this.codeSystem = new fhir.FhirUri({value: source.codeSystem}); }
    if (source['_codeSystem']) {
      if (this.codeSystem) { this.codeSystem.addExtendedProperties(source._codeSystem!); }
      else { this.codeSystem = new fhir.FhirUri(source._codeSystem as Partial<fhir.FhirUriArgs>); }
    }
    if (source['code']) { this.code = new fhir.FhirCode({value: source.code}); }
    if (source['_code']) {
      if (this.code) { this.code.addExtendedProperties(source._code!); }
      else { this.code = new fhir.FhirCode(source._code as Partial<fhir.FhirCodeArgs>); }
    }
    if (source['target']) { this.target = source.target.map((x) => new fhir.ConceptMapElementTarget(x)); }
    else { this.target = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ConceptMap.element' }
    iss.push(...this.vOS('codeSystem',exp));
    iss.push(...this.vOS('code',exp));
    iss.push(...this.vOA('target',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ConceptMap type.
 */
export interface ConceptMapArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "ConceptMap"|undefined;
  /**
   * An absolute URL that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) published.
   */
  url?: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * Formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * Support human navigation.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Identify when/if the concept map should be used.
   */
  status: fhir.FhirCode<ConformanceResourceStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * This ConceptMap was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
   */
  experimental?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.experimental
   */
  _experimental?:fhir.FhirElementArgs;
  /**
   * Helps establish the "authority/credibility" of the concept map.  May also allow for contact.
   */
  publisher?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.publisher
   */
  _publisher?:fhir.FhirElementArgs;
  /**
   * Contacts to assist a user in finding and communicating with the publisher.
   */
  contact?: fhir.ConceptMapContactArgs[]|undefined;
  /**
   * Need to know when a concept map was first legal for use or became withdrawn or replaced.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Human understandability.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Assist in searching for appropriate concept map instances.
   */
  useContext?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Explains why this concept map is needed and why it has been constrained as it has.
   */
  requirements?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.requirements
   */
  _requirements?:fhir.FhirElementArgs;
  /**
   * A copyright statement relating to the concept map and/or its contents.
   */
  copyright?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ConceptMap.copyright
   */
  _copyright?:fhir.FhirElementArgs;
  /**
   * The source value set that specifies the concepts that are being mapped.
   */
  source?: fhir.FhirUri|fhir.Reference|undefined;
  /**
   * The source value set that specifies the concepts that are being mapped.
   */
  sourceUri?: fhir.FhirUri|string|undefined;
  /**
   * The source value set that specifies the concepts that are being mapped.
   */
  sourceReference?: fhir.ReferenceArgs|undefined;
  /**
   * The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
   */
  target?: fhir.FhirUri|fhir.Reference|undefined;
  /**
   * The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
   */
  targetUri?: fhir.FhirUri|string|undefined;
  /**
   * The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
   */
  targetReference?: fhir.ReferenceArgs|undefined;
  /**
   * Mappings for an individual concept in the source to one or more concepts in the target.
   */
  element?: fhir.ConceptMapElementArgs[]|undefined;
}

/**
 * A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
 */
export class ConceptMap extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ConceptMap';
  /**
   * Resource Type Name
   */
  public override resourceType: "ConceptMap";
  /**
   * An absolute URL that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) published.
   */
  public url?: fhir.FhirUri|undefined;
  /**
   * Formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
   */
  public version?: fhir.FhirString|undefined;
  /**
   * Support human navigation.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Identify when/if the concept map should be used.
   */
  public status: fhir.FhirCode<ConformanceResourceStatusCodeType>|null;
  /**
   * This ConceptMap was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
   */
  public experimental?: fhir.FhirBoolean|undefined;
  /**
   * Helps establish the "authority/credibility" of the concept map.  May also allow for contact.
   */
  public publisher?: fhir.FhirString|undefined;
  /**
   * Contacts to assist a user in finding and communicating with the publisher.
   */
  public contact: fhir.ConceptMapContact[];
  /**
   * Need to know when a concept map was first legal for use or became withdrawn or replaced.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Human understandability.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Assist in searching for appropriate concept map instances.
   */
  public useContext: fhir.CodeableConcept[];
  /**
   * Explains why this concept map is needed and why it has been constrained as it has.
   */
  public requirements?: fhir.FhirString|undefined;
  /**
   * A copyright statement relating to the concept map and/or its contents.
   */
  public copyright?: fhir.FhirString|undefined;
  /**
   * The source value set that specifies the concepts that are being mapped.
   */
  public source: (fhir.FhirUri|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element ConceptMap.source[x]
   */
  protected static readonly _fts_sourceIsChoice:true = true;
  /**
   * The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
   */
  public target: (fhir.FhirUri|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element ConceptMap.target[x]
   */
  protected static readonly _fts_targetIsChoice:true = true;
  /**
   * Mappings for an individual concept in the source to one or more concepts in the target.
   */
  public element: fhir.ConceptMapElement[];
  /**
   * Default constructor for ConceptMap - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConceptMapArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'ConceptMap';
    if (source['url']) { this.url = new fhir.FhirUri({value: source.url}); }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>); }
    }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['version']) { this.version = new fhir.FhirString({value: source.version}); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>); }
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['status']) { this.status = new fhir.FhirCode<ConformanceResourceStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<ConformanceResourceStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['experimental']) { this.experimental = new fhir.FhirBoolean({value: source.experimental}); }
    if (source['_experimental']) {
      if (this.experimental) { this.experimental.addExtendedProperties(source._experimental!); }
      else { this.experimental = new fhir.FhirBoolean(source._experimental as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['publisher']) { this.publisher = new fhir.FhirString({value: source.publisher}); }
    if (source['_publisher']) {
      if (this.publisher) { this.publisher.addExtendedProperties(source._publisher!); }
      else { this.publisher = new fhir.FhirString(source._publisher as Partial<fhir.FhirStringArgs>); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.ConceptMapContact(x)); }
    else { this.contact = []; }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['useContext']) { this.useContext = source.useContext.map((x) => new fhir.CodeableConcept(x)); }
    else { this.useContext = []; }
    if (source['requirements']) { this.requirements = new fhir.FhirString({value: source.requirements}); }
    if (source['_requirements']) {
      if (this.requirements) { this.requirements.addExtendedProperties(source._requirements!); }
      else { this.requirements = new fhir.FhirString(source._requirements as Partial<fhir.FhirStringArgs>); }
    }
    if (source['copyright']) { this.copyright = new fhir.FhirString({value: source.copyright}); }
    if (source['_copyright']) {
      if (this.copyright) { this.copyright.addExtendedProperties(source._copyright!); }
      else { this.copyright = new fhir.FhirString(source._copyright as Partial<fhir.FhirStringArgs>); }
    }
    if (source['source']) { this.source = source.source; }
    else if (source['sourceUri']) { this.source = new fhir.FhirUri({value: source.sourceUri}); }
    else if (source['sourceReference']) { this.source = new fhir.Reference(source.sourceReference); }
    else { this.source = null; }
    if (source['target']) { this.target = source.target; }
    else if (source['targetUri']) { this.target = new fhir.FhirUri({value: source.targetUri}); }
    else if (source['targetReference']) { this.target = new fhir.Reference(source.targetReference); }
    else { this.target = null; }
    if (source['element']) { this.element = source.element.map((x) => new fhir.ConceptMapElement(x)); }
    else { this.element = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ConceptMap' }
    iss.push(...this.vRPS('resourceType',exp));
    iss.push(...this.vOS('url',exp));
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOS('version',exp));
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vRSV('status',exp,'ConformanceResourceStatus',ConformanceResourceStatusVsValidation,'r'));
    iss.push(...this.vOS('experimental',exp));
    iss.push(...this.vOS('publisher',exp));
    iss.push(...this.vOA('contact',exp));
    iss.push(...this.vOS('date',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOA('useContext',exp));
    iss.push(...this.vOS('requirements',exp));
    iss.push(...this.vOS('copyright',exp));
    iss.push(...this.vRS('source',exp));
    iss.push(...this.vRS('target',exp));
    iss.push(...this.vOA('element',exp));
    return iss;
  }
}
