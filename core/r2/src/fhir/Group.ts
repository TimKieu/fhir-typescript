// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Group

import * as fhir from '../fhir.js';

// @ts-ignore
import { GroupTypeCodes,  GroupTypeCodeType } from '../fhirValueSets/GroupTypeCodes.js';
// @ts-ignore
import { GroupTypeVsValidation } from '../fhirValueSets/GroupTypeVsValidation.js';
/**
 * Valid arguments for the GroupCharacteristic type.
 */
export interface GroupCharacteristicArgs extends fhir.BackboneElementArgs {
  /**
   * Need a formal way of identifying the characteristic being described.
   */
  code: fhir.CodeableConceptArgs|null;
  /**
   * The value of the characteristic is what determines group membership.
   */
  value?: fhir.CodeableConcept|fhir.FhirBoolean|fhir.Quantity|fhir.Range|undefined;
  /**
   * The value of the characteristic is what determines group membership.
   */
  valueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The value of the characteristic is what determines group membership.
   */
  valueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * The value of the characteristic is what determines group membership.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * The value of the characteristic is what determines group membership.
   */
  valueRange?: fhir.RangeArgs|undefined;
  /**
   * Sometimes group membership is determined by characteristics not possessed.
   */
  exclude: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Group.characteristic.exclude
   */
  _exclude?:fhir.FhirElementArgs;
  /**
   * The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
   */
  period?: fhir.PeriodArgs|undefined;
}

/**
 * Needs to be a generic mechanism for identifying what individuals can be part of a group.
 */
export class GroupCharacteristic extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'GroupCharacteristic';
  /**
   * Need a formal way of identifying the characteristic being described.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * The value of the characteristic is what determines group membership.
   */
  public value: (fhir.CodeableConcept|fhir.FhirBoolean|fhir.Quantity|fhir.Range)|null;
  /**
   * Internal flag to properly serialize choice-type element Group.characteristic.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * Sometimes group membership is determined by characteristics not possessed.
   */
  public exclude: fhir.FhirBoolean|null;
  /**
   * The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
   */
  public period?: fhir.Period|undefined;
  /**
   * Default constructor for GroupCharacteristic - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<GroupCharacteristicArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
    if (source['value']) { this.value = source.value; }
    else if (source['valueCodeableConcept']) { this.value = new fhir.CodeableConcept(source.valueCodeableConcept); }
    else if (source['valueBoolean']) { this.value = new fhir.FhirBoolean({value: source.valueBoolean}); }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueRange']) { this.value = new fhir.Range(source.valueRange); }
    else { this.value = null; }
    if (source['exclude']) { this.exclude = new fhir.FhirBoolean({value: source.exclude}); }
    else { this.exclude = null; }
    if (source['_exclude']) {
      if (this.exclude) { this.exclude.addExtendedProperties(source._exclude!); }
      else { this.exclude = new fhir.FhirBoolean(source._exclude as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['period']) { this.period = new fhir.Period(source.period); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Group.characteristic' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vRS('value',exp));
    iss.push(...this.vRS('exclude',exp));
    iss.push(...this.vOS('period',exp));
    return iss;
  }
}
/**
 * Valid arguments for the GroupMember type.
 */
export interface GroupMemberArgs extends fhir.BackboneElementArgs {
  /**
   * A reference to the entity that is a member of the group. Must be consistent with Group.type.
   */
  entity: fhir.ReferenceArgs|null;
  /**
   * Need to track who was in a group at a  particular time.
   */
  period?: fhir.PeriodArgs|undefined;
  /**
   * Sometimes you don't know when someone stopped being in a group, but not when.
   */
  inactive?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Group.member.inactive
   */
  _inactive?:fhir.FhirElementArgs;
}

/**
 * Often the only thing of interest about a group is "who's in it".
 */
export class GroupMember extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'GroupMember';
  /**
   * A reference to the entity that is a member of the group. Must be consistent with Group.type.
   */
  public entity: fhir.Reference|null;
  /**
   * Need to track who was in a group at a  particular time.
   */
  public period?: fhir.Period|undefined;
  /**
   * Sometimes you don't know when someone stopped being in a group, but not when.
   */
  public inactive?: fhir.FhirBoolean|undefined;
  /**
   * Default constructor for GroupMember - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<GroupMemberArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['entity']) { this.entity = new fhir.Reference(source.entity); }
    else { this.entity = null; }
    if (source['period']) { this.period = new fhir.Period(source.period); }
    if (source['inactive']) { this.inactive = new fhir.FhirBoolean({value: source.inactive}); }
    if (source['_inactive']) {
      if (this.inactive) { this.inactive.addExtendedProperties(source._inactive!); }
      else { this.inactive = new fhir.FhirBoolean(source._inactive as Partial<fhir.FhirBooleanArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Group.member' }
    iss.push(...this.vRS('entity',exp));
    iss.push(...this.vOS('period',exp));
    iss.push(...this.vOS('inactive',exp));
    return iss;
  }
}
/**
 * Valid arguments for the Group type.
 */
export interface GroupArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Group"|undefined;
  /**
   * Allows the group to be referenced from external specifications.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * Identifies what type of resources the group is made up of.
   */
  type: fhir.FhirCode<GroupTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Group.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * There are use-cases for groups that define specific collections of individuals, and other groups that define "types" of intended individuals.  The requirements for both kinds of groups are similar, so we use a single resource, distinguished by this flag.
   */
  actual: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Group.actual
   */
  _actual?:fhir.FhirElementArgs;
  /**
   * Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * Used to identify the group in human communication.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Group.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Group size is a common defining characteristic.
   */
  quantity?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * Extended properties for primitive element: Group.quantity
   */
  _quantity?:fhir.FhirElementArgs;
  /**
   * Needs to be a generic mechanism for identifying what individuals can be part of a group.
   */
  characteristic?: fhir.GroupCharacteristicArgs[]|undefined;
  /**
   * Often the only thing of interest about a group is "who's in it".
   */
  member?: fhir.GroupMemberArgs[]|undefined;
}

/**
 * Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
 */
export class Group extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Group';
  /**
   * Resource Type Name
   */
  public override resourceType: "Group";
  /**
   * Allows the group to be referenced from external specifications.
   */
  public identifier: fhir.Identifier[];
  /**
   * Identifies what type of resources the group is made up of.
   */
  public type: fhir.FhirCode<GroupTypeCodeType>|null;
  /**
   * There are use-cases for groups that define specific collections of individuals, and other groups that define "types" of intended individuals.  The requirements for both kinds of groups are similar, so we use a single resource, distinguished by this flag.
   */
  public actual: fhir.FhirBoolean|null;
  /**
   * Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Used to identify the group in human communication.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Group size is a common defining characteristic.
   */
  public quantity?: fhir.FhirUnsignedInt|undefined;
  /**
   * Needs to be a generic mechanism for identifying what individuals can be part of a group.
   */
  public characteristic: fhir.GroupCharacteristic[];
  /**
   * Often the only thing of interest about a group is "who's in it".
   */
  public member: fhir.GroupMember[];
  /**
   * Default constructor for Group - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<GroupArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Group';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['type']) { this.type = new fhir.FhirCode<GroupTypeCodeType>({value: source.type}); }
    else { this.type = null; }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<GroupTypeCodeType>(source._type as Partial<fhir.FhirCode>); }
    }
    if (source['actual']) { this.actual = new fhir.FhirBoolean({value: source.actual}); }
    else { this.actual = null; }
    if (source['_actual']) {
      if (this.actual) { this.actual.addExtendedProperties(source._actual!); }
      else { this.actual = new fhir.FhirBoolean(source._actual as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['quantity']) { this.quantity = new fhir.FhirUnsignedInt({value: source.quantity}); }
    if (source['_quantity']) {
      if (this.quantity) { this.quantity.addExtendedProperties(source._quantity!); }
      else { this.quantity = new fhir.FhirUnsignedInt(source._quantity as Partial<fhir.FhirUnsignedIntArgs>); }
    }
    if (source['characteristic']) { this.characteristic = source.characteristic.map((x) => new fhir.GroupCharacteristic(x)); }
    else { this.characteristic = []; }
    if (source['member']) { this.member = source.member.map((x) => new fhir.GroupMember(x)); }
    else { this.member = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Group' }
    iss.push(...this.vOA('identifier',exp));
    iss.push(...this.vRSV('type',exp,'GroupType',GroupTypeVsValidation,'r'));
    iss.push(...this.vRS('actual',exp));
    iss.push(...this.vOS('code',exp));
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOS('quantity',exp));
    iss.push(...this.vOA('characteristic',exp));
    iss.push(...this.vOA('member',exp));
    return iss;
  }
}
