// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: ElementDefinition

import * as fhir from '../fhir.js';

// @ts-ignore
import { ResourceSlicingRulesCodes,  ResourceSlicingRulesCodeType } from '../fhirValueSets/ResourceSlicingRulesCodes.js';
// @ts-ignore
import { ResourceSlicingRulesVsValidation } from '../fhirValueSets/ResourceSlicingRulesVsValidation.js';
// @ts-ignore
import { DefinedTypesCodes,  DefinedTypesCodeType } from '../fhirValueSets/DefinedTypesCodes.js';
// @ts-ignore
import { DefinedTypesVsValidation } from '../fhirValueSets/DefinedTypesVsValidation.js';
// @ts-ignore
import { ResourceAggregationModeCodes,  ResourceAggregationModeCodeType } from '../fhirValueSets/ResourceAggregationModeCodes.js';
// @ts-ignore
import { ResourceAggregationModeVsValidation } from '../fhirValueSets/ResourceAggregationModeVsValidation.js';
// @ts-ignore
import { ConstraintSeverityCodes,  ConstraintSeverityCodeType } from '../fhirValueSets/ConstraintSeverityCodes.js';
// @ts-ignore
import { ConstraintSeverityVsValidation } from '../fhirValueSets/ConstraintSeverityVsValidation.js';
// @ts-ignore
import { BindingStrengthCodes,  BindingStrengthCodeType } from '../fhirValueSets/BindingStrengthCodes.js';
// @ts-ignore
import { BindingStrengthVsValidation } from '../fhirValueSets/BindingStrengthVsValidation.js';
// @ts-ignore
import { PropertyRepresentationCodes,  PropertyRepresentationCodeType } from '../fhirValueSets/PropertyRepresentationCodes.js';
// @ts-ignore
import { PropertyRepresentationVsValidation } from '../fhirValueSets/PropertyRepresentationVsValidation.js';
/**
 * Valid arguments for the ElementDefinitionSlicing type.
 */
export interface ElementDefinitionSlicingArgs extends fhir.FhirElementArgs {
  /**
   * Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
   */
  discriminator?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.slicing.discriminator
   */
  _discriminator?:(fhir.FhirElementArgs|null)[];
  /**
   * A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.slicing.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * If the matching elements have to occur in the same order as defined in the profile.
   */
  ordered?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.slicing.ordered
   */
  _ordered?:fhir.FhirElementArgs;
  /**
   * Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
   */
  rules: fhir.FhirCode<ResourceSlicingRulesCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.slicing.rules
   */
  _rules?:fhir.FhirElementArgs;
}

/**
 * Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
 */
export class ElementDefinitionSlicing extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionSlicing';
  /**
   * Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
   */
  public discriminator: fhir.FhirString[];
  /**
   * A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * If the matching elements have to occur in the same order as defined in the profile.
   */
  public ordered?: fhir.FhirBoolean|undefined;
  /**
   * Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
   */
  public rules: fhir.FhirCode<ResourceSlicingRulesCodeType>|null;
  /**
   * Default constructor for ElementDefinitionSlicing - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionSlicingArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['discriminator']) { this.discriminator = source.discriminator.map((x) => new fhir.FhirString({value: x})); }
    else { this.discriminator = []; }
    if (source['_discriminator']) {
      source._discriminator.forEach((x,i) => {
        if (this.discriminator.length >= i) { if (x) { this.discriminator[i].addExtendedProperties(x); } }
        else { if (x) { this.discriminator.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['ordered']) { this.ordered = new fhir.FhirBoolean({value: source.ordered}); }
    if (source['_ordered']) {
      if (this.ordered) { this.ordered.addExtendedProperties(source._ordered!); }
      else { this.ordered = new fhir.FhirBoolean(source._ordered as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['rules']) { this.rules = new fhir.FhirCode<ResourceSlicingRulesCodeType>({value: source.rules}); }
    else { this.rules = null; }
    if (source['_rules']) {
      if (this.rules) { this.rules.addExtendedProperties(source._rules!); }
      else { this.rules = new fhir.FhirCode<ResourceSlicingRulesCodeType>(source._rules as Partial<fhir.FhirCode>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.slicing' }
    iss.push(...this.vOA('discriminator',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOS('ordered',exp));
    iss.push(...this.vRSV('rules',exp,'ResourceSlicingRules',ResourceSlicingRulesVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinitionBase type.
 */
export interface ElementDefinitionBaseArgs extends fhir.FhirElementArgs {
  /**
   * The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [[[StructureDefinition]]] without a StructureDefinition.base.
   */
  path: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.base.path
   */
  _path?:fhir.FhirElementArgs;
  /**
   * Minimum cardinality of the base element identified by the path.
   */
  min: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.base.min
   */
  _min?:fhir.FhirElementArgs;
  /**
   * Maximum cardinality of the base element identified by the path.
   */
  max: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.base.max
   */
  _max?:fhir.FhirElementArgs;
}

/**
 * Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
 */
export class ElementDefinitionBase extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionBase';
  /**
   * The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [[[StructureDefinition]]] without a StructureDefinition.base.
   */
  public path: fhir.FhirString|null;
  /**
   * Minimum cardinality of the base element identified by the path.
   */
  public min: fhir.FhirInteger|null;
  /**
   * Maximum cardinality of the base element identified by the path.
   */
  public max: fhir.FhirString|null;
  /**
   * Default constructor for ElementDefinitionBase - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionBaseArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['path']) { this.path = new fhir.FhirString({value: source.path}); }
    else { this.path = null; }
    if (source['_path']) {
      if (this.path) { this.path.addExtendedProperties(source._path!); }
      else { this.path = new fhir.FhirString(source._path as Partial<fhir.FhirStringArgs>); }
    }
    if (source['min']) { this.min = new fhir.FhirInteger({value: source.min}); }
    else { this.min = null; }
    if (source['_min']) {
      if (this.min) { this.min.addExtendedProperties(source._min!); }
      else { this.min = new fhir.FhirInteger(source._min as Partial<fhir.FhirIntegerArgs>); }
    }
    if (source['max']) { this.max = new fhir.FhirString({value: source.max}); }
    else { this.max = null; }
    if (source['_max']) {
      if (this.max) { this.max.addExtendedProperties(source._max!); }
      else { this.max = new fhir.FhirString(source._max as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.base' }
    iss.push(...this.vRS('path',exp));
    iss.push(...this.vRS('min',exp));
    iss.push(...this.vRS('max',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinitionType type.
 */
export interface ElementDefinitionTypeArgs extends fhir.FhirElementArgs {
  /**
   * Name of Data type or Resource that is a(or the) type used for this element.
   */
  code: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.type.code
   */
  _code?:fhir.FhirElementArgs;
  /**
   * Identifies a profile structure or implementation Guide that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile. When more than one profile is specified, the content must conform to all of them. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
   */
  profile?: fhir.FhirUri[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.type.profile
   */
  _profile?:(fhir.FhirElementArgs|null)[];
  /**
   * If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
   */
  aggregation?: fhir.FhirCode<ResourceAggregationModeCodeType>[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.type.aggregation
   */
  _aggregation?:(fhir.FhirElementArgs|null)[];
}

/**
 * The data type or resource that the value of this element is permitted to be.
 */
export class ElementDefinitionType extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionType';
  /**
   * Name of Data type or Resource that is a(or the) type used for this element.
   */
  public code: fhir.FhirCode|null;
  /**
   * Identifies a profile structure or implementation Guide that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile. When more than one profile is specified, the content must conform to all of them. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
   */
  public profile: fhir.FhirUri[];
  /**
   * If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
   */
  public aggregation: fhir.FhirCode<ResourceAggregationModeCodeType>[];
  /**
   * Default constructor for ElementDefinitionType - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionTypeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.FhirCode({value: source.code}); }
    else { this.code = null; }
    if (source['_code']) {
      if (this.code) { this.code.addExtendedProperties(source._code!); }
      else { this.code = new fhir.FhirCode(source._code as Partial<fhir.FhirCodeArgs>); }
    }
    if (source['profile']) { this.profile = source.profile.map((x) => new fhir.FhirUri({value: x})); }
    else { this.profile = []; }
    if (source['_profile']) {
      source._profile.forEach((x,i) => {
        if (this.profile.length >= i) { if (x) { this.profile[i].addExtendedProperties(x); } }
        else { if (x) { this.profile.push(new fhir.FhirUri(x as Partial<fhir.FhirUriArgs>)); } }
      });
    }
    if (source['aggregation']) { this.aggregation = source.aggregation.map((x) => new fhir.FhirCode<ResourceAggregationModeCodeType>({value: x})); }
    else { this.aggregation = []; }
    if (source['_aggregation']) {
      source._aggregation.forEach((x,i) => {
        if (this.aggregation.length >= i) { if (x) { this.aggregation[i].addExtendedProperties(x); } }
        else { if (x) { this.aggregation.push(new fhir.FhirCode<ResourceAggregationModeCodeType>(x as Partial<fhir.FhirCode>)); } }
      });
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.type' }
    iss.push(...this.vRSV('code',exp,'DefinedTypes',DefinedTypesVsValidation,'r'));
    iss.push(...this.vOA('profile',exp));
    iss.push(...this.vOAV('aggregation',exp,'ResourceAggregationMode',ResourceAggregationModeVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinitionConstraint type.
 */
export interface ElementDefinitionConstraintArgs extends fhir.FhirElementArgs {
  /**
   * Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
   */
  key: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.constraint.key
   */
  _key?:fhir.FhirElementArgs;
  /**
   * Description of why this constraint is necessary or appropriate.
   */
  requirements?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.constraint.requirements
   */
  _requirements?:fhir.FhirElementArgs;
  /**
   * Identifies the impact constraint violation has on the conformance of the instance.
   */
  severity: fhir.FhirCode<ConstraintSeverityCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.constraint.severity
   */
  _severity?:fhir.FhirElementArgs;
  /**
   * Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
   */
  human: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.constraint.human
   */
  _human?:fhir.FhirElementArgs;
  /**
   * Used in Schematron tests of the validity of the resource.
   */
  xpath: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.constraint.xpath
   */
  _xpath?:fhir.FhirElementArgs;
}

/**
 * Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
 */
export class ElementDefinitionConstraint extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionConstraint';
  /**
   * Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
   */
  public key: fhir.FhirId|null;
  /**
   * Description of why this constraint is necessary or appropriate.
   */
  public requirements?: fhir.FhirString|undefined;
  /**
   * Identifies the impact constraint violation has on the conformance of the instance.
   */
  public severity: fhir.FhirCode<ConstraintSeverityCodeType>|null;
  /**
   * Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
   */
  public human: fhir.FhirString|null;
  /**
   * Used in Schematron tests of the validity of the resource.
   */
  public xpath: fhir.FhirString|null;
  /**
   * Default constructor for ElementDefinitionConstraint - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionConstraintArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['key']) { this.key = new fhir.FhirId({value: source.key}); }
    else { this.key = null; }
    if (source['_key']) {
      if (this.key) { this.key.addExtendedProperties(source._key!); }
      else { this.key = new fhir.FhirId(source._key as Partial<fhir.FhirIdArgs>); }
    }
    if (source['requirements']) { this.requirements = new fhir.FhirString({value: source.requirements}); }
    if (source['_requirements']) {
      if (this.requirements) { this.requirements.addExtendedProperties(source._requirements!); }
      else { this.requirements = new fhir.FhirString(source._requirements as Partial<fhir.FhirStringArgs>); }
    }
    if (source['severity']) { this.severity = new fhir.FhirCode<ConstraintSeverityCodeType>({value: source.severity}); }
    else { this.severity = null; }
    if (source['_severity']) {
      if (this.severity) { this.severity.addExtendedProperties(source._severity!); }
      else { this.severity = new fhir.FhirCode<ConstraintSeverityCodeType>(source._severity as Partial<fhir.FhirCode>); }
    }
    if (source['human']) { this.human = new fhir.FhirString({value: source.human}); }
    else { this.human = null; }
    if (source['_human']) {
      if (this.human) { this.human.addExtendedProperties(source._human!); }
      else { this.human = new fhir.FhirString(source._human as Partial<fhir.FhirStringArgs>); }
    }
    if (source['xpath']) { this.xpath = new fhir.FhirString({value: source.xpath}); }
    else { this.xpath = null; }
    if (source['_xpath']) {
      if (this.xpath) { this.xpath.addExtendedProperties(source._xpath!); }
      else { this.xpath = new fhir.FhirString(source._xpath as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.constraint' }
    iss.push(...this.vRS('key',exp));
    iss.push(...this.vOS('requirements',exp));
    iss.push(...this.vRSV('severity',exp,'ConstraintSeverity',ConstraintSeverityVsValidation,'r'));
    iss.push(...this.vRS('human',exp));
    iss.push(...this.vRS('xpath',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinitionBinding type.
 */
export interface ElementDefinitionBindingArgs extends fhir.FhirElementArgs {
  /**
   * Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
   */
  strength: fhir.FhirCode<BindingStrengthCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.binding.strength
   */
  _strength?:fhir.FhirElementArgs;
  /**
   * Describes the intended use of this particular set of codes.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.binding.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
   */
  valueSet?: fhir.FhirUri|fhir.Reference|undefined;
  /**
   * Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
   */
  valueSetUri?: fhir.FhirUri|string|undefined;
  /**
   * Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
   */
  valueSetReference?: fhir.ReferenceArgs|undefined;
}

/**
 * Binds to a value set if this element is coded (code, Coding, CodeableConcept).
 */
export class ElementDefinitionBinding extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionBinding';
  /**
   * Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
   */
  public strength: fhir.FhirCode<BindingStrengthCodeType>|null;
  /**
   * Describes the intended use of this particular set of codes.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
   */
  public valueSet?: (fhir.FhirUri|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.binding.valueSet[x]
   */
  protected static readonly _fts_valueSetIsChoice:true = true;
  /**
   * Default constructor for ElementDefinitionBinding - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionBindingArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['strength']) { this.strength = new fhir.FhirCode<BindingStrengthCodeType>({value: source.strength}); }
    else { this.strength = null; }
    if (source['_strength']) {
      if (this.strength) { this.strength.addExtendedProperties(source._strength!); }
      else { this.strength = new fhir.FhirCode<BindingStrengthCodeType>(source._strength as Partial<fhir.FhirCode>); }
    }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['valueSet']) { this.valueSet = source.valueSet; }
    else if (source['valueSetUri']) { this.valueSet = new fhir.FhirUri({value: source.valueSetUri}); }
    else if (source['valueSetReference']) { this.valueSet = new fhir.Reference(source.valueSetReference); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.binding' }
    iss.push(...this.vRSV('strength',exp,'BindingStrength',BindingStrengthVsValidation,'r'));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOS('valueSet',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinitionMapping type.
 */
export interface ElementDefinitionMappingArgs extends fhir.FhirElementArgs {
  /**
   * An internal reference to the definition of a mapping.
   */
  identity: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.mapping.identity
   */
  _identity?:fhir.FhirElementArgs;
  /**
   * Identifies the computable language in which mapping.map is expressed.
   */
  language?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.mapping.language
   */
  _language?:fhir.FhirElementArgs;
  /**
   * Expresses what part of the target specification corresponds to this element.
   */
  map: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.mapping.map
   */
  _map?:fhir.FhirElementArgs;
}

/**
 * Provides guidance to implementers familiar with or converting content from other specifications.
 */
export class ElementDefinitionMapping extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinitionMapping';
  /**
   * An internal reference to the definition of a mapping.
   */
  public identity: fhir.FhirId|null;
  /**
   * Identifies the computable language in which mapping.map is expressed.
   */
  public language?: fhir.FhirCode|undefined;
  /**
   * Expresses what part of the target specification corresponds to this element.
   */
  public map: fhir.FhirString|null;
  /**
   * Default constructor for ElementDefinitionMapping - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionMappingArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identity']) { this.identity = new fhir.FhirId({value: source.identity}); }
    else { this.identity = null; }
    if (source['_identity']) {
      if (this.identity) { this.identity.addExtendedProperties(source._identity!); }
      else { this.identity = new fhir.FhirId(source._identity as Partial<fhir.FhirIdArgs>); }
    }
    if (source['language']) { this.language = new fhir.FhirCode({value: source.language}); }
    if (source['_language']) {
      if (this.language) { this.language.addExtendedProperties(source._language!); }
      else { this.language = new fhir.FhirCode(source._language as Partial<fhir.FhirCodeArgs>); }
    }
    if (source['map']) { this.map = new fhir.FhirString({value: source.map}); }
    else { this.map = null; }
    if (source['_map']) {
      if (this.map) { this.map.addExtendedProperties(source._map!); }
      else { this.map = new fhir.FhirString(source._map as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition.mapping' }
    iss.push(...this.vRS('identity',exp));
    iss.push(...this.vOS('language',exp));
    iss.push(...this.vRS('map',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ElementDefinition type.
 */
export interface ElementDefinitionArgs extends fhir.FhirElementArgs {
  /**
   * The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
   */
  path: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.path
   */
  _path?:fhir.FhirElementArgs;
  /**
   * Codes that define how this element is represented in instances, when the deviation varies from the normal case.
   */
  representation?: fhir.FhirCode[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.representation
   */
  _representation?:(fhir.FhirElementArgs|null)[];
  /**
   * Allows referencing a defined element.  May also be used for code generation purposes.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * The text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
   */
  label?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.label
   */
  _label?:fhir.FhirElementArgs;
  /**
   * Links the meaning of an element to an external terminology.
   */
  code?: fhir.CodingArgs[]|undefined;
  /**
   * Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
   */
  slicing?: fhir.ElementDefinitionSlicingArgs|undefined;
  /**
   * A concise description of what this element means (e.g. for use in autogenerated summaries).
   */
  short?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.short
   */
  _short?:fhir.FhirElementArgs;
  /**
   * To allow a user to state the usage of an element in a particular context.
   */
  definition?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.definition
   */
  _definition?:fhir.FhirElementArgs;
  /**
   * Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc.
   */
  comments?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.comments
   */
  _comments?:fhir.FhirElementArgs;
  /**
   * This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
   */
  requirements?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.requirements
   */
  _requirements?:fhir.FhirElementArgs;
  /**
   * Allows for better easier recognition of the element by multiple communities, including international communities.
   */
  alias?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.alias
   */
  _alias?:(fhir.FhirElementArgs|null)[];
  /**
   * The minimum number of times this element SHALL appear in the instance.
   */
  min?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.min
   */
  _min?:fhir.FhirElementArgs;
  /**
   * The maximum number of times this element is permitted to appear in the instance.
   */
  max?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.max
   */
  _max?:fhir.FhirElementArgs;
  /**
   * Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
   */
  base?: fhir.ElementDefinitionBaseArgs|undefined;
  /**
   * The data type or resource that the value of this element is permitted to be.
   */
  type?: fhir.ElementDefinitionTypeArgs[]|undefined;
  /**
   * Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
   */
  nameReference?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.nameReference
   */
  _nameReference?:fhir.FhirElementArgs;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValue?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueInteger?: fhir.FhirInteger|number|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueInstant?: fhir.FhirInstant|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueString?: fhir.FhirString|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueUri?: fhir.FhirUri|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueDate?: fhir.FhirDate|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueTime?: fhir.FhirTime|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueCode?: fhir.FhirCode|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueOid?: fhir.FhirOid|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueId?: fhir.FhirId|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValuePositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueCoding?: fhir.CodingArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueRange?: fhir.RangeArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValuePeriod?: fhir.PeriodArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueRatio?: fhir.RatioArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueSignature?: fhir.SignatureArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueAddress?: fhir.AddressArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueTiming?: fhir.TimingArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueReference?: fhir.ReferenceArgs|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  defaultValueMeta?: fhir.MetaArgs|undefined;
  /**
   * The Implicit meaning that is to be understood when this element is missing (e.g. 'when this element is missing, the period is ongoing'.
   */
  meaningWhenMissing?: fhir.FhirMarkdown|string|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.meaningWhenMissing
   */
  _meaningWhenMissing?:fhir.FhirElementArgs;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixed?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedInteger?: fhir.FhirInteger|number|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedInstant?: fhir.FhirInstant|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedString?: fhir.FhirString|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedUri?: fhir.FhirUri|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedDate?: fhir.FhirDate|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedTime?: fhir.FhirTime|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedCode?: fhir.FhirCode|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedOid?: fhir.FhirOid|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedId?: fhir.FhirId|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedPositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedCoding?: fhir.CodingArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedRange?: fhir.RangeArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedRatio?: fhir.RatioArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedSignature?: fhir.SignatureArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedAddress?: fhir.AddressArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedTiming?: fhir.TimingArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedReference?: fhir.ReferenceArgs|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  fixedMeta?: fhir.MetaArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  pattern?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternInteger?: fhir.FhirInteger|number|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternInstant?: fhir.FhirInstant|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternString?: fhir.FhirString|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternUri?: fhir.FhirUri|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternDate?: fhir.FhirDate|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternTime?: fhir.FhirTime|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternCode?: fhir.FhirCode|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternOid?: fhir.FhirOid|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternId?: fhir.FhirId|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternPositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternCoding?: fhir.CodingArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternRange?: fhir.RangeArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternRatio?: fhir.RatioArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternSignature?: fhir.SignatureArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternAddress?: fhir.AddressArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternTiming?: fhir.TimingArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternReference?: fhir.ReferenceArgs|undefined;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  patternMeta?: fhir.MetaArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  example?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleInteger?: fhir.FhirInteger|number|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleInstant?: fhir.FhirInstant|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleString?: fhir.FhirString|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleUri?: fhir.FhirUri|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleDate?: fhir.FhirDate|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleTime?: fhir.FhirTime|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleCode?: fhir.FhirCode|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleOid?: fhir.FhirOid|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleId?: fhir.FhirId|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  examplePositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleCoding?: fhir.CodingArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleQuantity?: fhir.QuantityArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleRange?: fhir.RangeArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  examplePeriod?: fhir.PeriodArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleRatio?: fhir.RatioArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleSignature?: fhir.SignatureArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleAddress?: fhir.AddressArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleTiming?: fhir.TimingArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleReference?: fhir.ReferenceArgs|undefined;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  exampleMeta?: fhir.MetaArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValue?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueInteger?: fhir.FhirInteger|number|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueInstant?: fhir.FhirInstant|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueString?: fhir.FhirString|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueUri?: fhir.FhirUri|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueDate?: fhir.FhirDate|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueTime?: fhir.FhirTime|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueCode?: fhir.FhirCode|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueOid?: fhir.FhirOid|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueId?: fhir.FhirId|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValuePositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueCoding?: fhir.CodingArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueRange?: fhir.RangeArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValuePeriod?: fhir.PeriodArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueRatio?: fhir.RatioArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueSignature?: fhir.SignatureArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueAddress?: fhir.AddressArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueTiming?: fhir.TimingArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueReference?: fhir.ReferenceArgs|undefined;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  minValueMeta?: fhir.MetaArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValue?: fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueBoolean?: fhir.FhirBoolean|boolean|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueInteger?: fhir.FhirInteger|number|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueDecimal?: fhir.FhirDecimal|number|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueBase64Binary?: fhir.FhirBase64Binary|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueInstant?: fhir.FhirInstant|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueString?: fhir.FhirString|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueUri?: fhir.FhirUri|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueDate?: fhir.FhirDate|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueTime?: fhir.FhirTime|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueCode?: fhir.FhirCode|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueOid?: fhir.FhirOid|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueId?: fhir.FhirId|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueUnsignedInt?: fhir.FhirUnsignedInt|number|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValuePositiveInt?: fhir.FhirPositiveInt|number|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueMarkdown?: fhir.FhirMarkdown|string|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueAnnotation?: fhir.AnnotationArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueCoding?: fhir.CodingArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueRange?: fhir.RangeArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValuePeriod?: fhir.PeriodArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueRatio?: fhir.RatioArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueSignature?: fhir.SignatureArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueHumanName?: fhir.HumanNameArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueAddress?: fhir.AddressArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueContactPoint?: fhir.ContactPointArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueTiming?: fhir.TimingArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueReference?: fhir.ReferenceArgs|undefined;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  maxValueMeta?: fhir.MetaArgs|undefined;
  /**
   * Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
   */
  maxLength?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.maxLength
   */
  _maxLength?:fhir.FhirElementArgs;
  /**
   * A reference to an invariant that may make additional statements about the cardinality or value in the instance.
   */
  condition?: fhir.FhirId[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.condition
   */
  _condition?:(fhir.FhirElementArgs|null)[];
  /**
   * Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
   */
  constraint?: fhir.ElementDefinitionConstraintArgs[]|undefined;
  /**
   * Allows a profile to set expectations for system capabilities beyond merely respecting cardinality constraints.
   */
  mustSupport?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.mustSupport
   */
  _mustSupport?:fhir.FhirElementArgs;
  /**
   * Allows elements to be introduced into a specification that can't safely be ignored by applications that don't recognize them.
   */
  isModifier?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.isModifier
   */
  _isModifier?:fhir.FhirElementArgs;
  /**
   * Allow clients to search through large resources quickly.
   */
  isSummary?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ElementDefinition.isSummary
   */
  _isSummary?:fhir.FhirElementArgs;
  /**
   * Binds to a value set if this element is coded (code, Coding, CodeableConcept).
   */
  binding?: fhir.ElementDefinitionBindingArgs|undefined;
  /**
   * Provides guidance to implementers familiar with or converting content from other specifications.
   */
  mapping?: fhir.ElementDefinitionMappingArgs[]|undefined;
}

/**
 * Captures constraints on each element within the resource, profile, or extension.
 */
export class ElementDefinition extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ElementDefinition';
  /**
   * The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
   */
  public path: fhir.FhirString|null;
  /**
   * Codes that define how this element is represented in instances, when the deviation varies from the normal case.
   */
  public representation: fhir.FhirCode[];
  /**
   * Allows referencing a defined element.  May also be used for code generation purposes.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * The text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
   */
  public label?: fhir.FhirString|undefined;
  /**
   * Links the meaning of an element to an external terminology.
   */
  public code: fhir.Coding[];
  /**
   * Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
   */
  public slicing?: fhir.ElementDefinitionSlicing|undefined;
  /**
   * A concise description of what this element means (e.g. for use in autogenerated summaries).
   */
  public short?: fhir.FhirString|undefined;
  /**
   * To allow a user to state the usage of an element in a particular context.
   */
  public definition?: fhir.FhirMarkdown|undefined;
  /**
   * Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc.
   */
  public comments?: fhir.FhirMarkdown|undefined;
  /**
   * This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
   */
  public requirements?: fhir.FhirMarkdown|undefined;
  /**
   * Allows for better easier recognition of the element by multiple communities, including international communities.
   */
  public alias: fhir.FhirString[];
  /**
   * The minimum number of times this element SHALL appear in the instance.
   */
  public min?: fhir.FhirInteger|undefined;
  /**
   * The maximum number of times this element is permitted to appear in the instance.
   */
  public max?: fhir.FhirString|undefined;
  /**
   * Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
   */
  public base?: fhir.ElementDefinitionBase|undefined;
  /**
   * The data type or resource that the value of this element is permitted to be.
   */
  public type: fhir.ElementDefinitionType[];
  /**
   * Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
   */
  public nameReference?: fhir.FhirString|undefined;
  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  public defaultValue?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.defaultValue[x]
   */
  protected static readonly _fts_defaultValueIsChoice:true = true;
  /**
   * The Implicit meaning that is to be understood when this element is missing (e.g. 'when this element is missing, the period is ongoing'.
   */
  public meaningWhenMissing?: fhir.FhirMarkdown|undefined;
  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   */
  public fixed?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.fixed[x]
   */
  protected static readonly _fts_fixedIsChoice:true = true;
  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
   */
  public pattern?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.pattern[x]
   */
  protected static readonly _fts_patternIsChoice:true = true;
  /**
   * A sample value for this element demonstrating the type of information that would typically be captured.
   */
  public example?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.example[x]
   */
  protected static readonly _fts_exampleIsChoice:true = true;
  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  public minValue?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.minValue[x]
   */
  protected static readonly _fts_minValueIsChoice:true = true;
  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   */
  public maxValue?: (fhir.FhirBoolean|fhir.FhirInteger|fhir.FhirDecimal|fhir.FhirBase64Binary|fhir.FhirInstant|fhir.FhirString|fhir.FhirUri|fhir.FhirDate|fhir.FhirDateTime|fhir.FhirTime|fhir.FhirCode|fhir.FhirOid|fhir.FhirId|fhir.FhirUnsignedInt|fhir.FhirPositiveInt|fhir.FhirMarkdown|fhir.Annotation|fhir.Attachment|fhir.Identifier|fhir.CodeableConcept|fhir.Coding|fhir.Quantity|fhir.Range|fhir.Period|fhir.Ratio|fhir.SampledData|fhir.Signature|fhir.HumanName|fhir.Address|fhir.ContactPoint|fhir.Timing|fhir.Reference|fhir.Meta)|undefined;
  /**
   * Internal flag to properly serialize choice-type element ElementDefinition.maxValue[x]
   */
  protected static readonly _fts_maxValueIsChoice:true = true;
  /**
   * Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
   */
  public maxLength?: fhir.FhirInteger|undefined;
  /**
   * A reference to an invariant that may make additional statements about the cardinality or value in the instance.
   */
  public condition: fhir.FhirId[];
  /**
   * Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
   */
  public constraint: fhir.ElementDefinitionConstraint[];
  /**
   * Allows a profile to set expectations for system capabilities beyond merely respecting cardinality constraints.
   */
  public mustSupport?: fhir.FhirBoolean|undefined;
  /**
   * Allows elements to be introduced into a specification that can't safely be ignored by applications that don't recognize them.
   */
  public isModifier?: fhir.FhirBoolean|undefined;
  /**
   * Allow clients to search through large resources quickly.
   */
  public isSummary?: fhir.FhirBoolean|undefined;
  /**
   * Binds to a value set if this element is coded (code, Coding, CodeableConcept).
   */
  public binding?: fhir.ElementDefinitionBinding|undefined;
  /**
   * Provides guidance to implementers familiar with or converting content from other specifications.
   */
  public mapping: fhir.ElementDefinitionMapping[];
  /**
   * Default constructor for ElementDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ElementDefinitionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['path']) { this.path = new fhir.FhirString({value: source.path}); }
    else { this.path = null; }
    if (source['_path']) {
      if (this.path) { this.path.addExtendedProperties(source._path!); }
      else { this.path = new fhir.FhirString(source._path as Partial<fhir.FhirStringArgs>); }
    }
    if (source['representation']) { this.representation = source.representation.map((x) => new fhir.FhirCode({value: x})); }
    else { this.representation = []; }
    if (source['_representation']) {
      source._representation.forEach((x,i) => {
        if (this.representation.length >= i) { if (x) { this.representation[i].addExtendedProperties(x); } }
        else { if (x) { this.representation.push(new fhir.FhirCode(x as Partial<fhir.FhirCodeArgs>)); } }
      });
    }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>); }
    }
    if (source['label']) { this.label = new fhir.FhirString({value: source.label}); }
    if (source['_label']) {
      if (this.label) { this.label.addExtendedProperties(source._label!); }
      else { this.label = new fhir.FhirString(source._label as Partial<fhir.FhirStringArgs>); }
    }
    if (source['code']) { this.code = source.code.map((x) => new fhir.Coding(x)); }
    else { this.code = []; }
    if (source['slicing']) { this.slicing = new fhir.ElementDefinitionSlicing(source.slicing); }
    if (source['short']) { this.short = new fhir.FhirString({value: source.short}); }
    if (source['_short']) {
      if (this.short) { this.short.addExtendedProperties(source._short!); }
      else { this.short = new fhir.FhirString(source._short as Partial<fhir.FhirStringArgs>); }
    }
    if (source['definition']) { this.definition = new fhir.FhirMarkdown({value: source.definition}); }
    if (source['_definition']) {
      if (this.definition) { this.definition.addExtendedProperties(source._definition!); }
      else { this.definition = new fhir.FhirMarkdown(source._definition as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['comments']) { this.comments = new fhir.FhirMarkdown({value: source.comments}); }
    if (source['_comments']) {
      if (this.comments) { this.comments.addExtendedProperties(source._comments!); }
      else { this.comments = new fhir.FhirMarkdown(source._comments as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['requirements']) { this.requirements = new fhir.FhirMarkdown({value: source.requirements}); }
    if (source['_requirements']) {
      if (this.requirements) { this.requirements.addExtendedProperties(source._requirements!); }
      else { this.requirements = new fhir.FhirMarkdown(source._requirements as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['alias']) { this.alias = source.alias.map((x) => new fhir.FhirString({value: x})); }
    else { this.alias = []; }
    if (source['_alias']) {
      source._alias.forEach((x,i) => {
        if (this.alias.length >= i) { if (x) { this.alias[i].addExtendedProperties(x); } }
        else { if (x) { this.alias.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['min']) { this.min = new fhir.FhirInteger({value: source.min}); }
    if (source['_min']) {
      if (this.min) { this.min.addExtendedProperties(source._min!); }
      else { this.min = new fhir.FhirInteger(source._min as Partial<fhir.FhirIntegerArgs>); }
    }
    if (source['max']) { this.max = new fhir.FhirString({value: source.max}); }
    if (source['_max']) {
      if (this.max) { this.max.addExtendedProperties(source._max!); }
      else { this.max = new fhir.FhirString(source._max as Partial<fhir.FhirStringArgs>); }
    }
    if (source['base']) { this.base = new fhir.ElementDefinitionBase(source.base); }
    if (source['type']) { this.type = source.type.map((x) => new fhir.ElementDefinitionType(x)); }
    else { this.type = []; }
    if (source['nameReference']) { this.nameReference = new fhir.FhirString({value: source.nameReference}); }
    if (source['_nameReference']) {
      if (this.nameReference) { this.nameReference.addExtendedProperties(source._nameReference!); }
      else { this.nameReference = new fhir.FhirString(source._nameReference as Partial<fhir.FhirStringArgs>); }
    }
    if (source['defaultValue']) { this.defaultValue = source.defaultValue; }
    else if (source['defaultValueBoolean']) { this.defaultValue = new fhir.FhirBoolean({value: source.defaultValueBoolean}); }
    else if (source['defaultValueInteger']) { this.defaultValue = new fhir.FhirInteger({value: source.defaultValueInteger}); }
    else if (source['defaultValueDecimal']) { this.defaultValue = new fhir.FhirDecimal({value: source.defaultValueDecimal}); }
    else if (source['defaultValueBase64Binary']) { this.defaultValue = new fhir.FhirBase64Binary({value: source.defaultValueBase64Binary}); }
    else if (source['defaultValueInstant']) { this.defaultValue = new fhir.FhirInstant({value: source.defaultValueInstant}); }
    else if (source['defaultValueString']) { this.defaultValue = new fhir.FhirString({value: source.defaultValueString}); }
    else if (source['defaultValueUri']) { this.defaultValue = new fhir.FhirUri({value: source.defaultValueUri}); }
    else if (source['defaultValueDate']) { this.defaultValue = new fhir.FhirDate({value: source.defaultValueDate}); }
    else if (source['defaultValueDateTime']) { this.defaultValue = new fhir.FhirDateTime({value: source.defaultValueDateTime}); }
    else if (source['defaultValueTime']) { this.defaultValue = new fhir.FhirTime({value: source.defaultValueTime}); }
    else if (source['defaultValueCode']) { this.defaultValue = new fhir.FhirCode({value: source.defaultValueCode}); }
    else if (source['defaultValueOid']) { this.defaultValue = new fhir.FhirOid({value: source.defaultValueOid}); }
    else if (source['defaultValueId']) { this.defaultValue = new fhir.FhirId({value: source.defaultValueId}); }
    else if (source['defaultValueUnsignedInt']) { this.defaultValue = new fhir.FhirUnsignedInt({value: source.defaultValueUnsignedInt}); }
    else if (source['defaultValuePositiveInt']) { this.defaultValue = new fhir.FhirPositiveInt({value: source.defaultValuePositiveInt}); }
    else if (source['defaultValueMarkdown']) { this.defaultValue = new fhir.FhirMarkdown({value: source.defaultValueMarkdown}); }
    else if (source['defaultValueAnnotation']) { this.defaultValue = new fhir.Annotation(source.defaultValueAnnotation); }
    else if (source['defaultValueAttachment']) { this.defaultValue = new fhir.Attachment(source.defaultValueAttachment); }
    else if (source['defaultValueIdentifier']) { this.defaultValue = new fhir.Identifier(source.defaultValueIdentifier); }
    else if (source['defaultValueCodeableConcept']) { this.defaultValue = new fhir.CodeableConcept(source.defaultValueCodeableConcept); }
    else if (source['defaultValueCoding']) { this.defaultValue = new fhir.Coding(source.defaultValueCoding); }
    else if (source['defaultValueQuantity']) { this.defaultValue = new fhir.Quantity(source.defaultValueQuantity); }
    else if (source['defaultValueRange']) { this.defaultValue = new fhir.Range(source.defaultValueRange); }
    else if (source['defaultValuePeriod']) { this.defaultValue = new fhir.Period(source.defaultValuePeriod); }
    else if (source['defaultValueRatio']) { this.defaultValue = new fhir.Ratio(source.defaultValueRatio); }
    else if (source['defaultValueSampledData']) { this.defaultValue = new fhir.SampledData(source.defaultValueSampledData); }
    else if (source['defaultValueSignature']) { this.defaultValue = new fhir.Signature(source.defaultValueSignature); }
    else if (source['defaultValueHumanName']) { this.defaultValue = new fhir.HumanName(source.defaultValueHumanName); }
    else if (source['defaultValueAddress']) { this.defaultValue = new fhir.Address(source.defaultValueAddress); }
    else if (source['defaultValueContactPoint']) { this.defaultValue = new fhir.ContactPoint(source.defaultValueContactPoint); }
    else if (source['defaultValueTiming']) { this.defaultValue = new fhir.Timing(source.defaultValueTiming); }
    else if (source['defaultValueReference']) { this.defaultValue = new fhir.Reference(source.defaultValueReference); }
    else if (source['defaultValueMeta']) { this.defaultValue = new fhir.Meta(source.defaultValueMeta); }
    if (source['meaningWhenMissing']) { this.meaningWhenMissing = new fhir.FhirMarkdown({value: source.meaningWhenMissing}); }
    if (source['_meaningWhenMissing']) {
      if (this.meaningWhenMissing) { this.meaningWhenMissing.addExtendedProperties(source._meaningWhenMissing!); }
      else { this.meaningWhenMissing = new fhir.FhirMarkdown(source._meaningWhenMissing as Partial<fhir.FhirMarkdownArgs>); }
    }
    if (source['fixed']) { this.fixed = source.fixed; }
    else if (source['fixedBoolean']) { this.fixed = new fhir.FhirBoolean({value: source.fixedBoolean}); }
    else if (source['fixedInteger']) { this.fixed = new fhir.FhirInteger({value: source.fixedInteger}); }
    else if (source['fixedDecimal']) { this.fixed = new fhir.FhirDecimal({value: source.fixedDecimal}); }
    else if (source['fixedBase64Binary']) { this.fixed = new fhir.FhirBase64Binary({value: source.fixedBase64Binary}); }
    else if (source['fixedInstant']) { this.fixed = new fhir.FhirInstant({value: source.fixedInstant}); }
    else if (source['fixedString']) { this.fixed = new fhir.FhirString({value: source.fixedString}); }
    else if (source['fixedUri']) { this.fixed = new fhir.FhirUri({value: source.fixedUri}); }
    else if (source['fixedDate']) { this.fixed = new fhir.FhirDate({value: source.fixedDate}); }
    else if (source['fixedDateTime']) { this.fixed = new fhir.FhirDateTime({value: source.fixedDateTime}); }
    else if (source['fixedTime']) { this.fixed = new fhir.FhirTime({value: source.fixedTime}); }
    else if (source['fixedCode']) { this.fixed = new fhir.FhirCode({value: source.fixedCode}); }
    else if (source['fixedOid']) { this.fixed = new fhir.FhirOid({value: source.fixedOid}); }
    else if (source['fixedId']) { this.fixed = new fhir.FhirId({value: source.fixedId}); }
    else if (source['fixedUnsignedInt']) { this.fixed = new fhir.FhirUnsignedInt({value: source.fixedUnsignedInt}); }
    else if (source['fixedPositiveInt']) { this.fixed = new fhir.FhirPositiveInt({value: source.fixedPositiveInt}); }
    else if (source['fixedMarkdown']) { this.fixed = new fhir.FhirMarkdown({value: source.fixedMarkdown}); }
    else if (source['fixedAnnotation']) { this.fixed = new fhir.Annotation(source.fixedAnnotation); }
    else if (source['fixedAttachment']) { this.fixed = new fhir.Attachment(source.fixedAttachment); }
    else if (source['fixedIdentifier']) { this.fixed = new fhir.Identifier(source.fixedIdentifier); }
    else if (source['fixedCodeableConcept']) { this.fixed = new fhir.CodeableConcept(source.fixedCodeableConcept); }
    else if (source['fixedCoding']) { this.fixed = new fhir.Coding(source.fixedCoding); }
    else if (source['fixedQuantity']) { this.fixed = new fhir.Quantity(source.fixedQuantity); }
    else if (source['fixedRange']) { this.fixed = new fhir.Range(source.fixedRange); }
    else if (source['fixedPeriod']) { this.fixed = new fhir.Period(source.fixedPeriod); }
    else if (source['fixedRatio']) { this.fixed = new fhir.Ratio(source.fixedRatio); }
    else if (source['fixedSampledData']) { this.fixed = new fhir.SampledData(source.fixedSampledData); }
    else if (source['fixedSignature']) { this.fixed = new fhir.Signature(source.fixedSignature); }
    else if (source['fixedHumanName']) { this.fixed = new fhir.HumanName(source.fixedHumanName); }
    else if (source['fixedAddress']) { this.fixed = new fhir.Address(source.fixedAddress); }
    else if (source['fixedContactPoint']) { this.fixed = new fhir.ContactPoint(source.fixedContactPoint); }
    else if (source['fixedTiming']) { this.fixed = new fhir.Timing(source.fixedTiming); }
    else if (source['fixedReference']) { this.fixed = new fhir.Reference(source.fixedReference); }
    else if (source['fixedMeta']) { this.fixed = new fhir.Meta(source.fixedMeta); }
    if (source['pattern']) { this.pattern = source.pattern; }
    else if (source['patternBoolean']) { this.pattern = new fhir.FhirBoolean({value: source.patternBoolean}); }
    else if (source['patternInteger']) { this.pattern = new fhir.FhirInteger({value: source.patternInteger}); }
    else if (source['patternDecimal']) { this.pattern = new fhir.FhirDecimal({value: source.patternDecimal}); }
    else if (source['patternBase64Binary']) { this.pattern = new fhir.FhirBase64Binary({value: source.patternBase64Binary}); }
    else if (source['patternInstant']) { this.pattern = new fhir.FhirInstant({value: source.patternInstant}); }
    else if (source['patternString']) { this.pattern = new fhir.FhirString({value: source.patternString}); }
    else if (source['patternUri']) { this.pattern = new fhir.FhirUri({value: source.patternUri}); }
    else if (source['patternDate']) { this.pattern = new fhir.FhirDate({value: source.patternDate}); }
    else if (source['patternDateTime']) { this.pattern = new fhir.FhirDateTime({value: source.patternDateTime}); }
    else if (source['patternTime']) { this.pattern = new fhir.FhirTime({value: source.patternTime}); }
    else if (source['patternCode']) { this.pattern = new fhir.FhirCode({value: source.patternCode}); }
    else if (source['patternOid']) { this.pattern = new fhir.FhirOid({value: source.patternOid}); }
    else if (source['patternId']) { this.pattern = new fhir.FhirId({value: source.patternId}); }
    else if (source['patternUnsignedInt']) { this.pattern = new fhir.FhirUnsignedInt({value: source.patternUnsignedInt}); }
    else if (source['patternPositiveInt']) { this.pattern = new fhir.FhirPositiveInt({value: source.patternPositiveInt}); }
    else if (source['patternMarkdown']) { this.pattern = new fhir.FhirMarkdown({value: source.patternMarkdown}); }
    else if (source['patternAnnotation']) { this.pattern = new fhir.Annotation(source.patternAnnotation); }
    else if (source['patternAttachment']) { this.pattern = new fhir.Attachment(source.patternAttachment); }
    else if (source['patternIdentifier']) { this.pattern = new fhir.Identifier(source.patternIdentifier); }
    else if (source['patternCodeableConcept']) { this.pattern = new fhir.CodeableConcept(source.patternCodeableConcept); }
    else if (source['patternCoding']) { this.pattern = new fhir.Coding(source.patternCoding); }
    else if (source['patternQuantity']) { this.pattern = new fhir.Quantity(source.patternQuantity); }
    else if (source['patternRange']) { this.pattern = new fhir.Range(source.patternRange); }
    else if (source['patternPeriod']) { this.pattern = new fhir.Period(source.patternPeriod); }
    else if (source['patternRatio']) { this.pattern = new fhir.Ratio(source.patternRatio); }
    else if (source['patternSampledData']) { this.pattern = new fhir.SampledData(source.patternSampledData); }
    else if (source['patternSignature']) { this.pattern = new fhir.Signature(source.patternSignature); }
    else if (source['patternHumanName']) { this.pattern = new fhir.HumanName(source.patternHumanName); }
    else if (source['patternAddress']) { this.pattern = new fhir.Address(source.patternAddress); }
    else if (source['patternContactPoint']) { this.pattern = new fhir.ContactPoint(source.patternContactPoint); }
    else if (source['patternTiming']) { this.pattern = new fhir.Timing(source.patternTiming); }
    else if (source['patternReference']) { this.pattern = new fhir.Reference(source.patternReference); }
    else if (source['patternMeta']) { this.pattern = new fhir.Meta(source.patternMeta); }
    if (source['example']) { this.example = source.example; }
    else if (source['exampleBoolean']) { this.example = new fhir.FhirBoolean({value: source.exampleBoolean}); }
    else if (source['exampleInteger']) { this.example = new fhir.FhirInteger({value: source.exampleInteger}); }
    else if (source['exampleDecimal']) { this.example = new fhir.FhirDecimal({value: source.exampleDecimal}); }
    else if (source['exampleBase64Binary']) { this.example = new fhir.FhirBase64Binary({value: source.exampleBase64Binary}); }
    else if (source['exampleInstant']) { this.example = new fhir.FhirInstant({value: source.exampleInstant}); }
    else if (source['exampleString']) { this.example = new fhir.FhirString({value: source.exampleString}); }
    else if (source['exampleUri']) { this.example = new fhir.FhirUri({value: source.exampleUri}); }
    else if (source['exampleDate']) { this.example = new fhir.FhirDate({value: source.exampleDate}); }
    else if (source['exampleDateTime']) { this.example = new fhir.FhirDateTime({value: source.exampleDateTime}); }
    else if (source['exampleTime']) { this.example = new fhir.FhirTime({value: source.exampleTime}); }
    else if (source['exampleCode']) { this.example = new fhir.FhirCode({value: source.exampleCode}); }
    else if (source['exampleOid']) { this.example = new fhir.FhirOid({value: source.exampleOid}); }
    else if (source['exampleId']) { this.example = new fhir.FhirId({value: source.exampleId}); }
    else if (source['exampleUnsignedInt']) { this.example = new fhir.FhirUnsignedInt({value: source.exampleUnsignedInt}); }
    else if (source['examplePositiveInt']) { this.example = new fhir.FhirPositiveInt({value: source.examplePositiveInt}); }
    else if (source['exampleMarkdown']) { this.example = new fhir.FhirMarkdown({value: source.exampleMarkdown}); }
    else if (source['exampleAnnotation']) { this.example = new fhir.Annotation(source.exampleAnnotation); }
    else if (source['exampleAttachment']) { this.example = new fhir.Attachment(source.exampleAttachment); }
    else if (source['exampleIdentifier']) { this.example = new fhir.Identifier(source.exampleIdentifier); }
    else if (source['exampleCodeableConcept']) { this.example = new fhir.CodeableConcept(source.exampleCodeableConcept); }
    else if (source['exampleCoding']) { this.example = new fhir.Coding(source.exampleCoding); }
    else if (source['exampleQuantity']) { this.example = new fhir.Quantity(source.exampleQuantity); }
    else if (source['exampleRange']) { this.example = new fhir.Range(source.exampleRange); }
    else if (source['examplePeriod']) { this.example = new fhir.Period(source.examplePeriod); }
    else if (source['exampleRatio']) { this.example = new fhir.Ratio(source.exampleRatio); }
    else if (source['exampleSampledData']) { this.example = new fhir.SampledData(source.exampleSampledData); }
    else if (source['exampleSignature']) { this.example = new fhir.Signature(source.exampleSignature); }
    else if (source['exampleHumanName']) { this.example = new fhir.HumanName(source.exampleHumanName); }
    else if (source['exampleAddress']) { this.example = new fhir.Address(source.exampleAddress); }
    else if (source['exampleContactPoint']) { this.example = new fhir.ContactPoint(source.exampleContactPoint); }
    else if (source['exampleTiming']) { this.example = new fhir.Timing(source.exampleTiming); }
    else if (source['exampleReference']) { this.example = new fhir.Reference(source.exampleReference); }
    else if (source['exampleMeta']) { this.example = new fhir.Meta(source.exampleMeta); }
    if (source['minValue']) { this.minValue = source.minValue; }
    else if (source['minValueBoolean']) { this.minValue = new fhir.FhirBoolean({value: source.minValueBoolean}); }
    else if (source['minValueInteger']) { this.minValue = new fhir.FhirInteger({value: source.minValueInteger}); }
    else if (source['minValueDecimal']) { this.minValue = new fhir.FhirDecimal({value: source.minValueDecimal}); }
    else if (source['minValueBase64Binary']) { this.minValue = new fhir.FhirBase64Binary({value: source.minValueBase64Binary}); }
    else if (source['minValueInstant']) { this.minValue = new fhir.FhirInstant({value: source.minValueInstant}); }
    else if (source['minValueString']) { this.minValue = new fhir.FhirString({value: source.minValueString}); }
    else if (source['minValueUri']) { this.minValue = new fhir.FhirUri({value: source.minValueUri}); }
    else if (source['minValueDate']) { this.minValue = new fhir.FhirDate({value: source.minValueDate}); }
    else if (source['minValueDateTime']) { this.minValue = new fhir.FhirDateTime({value: source.minValueDateTime}); }
    else if (source['minValueTime']) { this.minValue = new fhir.FhirTime({value: source.minValueTime}); }
    else if (source['minValueCode']) { this.minValue = new fhir.FhirCode({value: source.minValueCode}); }
    else if (source['minValueOid']) { this.minValue = new fhir.FhirOid({value: source.minValueOid}); }
    else if (source['minValueId']) { this.minValue = new fhir.FhirId({value: source.minValueId}); }
    else if (source['minValueUnsignedInt']) { this.minValue = new fhir.FhirUnsignedInt({value: source.minValueUnsignedInt}); }
    else if (source['minValuePositiveInt']) { this.minValue = new fhir.FhirPositiveInt({value: source.minValuePositiveInt}); }
    else if (source['minValueMarkdown']) { this.minValue = new fhir.FhirMarkdown({value: source.minValueMarkdown}); }
    else if (source['minValueAnnotation']) { this.minValue = new fhir.Annotation(source.minValueAnnotation); }
    else if (source['minValueAttachment']) { this.minValue = new fhir.Attachment(source.minValueAttachment); }
    else if (source['minValueIdentifier']) { this.minValue = new fhir.Identifier(source.minValueIdentifier); }
    else if (source['minValueCodeableConcept']) { this.minValue = new fhir.CodeableConcept(source.minValueCodeableConcept); }
    else if (source['minValueCoding']) { this.minValue = new fhir.Coding(source.minValueCoding); }
    else if (source['minValueQuantity']) { this.minValue = new fhir.Quantity(source.minValueQuantity); }
    else if (source['minValueRange']) { this.minValue = new fhir.Range(source.minValueRange); }
    else if (source['minValuePeriod']) { this.minValue = new fhir.Period(source.minValuePeriod); }
    else if (source['minValueRatio']) { this.minValue = new fhir.Ratio(source.minValueRatio); }
    else if (source['minValueSampledData']) { this.minValue = new fhir.SampledData(source.minValueSampledData); }
    else if (source['minValueSignature']) { this.minValue = new fhir.Signature(source.minValueSignature); }
    else if (source['minValueHumanName']) { this.minValue = new fhir.HumanName(source.minValueHumanName); }
    else if (source['minValueAddress']) { this.minValue = new fhir.Address(source.minValueAddress); }
    else if (source['minValueContactPoint']) { this.minValue = new fhir.ContactPoint(source.minValueContactPoint); }
    else if (source['minValueTiming']) { this.minValue = new fhir.Timing(source.minValueTiming); }
    else if (source['minValueReference']) { this.minValue = new fhir.Reference(source.minValueReference); }
    else if (source['minValueMeta']) { this.minValue = new fhir.Meta(source.minValueMeta); }
    if (source['maxValue']) { this.maxValue = source.maxValue; }
    else if (source['maxValueBoolean']) { this.maxValue = new fhir.FhirBoolean({value: source.maxValueBoolean}); }
    else if (source['maxValueInteger']) { this.maxValue = new fhir.FhirInteger({value: source.maxValueInteger}); }
    else if (source['maxValueDecimal']) { this.maxValue = new fhir.FhirDecimal({value: source.maxValueDecimal}); }
    else if (source['maxValueBase64Binary']) { this.maxValue = new fhir.FhirBase64Binary({value: source.maxValueBase64Binary}); }
    else if (source['maxValueInstant']) { this.maxValue = new fhir.FhirInstant({value: source.maxValueInstant}); }
    else if (source['maxValueString']) { this.maxValue = new fhir.FhirString({value: source.maxValueString}); }
    else if (source['maxValueUri']) { this.maxValue = new fhir.FhirUri({value: source.maxValueUri}); }
    else if (source['maxValueDate']) { this.maxValue = new fhir.FhirDate({value: source.maxValueDate}); }
    else if (source['maxValueDateTime']) { this.maxValue = new fhir.FhirDateTime({value: source.maxValueDateTime}); }
    else if (source['maxValueTime']) { this.maxValue = new fhir.FhirTime({value: source.maxValueTime}); }
    else if (source['maxValueCode']) { this.maxValue = new fhir.FhirCode({value: source.maxValueCode}); }
    else if (source['maxValueOid']) { this.maxValue = new fhir.FhirOid({value: source.maxValueOid}); }
    else if (source['maxValueId']) { this.maxValue = new fhir.FhirId({value: source.maxValueId}); }
    else if (source['maxValueUnsignedInt']) { this.maxValue = new fhir.FhirUnsignedInt({value: source.maxValueUnsignedInt}); }
    else if (source['maxValuePositiveInt']) { this.maxValue = new fhir.FhirPositiveInt({value: source.maxValuePositiveInt}); }
    else if (source['maxValueMarkdown']) { this.maxValue = new fhir.FhirMarkdown({value: source.maxValueMarkdown}); }
    else if (source['maxValueAnnotation']) { this.maxValue = new fhir.Annotation(source.maxValueAnnotation); }
    else if (source['maxValueAttachment']) { this.maxValue = new fhir.Attachment(source.maxValueAttachment); }
    else if (source['maxValueIdentifier']) { this.maxValue = new fhir.Identifier(source.maxValueIdentifier); }
    else if (source['maxValueCodeableConcept']) { this.maxValue = new fhir.CodeableConcept(source.maxValueCodeableConcept); }
    else if (source['maxValueCoding']) { this.maxValue = new fhir.Coding(source.maxValueCoding); }
    else if (source['maxValueQuantity']) { this.maxValue = new fhir.Quantity(source.maxValueQuantity); }
    else if (source['maxValueRange']) { this.maxValue = new fhir.Range(source.maxValueRange); }
    else if (source['maxValuePeriod']) { this.maxValue = new fhir.Period(source.maxValuePeriod); }
    else if (source['maxValueRatio']) { this.maxValue = new fhir.Ratio(source.maxValueRatio); }
    else if (source['maxValueSampledData']) { this.maxValue = new fhir.SampledData(source.maxValueSampledData); }
    else if (source['maxValueSignature']) { this.maxValue = new fhir.Signature(source.maxValueSignature); }
    else if (source['maxValueHumanName']) { this.maxValue = new fhir.HumanName(source.maxValueHumanName); }
    else if (source['maxValueAddress']) { this.maxValue = new fhir.Address(source.maxValueAddress); }
    else if (source['maxValueContactPoint']) { this.maxValue = new fhir.ContactPoint(source.maxValueContactPoint); }
    else if (source['maxValueTiming']) { this.maxValue = new fhir.Timing(source.maxValueTiming); }
    else if (source['maxValueReference']) { this.maxValue = new fhir.Reference(source.maxValueReference); }
    else if (source['maxValueMeta']) { this.maxValue = new fhir.Meta(source.maxValueMeta); }
    if (source['maxLength']) { this.maxLength = new fhir.FhirInteger({value: source.maxLength}); }
    if (source['_maxLength']) {
      if (this.maxLength) { this.maxLength.addExtendedProperties(source._maxLength!); }
      else { this.maxLength = new fhir.FhirInteger(source._maxLength as Partial<fhir.FhirIntegerArgs>); }
    }
    if (source['condition']) { this.condition = source.condition.map((x) => new fhir.FhirId({value: x})); }
    else { this.condition = []; }
    if (source['_condition']) {
      source._condition.forEach((x,i) => {
        if (this.condition.length >= i) { if (x) { this.condition[i].addExtendedProperties(x); } }
        else { if (x) { this.condition.push(new fhir.FhirId(x as Partial<fhir.FhirIdArgs>)); } }
      });
    }
    if (source['constraint']) { this.constraint = source.constraint.map((x) => new fhir.ElementDefinitionConstraint(x)); }
    else { this.constraint = []; }
    if (source['mustSupport']) { this.mustSupport = new fhir.FhirBoolean({value: source.mustSupport}); }
    if (source['_mustSupport']) {
      if (this.mustSupport) { this.mustSupport.addExtendedProperties(source._mustSupport!); }
      else { this.mustSupport = new fhir.FhirBoolean(source._mustSupport as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['isModifier']) { this.isModifier = new fhir.FhirBoolean({value: source.isModifier}); }
    if (source['_isModifier']) {
      if (this.isModifier) { this.isModifier.addExtendedProperties(source._isModifier!); }
      else { this.isModifier = new fhir.FhirBoolean(source._isModifier as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['isSummary']) { this.isSummary = new fhir.FhirBoolean({value: source.isSummary}); }
    if (source['_isSummary']) {
      if (this.isSummary) { this.isSummary.addExtendedProperties(source._isSummary!); }
      else { this.isSummary = new fhir.FhirBoolean(source._isSummary as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['binding']) { this.binding = new fhir.ElementDefinitionBinding(source.binding); }
    if (source['mapping']) { this.mapping = source.mapping.map((x) => new fhir.ElementDefinitionMapping(x)); }
    else { this.mapping = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ElementDefinition' }
    iss.push(...this.vRS('path',exp));
    iss.push(...this.vOAV('representation',exp,'PropertyRepresentation',PropertyRepresentationVsValidation,'r'));
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOS('label',exp));
    iss.push(...this.vOA('code',exp));
    iss.push(...this.vOS('slicing',exp));
    iss.push(...this.vOS('short',exp));
    iss.push(...this.vOS('definition',exp));
    iss.push(...this.vOS('comments',exp));
    iss.push(...this.vOS('requirements',exp));
    iss.push(...this.vOA('alias',exp));
    iss.push(...this.vOS('min',exp));
    iss.push(...this.vOS('max',exp));
    iss.push(...this.vOS('base',exp));
    iss.push(...this.vOA('type',exp));
    iss.push(...this.vOS('nameReference',exp));
    iss.push(...this.vOS('defaultValue',exp));
    iss.push(...this.vOS('meaningWhenMissing',exp));
    iss.push(...this.vOS('fixed',exp));
    iss.push(...this.vOS('pattern',exp));
    iss.push(...this.vOS('example',exp));
    iss.push(...this.vOS('minValue',exp));
    iss.push(...this.vOS('maxValue',exp));
    iss.push(...this.vOS('maxLength',exp));
    iss.push(...this.vOA('condition',exp));
    iss.push(...this.vOA('constraint',exp));
    iss.push(...this.vOS('mustSupport',exp));
    iss.push(...this.vOS('isModifier',exp));
    iss.push(...this.vOS('isSummary',exp));
    iss.push(...this.vOS('binding',exp));
    iss.push(...this.vOA('mapping',exp));
    return iss;
  }
}
