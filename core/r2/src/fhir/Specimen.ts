// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Specimen

import * as fhir from '../fhir.js';

// @ts-ignore
import { SpecimenStatusCodes,  SpecimenStatusCodeType } from '../fhirValueSets/SpecimenStatusCodes.js';
// @ts-ignore
import { SpecimenStatusVsValidation } from '../fhirValueSets/SpecimenStatusVsValidation.js';
/**
 * Valid arguments for the SpecimenCollection type.
 */
export interface SpecimenCollectionArgs extends fhir.BackboneElementArgs {
  /**
   * Person who collected the specimen.
   */
  collector?: fhir.ReferenceArgs|undefined;
  /**
   * To communicate any details or issues encountered during the specimen collection procedure.
   */
  comment?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: Specimen.collection.comment
   */
  _comment?:(fhir.FhirElementArgs|null)[];
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  collected?: fhir.FhirDateTime|fhir.Period|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  collectedDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  collectedPeriod?: fhir.PeriodArgs|undefined;
  /**
   * The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
   */
  quantity?: fhir.QuantityArgs|undefined;
  /**
   * A coded value specifying the technique that is used to perform the procedure.
   */
  method?: fhir.CodeableConceptArgs|undefined;
  /**
   * Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
   */
  bodySite?: fhir.CodeableConceptArgs|undefined;
}

/**
 * Details concerning the specimen collection.
 */
export class SpecimenCollection extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SpecimenCollection';
  /**
   * Person who collected the specimen.
   */
  public collector?: fhir.Reference|undefined;
  /**
   * To communicate any details or issues encountered during the specimen collection procedure.
   */
  public comment: fhir.FhirString[];
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  public collected?: (fhir.FhirDateTime|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Specimen.collection.collected[x]
   */
  protected static readonly _fts_collectedIsChoice:true = true;
  /**
   * The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * A coded value specifying the technique that is used to perform the procedure.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
   */
  public bodySite?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenCollection - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SpecimenCollectionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['collector']) { this.collector = new fhir.Reference(source.collector); }
    if (source['comment']) { this.comment = source.comment.map((x) => new fhir.FhirString({value: x})); }
    else { this.comment = []; }
    if (source['_comment']) {
      source._comment.forEach((x,i) => {
        if (this.comment.length >= i) { if (x) { this.comment[i].addExtendedProperties(x); } }
        else { if (x) { this.comment.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['collected']) { this.collected = source.collected; }
    else if (source['collectedDateTime']) { this.collected = new fhir.FhirDateTime({value: source.collectedDateTime}); }
    else if (source['collectedPeriod']) { this.collected = new fhir.Period(source.collectedPeriod); }
    if (source['quantity']) { this.quantity = new fhir.Quantity(source.quantity); }
    if (source['method']) { this.method = new fhir.CodeableConcept(source.method); }
    if (source['bodySite']) { this.bodySite = new fhir.CodeableConcept(source.bodySite); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Specimen.collection' }
    this.vOS('collector',exp)
    this.vOA('comment',exp)
    this.vOS('collected',exp)
    this.vOS('quantity',exp)
    this.vOS('method',exp)
    this.vOS('bodySite',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SpecimenTreatment type.
 */
export interface SpecimenTreatmentArgs extends fhir.BackboneElementArgs {
  /**
   * Textual description of procedure.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Specimen.treatment.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * A coded value specifying the procedure used to process the specimen.
   */
  procedure?: fhir.CodeableConceptArgs|undefined;
  /**
   * Material used in the processing step.
   */
  additive?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Details concerning treatment and processing steps for the specimen.
 */
export class SpecimenTreatment extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SpecimenTreatment';
  /**
   * Textual description of procedure.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * A coded value specifying the procedure used to process the specimen.
   */
  public procedure?: fhir.CodeableConcept|undefined;
  /**
   * Material used in the processing step.
   */
  public additive: fhir.Reference[];
  /**
   * Default constructor for SpecimenTreatment - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SpecimenTreatmentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['procedure']) { this.procedure = new fhir.CodeableConcept(source.procedure); }
    if (source['additive']) { this.additive = source.additive.map((x) => new fhir.Reference(x)); }
    else { this.additive = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Specimen.treatment' }
    this.vOS('description',exp)
    this.vOS('procedure',exp)
    this.vOA('additive',exp)
    return issues;
  }
}
/**
 * Valid arguments for the SpecimenContainer type.
 */
export interface SpecimenContainerArgs extends fhir.BackboneElementArgs {
  /**
   * Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * Textual description of the container.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Specimen.container.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * The type of container associated with the specimen (e.g. slide, aliquot, etc.).
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The capacity (volume or other measure) the container may contain.
   */
  capacity?: fhir.QuantityArgs|undefined;
  /**
   * The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
   */
  specimenQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additive?: fhir.CodeableConcept|fhir.Reference|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveReference?: fhir.ReferenceArgs|undefined;
}

/**
 * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
 */
export class SpecimenContainer extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SpecimenContainer';
  /**
   * Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
   */
  public identifier: fhir.Identifier[];
  /**
   * Textual description of the container.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * The type of container associated with the specimen (e.g. slide, aliquot, etc.).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The capacity (volume or other measure) the container may contain.
   */
  public capacity?: fhir.Quantity|undefined;
  /**
   * The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
   */
  public specimenQuantity?: fhir.Quantity|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additive?: (fhir.CodeableConcept|fhir.Reference)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Specimen.container.additive[x]
   */
  protected static readonly _fts_additiveIsChoice:true = true;
  /**
   * Default constructor for SpecimenContainer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SpecimenContainerArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['capacity']) { this.capacity = new fhir.Quantity(source.capacity); }
    if (source['specimenQuantity']) { this.specimenQuantity = new fhir.Quantity(source.specimenQuantity); }
    if (source['additive']) { this.additive = source.additive; }
    else if (source['additiveCodeableConcept']) { this.additive = new fhir.CodeableConcept(source.additiveCodeableConcept); }
    else if (source['additiveReference']) { this.additive = new fhir.Reference(source.additiveReference); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Specimen.container' }
    this.vOA('identifier',exp)
    this.vOS('description',exp)
    this.vOS('type',exp)
    this.vOS('capacity',exp)
    this.vOS('specimenQuantity',exp)
    this.vOS('additive',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Specimen type.
 */
export interface SpecimenArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Specimen"|undefined;
  /**
   * Id for specimen.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * The availability of the specimen.
   */
  status?: fhir.FhirCode<SpecimenStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Specimen.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * The kind of material that forms the specimen.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
   */
  parent?: fhir.ReferenceArgs[]|undefined;
  /**
   * Must know the subject context.
   */
  subject: fhir.ReferenceArgs|null;
  /**
   * The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
   */
  accessionIdentifier?: fhir.IdentifierArgs|undefined;
  /**
   * Time when specimen was received for processing or testing.
   */
  receivedTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Specimen.receivedTime
   */
  _receivedTime?:fhir.FhirElementArgs;
  /**
   * Details concerning the specimen collection.
   */
  collection?: fhir.SpecimenCollectionArgs|undefined;
  /**
   * Details concerning treatment and processing steps for the specimen.
   */
  treatment?: fhir.SpecimenTreatmentArgs[]|undefined;
  /**
   * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
   */
  container?: fhir.SpecimenContainerArgs[]|undefined;
}

/**
 * A sample to be used for analysis.
 */
export class Specimen extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Specimen';
  /**
   * Resource Type Name
   */
  public override resourceType: "Specimen";
  /**
   * Id for specimen.
   */
  public identifier: fhir.Identifier[];
  /**
   * The availability of the specimen.
   */
  public status?: fhir.FhirCode<SpecimenStatusCodeType>|undefined;
  /**
   * The kind of material that forms the specimen.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
   */
  public parent: fhir.Reference[];
  /**
   * Must know the subject context.
   */
  public subject: fhir.Reference|null;
  /**
   * The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
   */
  public accessionIdentifier?: fhir.Identifier|undefined;
  /**
   * Time when specimen was received for processing or testing.
   */
  public receivedTime?: fhir.FhirDateTime|undefined;
  /**
   * Details concerning the specimen collection.
   */
  public collection?: fhir.SpecimenCollection|undefined;
  /**
   * Details concerning treatment and processing steps for the specimen.
   */
  public treatment: fhir.SpecimenTreatment[];
  /**
   * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
   */
  public container: fhir.SpecimenContainer[];
  /**
   * Default constructor for Specimen - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SpecimenArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Specimen';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['status']) { this.status = new fhir.FhirCode<SpecimenStatusCodeType>({value: source.status}); }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<SpecimenStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['parent']) { this.parent = source.parent.map((x) => new fhir.Reference(x)); }
    else { this.parent = []; }
    if (source['subject']) { this.subject = new fhir.Reference(source.subject); }
    else { this.subject = null; }
    if (source['accessionIdentifier']) { this.accessionIdentifier = new fhir.Identifier(source.accessionIdentifier); }
    if (source['receivedTime']) { this.receivedTime = new fhir.FhirDateTime({value: source.receivedTime}); }
    if (source['_receivedTime']) {
      if (this.receivedTime) { this.receivedTime.addExtendedProperties(source._receivedTime!); }
      else { this.receivedTime = new fhir.FhirDateTime(source._receivedTime as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['collection']) { this.collection = new fhir.SpecimenCollection(source.collection); }
    if (source['treatment']) { this.treatment = source.treatment.map((x) => new fhir.SpecimenTreatment(x)); }
    else { this.treatment = []; }
    if (source['container']) { this.container = source.container.map((x) => new fhir.SpecimenContainer(x)); }
    else { this.container = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Specimen' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vOSV('status',exp,'SpecimenStatus',SpecimenStatusVsValidation,'r')
    this.vOS('type',exp)
    this.vOA('parent',exp)
    this.vRS('subject',exp)
    this.vOS('accessionIdentifier',exp)
    this.vOS('receivedTime',exp)
    this.vOS('collection',exp)
    this.vOA('treatment',exp)
    this.vOA('container',exp)
    return issues;
  }
}
