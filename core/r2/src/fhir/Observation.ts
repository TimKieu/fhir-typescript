// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Observation

import * as fhir from '../fhir.js';

// @ts-ignore
import { ObservationRelationshiptypesCodes,  ObservationRelationshiptypesCodeType } from '../fhirValueSets/ObservationRelationshiptypesCodes.js';
// @ts-ignore
import { ObservationRelationshiptypesVsValidation } from '../fhirValueSets/ObservationRelationshiptypesVsValidation.js';
// @ts-ignore
import { ObservationStatusCodes,  ObservationStatusCodeType } from '../fhirValueSets/ObservationStatusCodes.js';
// @ts-ignore
import { ObservationStatusVsValidation } from '../fhirValueSets/ObservationStatusVsValidation.js';
/**
 * Valid arguments for the ObservationReferenceRange type.
 */
export interface ObservationReferenceRangeArgs extends fhir.BackboneElementArgs {
  /**
   * The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is &lt;=2.3).
   */
  low?: fhir.QuantityArgs|undefined;
  /**
   * The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is &gt;= 2.3).
   */
  high?: fhir.QuantityArgs|undefined;
  /**
   * Need to be able to say what kind of reference range this is - normal, recommended, therapeutic, or perhaps what state this reference range applies to (i.e. age, hormonal cycles, etc.).
   */
  meaning?: fhir.CodeableConceptArgs|undefined;
  /**
   * Some analytes vary greatly over age.
   */
  age?: fhir.RangeArgs|undefined;
  /**
   * Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
   */
  text?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Observation.referenceRange.text
   */
  _text?:fhir.FhirElementArgs;
}

/**
 * Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
 */
export class ObservationReferenceRange extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationReferenceRange';
  /**
   * The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is &lt;=2.3).
   */
  public low?: fhir.Quantity|undefined;
  /**
   * The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is &gt;= 2.3).
   */
  public high?: fhir.Quantity|undefined;
  /**
   * Need to be able to say what kind of reference range this is - normal, recommended, therapeutic, or perhaps what state this reference range applies to (i.e. age, hormonal cycles, etc.).
   */
  public meaning?: fhir.CodeableConcept|undefined;
  /**
   * Some analytes vary greatly over age.
   */
  public age?: fhir.Range|undefined;
  /**
   * Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
   */
  public text?: fhir.FhirString|undefined;
  /**
   * Default constructor for ObservationReferenceRange - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationReferenceRangeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['low']) { this.low = new fhir.Quantity(source.low); }
    if (source['high']) { this.high = new fhir.Quantity(source.high); }
    if (source['meaning']) { this.meaning = new fhir.CodeableConcept(source.meaning); }
    if (source['age']) { this.age = new fhir.Range(source.age); }
    if (source['text']) { this.text = new fhir.FhirString({value: source.text}); }
    if (source['_text']) {
      if (this.text) { this.text.addExtendedProperties(source._text!); }
      else { this.text = new fhir.FhirString(source._text as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Observation.referenceRange' }
    this.vOS('low',exp)
    this.vOS('high',exp)
    this.vOS('meaning',exp)
    this.vOS('age',exp)
    this.vOS('text',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ObservationRelated type.
 */
export interface ObservationRelatedArgs extends fhir.BackboneElementArgs {
  /**
   * A relationship type SHOULD be provided.
   */
  type?: fhir.FhirCode<ObservationRelationshiptypesCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Observation.related.type
   */
  _type?:fhir.FhirElementArgs;
  /**
   * A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
   */
  target: fhir.ReferenceArgs|null;
}

/**
 * Normally, an observation will have either a value or a set of related observations. A few observations (e.g. Apgar score) may have both a value and a set of related observations or sometimes QuestionnaireResponse  from which the measure is derived.
 */
export class ObservationRelated extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationRelated';
  /**
   * A relationship type SHOULD be provided.
   */
  public type?: fhir.FhirCode<ObservationRelationshiptypesCodeType>|undefined;
  /**
   * A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
   */
  public target: fhir.Reference|null;
  /**
   * Default constructor for ObservationRelated - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationRelatedArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.FhirCode<ObservationRelationshiptypesCodeType>({value: source.type}); }
    if (source['_type']) {
      if (this.type) { this.type.addExtendedProperties(source._type!); }
      else { this.type = new fhir.FhirCode<ObservationRelationshiptypesCodeType>(source._type as Partial<fhir.FhirCode>); }
    }
    if (source['target']) { this.target = new fhir.Reference(source.target); }
    else { this.target = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Observation.related' }
    this.vOSV('type',exp,'ObservationRelationshiptypes',ObservationRelationshiptypesVsValidation,'r')
    this.vRS('target',exp)
    return issues;
  }
}
/**
 * Valid arguments for the ObservationComponent type.
 */
export interface ObservationComponentArgs extends fhir.BackboneElementArgs {
  /**
   * Knowing what kind of observation is being made is essential to understanding the observation.
   */
  code: fhir.CodeableConceptArgs|null;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  value?: fhir.Quantity|fhir.CodeableConcept|fhir.FhirString|fhir.Range|fhir.Ratio|fhir.SampledData|fhir.Attachment|fhir.FhirTime|fhir.FhirDateTime|fhir.Period|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueString?: fhir.FhirString|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueRange?: fhir.RangeArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueRatio?: fhir.RatioArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueTime?: fhir.FhirTime|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valuePeriod?: fhir.PeriodArgs|undefined;
  /**
   * For many results it is necessary to handle exceptional values in measurements.
   */
  dataAbsentReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
   */
  referenceRange?: fhir.ObservationReferenceRangeArgs[]|undefined;
}

/**
 * Component observations share the same attributes in the Observation resource as the primary observation and are always treated a part of a single observation (they are not separable).   However, the reference range for the primary observation value is not inherited by the component values and is required when appropriate for each component observation.
 */
export class ObservationComponent extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ObservationComponent';
  /**
   * Knowing what kind of observation is being made is essential to understanding the observation.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  public value?: (fhir.Quantity|fhir.CodeableConcept|fhir.FhirString|fhir.Range|fhir.Ratio|fhir.SampledData|fhir.Attachment|fhir.FhirTime|fhir.FhirDateTime|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Observation.component.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * For many results it is necessary to handle exceptional values in measurements.
   */
  public dataAbsentReason?: fhir.CodeableConcept|undefined;
  /**
   * Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
   */
  public referenceRange: fhir.ObservationReferenceRange[];
  /**
   * Default constructor for ObservationComponent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationComponentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
    if (source['value']) { this.value = source.value; }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueCodeableConcept']) { this.value = new fhir.CodeableConcept(source.valueCodeableConcept); }
    else if (source['valueString']) { this.value = new fhir.FhirString({value: source.valueString}); }
    else if (source['valueRange']) { this.value = new fhir.Range(source.valueRange); }
    else if (source['valueRatio']) { this.value = new fhir.Ratio(source.valueRatio); }
    else if (source['valueSampledData']) { this.value = new fhir.SampledData(source.valueSampledData); }
    else if (source['valueAttachment']) { this.value = new fhir.Attachment(source.valueAttachment); }
    else if (source['valueTime']) { this.value = new fhir.FhirTime({value: source.valueTime}); }
    else if (source['valueDateTime']) { this.value = new fhir.FhirDateTime({value: source.valueDateTime}); }
    else if (source['valuePeriod']) { this.value = new fhir.Period(source.valuePeriod); }
    if (source['dataAbsentReason']) { this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason); }
    if (source['referenceRange']) { this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x)); }
    else { this.referenceRange = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Observation.component' }
    this.vRS('code',exp)
    this.vOS('value',exp)
    this.vOS('dataAbsentReason',exp)
    this.vOA('referenceRange',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Observation type.
 */
export interface ObservationArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Observation"|undefined;
  /**
   * Allows observations to be distinguished and referenced.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * Need to track the status of individual results. Some results are finalized before the whole report is finalized.
   */
  status: fhir.FhirCode<ObservationStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Observation.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * Knowing what kind of observation is being made is essential to understanding the observation.
   */
  code: fhir.CodeableConceptArgs|null;
  /**
   * Observations have no value if you don't know who or what they're about.
   */
  subject?: fhir.ReferenceArgs|undefined;
  /**
   * For some observations it may be important to know the link between an observation and a particular encounter.
   */
  encounter?: fhir.ReferenceArgs|undefined;
  /**
   * Knowing when an observation was deemed true is important to its relevance as well as determining trends.
   */
  effective?: fhir.FhirDateTime|fhir.Period|undefined;
  /**
   * Knowing when an observation was deemed true is important to its relevance as well as determining trends.
   */
  effectiveDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Knowing when an observation was deemed true is important to its relevance as well as determining trends.
   */
  effectivePeriod?: fhir.PeriodArgs|undefined;
  /**
   * The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
   */
  issued?: fhir.FhirInstant|string|undefined;
  /**
   * Extended properties for primitive element: Observation.issued
   */
  _issued?:fhir.FhirElementArgs;
  /**
   * May give a degree of confidence in the observation and also indicates where follow-up questions should be directed.
   */
  performer?: fhir.ReferenceArgs[]|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  value?: fhir.Quantity|fhir.CodeableConcept|fhir.FhirString|fhir.Range|fhir.Ratio|fhir.SampledData|fhir.Attachment|fhir.FhirTime|fhir.FhirDateTime|fhir.Period|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueQuantity?: fhir.QuantityArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueString?: fhir.FhirString|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueRange?: fhir.RangeArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueRatio?: fhir.RatioArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueSampledData?: fhir.SampledDataArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueTime?: fhir.FhirTime|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valueDateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  valuePeriod?: fhir.PeriodArgs|undefined;
  /**
   * For many results it is necessary to handle exceptional values in measurements.
   */
  dataAbsentReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * For some results, particularly numeric results, an interpretation is necessary to fully understand the significance of a result.
   */
  interpretation?: fhir.CodeableConceptArgs|undefined;
  /**
   * Need to be able to provide free text additional information.
   */
  comments?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Observation.comments
   */
  _comments?:fhir.FhirElementArgs;
  /**
   * Knowing where the observation is made is important for tracking if multiple sites are possible.
   */
  bodySite?: fhir.CodeableConceptArgs|undefined;
  /**
   * In some cases, method can impact results and is thus used for determining whether results can be compared or determining significance of results.
   */
  method?: fhir.CodeableConceptArgs|undefined;
  /**
   * The specimen that was used when this observation was made.
   */
  specimen?: fhir.ReferenceArgs|undefined;
  /**
   * The device used to generate the observation data.
   */
  device?: fhir.ReferenceArgs|undefined;
  /**
   * Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
   */
  referenceRange?: fhir.ObservationReferenceRangeArgs[]|undefined;
  /**
   * Normally, an observation will have either a value or a set of related observations. A few observations (e.g. Apgar score) may have both a value and a set of related observations or sometimes QuestionnaireResponse  from which the measure is derived.
   */
  related?: fhir.ObservationRelatedArgs[]|undefined;
  /**
   * Component observations share the same attributes in the Observation resource as the primary observation and are always treated a part of a single observation (they are not separable).   However, the reference range for the primary observation value is not inherited by the component values and is required when appropriate for each component observation.
   */
  component?: fhir.ObservationComponentArgs[]|undefined;
}

/**
 * Measurements and simple assertions made about a patient, device or other subject.
 */
export class Observation extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Observation';
  /**
   * Resource Type Name
   */
  public override resourceType: "Observation";
  /**
   * Allows observations to be distinguished and referenced.
   */
  public identifier: fhir.Identifier[];
  /**
   * Need to track the status of individual results. Some results are finalized before the whole report is finalized.
   */
  public status: fhir.FhirCode<ObservationStatusCodeType>|null;
  /**
   * A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * Knowing what kind of observation is being made is essential to understanding the observation.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * Observations have no value if you don't know who or what they're about.
   */
  public subject?: fhir.Reference|undefined;
  /**
   * For some observations it may be important to know the link between an observation and a particular encounter.
   */
  public encounter?: fhir.Reference|undefined;
  /**
   * Knowing when an observation was deemed true is important to its relevance as well as determining trends.
   */
  public effective?: (fhir.FhirDateTime|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Observation.effective[x]
   */
  protected static readonly _fts_effectiveIsChoice:true = true;
  /**
   * The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
   */
  public issued?: fhir.FhirInstant|undefined;
  /**
   * May give a degree of confidence in the observation and also indicates where follow-up questions should be directed.
   */
  public performer: fhir.Reference[];
  /**
   * An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
   */
  public value?: (fhir.Quantity|fhir.CodeableConcept|fhir.FhirString|fhir.Range|fhir.Ratio|fhir.SampledData|fhir.Attachment|fhir.FhirTime|fhir.FhirDateTime|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Observation.value[x]
   */
  protected static readonly _fts_valueIsChoice:true = true;
  /**
   * For many results it is necessary to handle exceptional values in measurements.
   */
  public dataAbsentReason?: fhir.CodeableConcept|undefined;
  /**
   * For some results, particularly numeric results, an interpretation is necessary to fully understand the significance of a result.
   */
  public interpretation?: fhir.CodeableConcept|undefined;
  /**
   * Need to be able to provide free text additional information.
   */
  public comments?: fhir.FhirString|undefined;
  /**
   * Knowing where the observation is made is important for tracking if multiple sites are possible.
   */
  public bodySite?: fhir.CodeableConcept|undefined;
  /**
   * In some cases, method can impact results and is thus used for determining whether results can be compared or determining significance of results.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * The specimen that was used when this observation was made.
   */
  public specimen?: fhir.Reference|undefined;
  /**
   * The device used to generate the observation data.
   */
  public device?: fhir.Reference|undefined;
  /**
   * Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
   */
  public referenceRange: fhir.ObservationReferenceRange[];
  /**
   * Normally, an observation will have either a value or a set of related observations. A few observations (e.g. Apgar score) may have both a value and a set of related observations or sometimes QuestionnaireResponse  from which the measure is derived.
   */
  public related: fhir.ObservationRelated[];
  /**
   * Component observations share the same attributes in the Observation resource as the primary observation and are always treated a part of a single observation (they are not separable).   However, the reference range for the primary observation value is not inherited by the component values and is required when appropriate for each component observation.
   */
  public component: fhir.ObservationComponent[];
  /**
   * Default constructor for Observation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ObservationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Observation';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['status']) { this.status = new fhir.FhirCode<ObservationStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<ObservationStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    else { this.code = null; }
    if (source['subject']) { this.subject = new fhir.Reference(source.subject); }
    if (source['encounter']) { this.encounter = new fhir.Reference(source.encounter); }
    if (source['effective']) { this.effective = source.effective; }
    else if (source['effectiveDateTime']) { this.effective = new fhir.FhirDateTime({value: source.effectiveDateTime}); }
    else if (source['effectivePeriod']) { this.effective = new fhir.Period(source.effectivePeriod); }
    if (source['issued']) { this.issued = new fhir.FhirInstant({value: source.issued}); }
    if (source['_issued']) {
      if (this.issued) { this.issued.addExtendedProperties(source._issued!); }
      else { this.issued = new fhir.FhirInstant(source._issued as Partial<fhir.FhirInstantArgs>); }
    }
    if (source['performer']) { this.performer = source.performer.map((x) => new fhir.Reference(x)); }
    else { this.performer = []; }
    if (source['value']) { this.value = source.value; }
    else if (source['valueQuantity']) { this.value = new fhir.Quantity(source.valueQuantity); }
    else if (source['valueCodeableConcept']) { this.value = new fhir.CodeableConcept(source.valueCodeableConcept); }
    else if (source['valueString']) { this.value = new fhir.FhirString({value: source.valueString}); }
    else if (source['valueRange']) { this.value = new fhir.Range(source.valueRange); }
    else if (source['valueRatio']) { this.value = new fhir.Ratio(source.valueRatio); }
    else if (source['valueSampledData']) { this.value = new fhir.SampledData(source.valueSampledData); }
    else if (source['valueAttachment']) { this.value = new fhir.Attachment(source.valueAttachment); }
    else if (source['valueTime']) { this.value = new fhir.FhirTime({value: source.valueTime}); }
    else if (source['valueDateTime']) { this.value = new fhir.FhirDateTime({value: source.valueDateTime}); }
    else if (source['valuePeriod']) { this.value = new fhir.Period(source.valuePeriod); }
    if (source['dataAbsentReason']) { this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason); }
    if (source['interpretation']) { this.interpretation = new fhir.CodeableConcept(source.interpretation); }
    if (source['comments']) { this.comments = new fhir.FhirString({value: source.comments}); }
    if (source['_comments']) {
      if (this.comments) { this.comments.addExtendedProperties(source._comments!); }
      else { this.comments = new fhir.FhirString(source._comments as Partial<fhir.FhirStringArgs>); }
    }
    if (source['bodySite']) { this.bodySite = new fhir.CodeableConcept(source.bodySite); }
    if (source['method']) { this.method = new fhir.CodeableConcept(source.method); }
    if (source['specimen']) { this.specimen = new fhir.Reference(source.specimen); }
    if (source['device']) { this.device = new fhir.Reference(source.device); }
    if (source['referenceRange']) { this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x)); }
    else { this.referenceRange = []; }
    if (source['related']) { this.related = source.related.map((x) => new fhir.ObservationRelated(x)); }
    else { this.related = []; }
    if (source['component']) { this.component = source.component.map((x) => new fhir.ObservationComponent(x)); }
    else { this.component = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Observation' }
    this.vRS('resourceType',exp)
    this.vOA('identifier',exp)
    this.vRSV('status',exp,'ObservationStatus',ObservationStatusVsValidation,'r')
    this.vOS('category',exp)
    this.vRS('code',exp)
    this.vOS('subject',exp)
    this.vOS('encounter',exp)
    this.vOS('effective',exp)
    this.vOS('issued',exp)
    this.vOA('performer',exp)
    this.vOS('value',exp)
    this.vOS('dataAbsentReason',exp)
    this.vOS('interpretation',exp)
    this.vOS('comments',exp)
    this.vOS('bodySite',exp)
    this.vOS('method',exp)
    this.vOS('specimen',exp)
    this.vOS('device',exp)
    this.vOA('referenceRange',exp)
    this.vOA('related',exp)
    this.vOA('component',exp)
    return issues;
  }
}
