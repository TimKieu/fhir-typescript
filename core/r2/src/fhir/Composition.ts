// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Composition

import * as fhir from '../fhir.js';

// @ts-ignore
import { CompositionAttestationModeCodes,  CompositionAttestationModeCodeType } from '../fhirValueSets/CompositionAttestationModeCodes.js';
// @ts-ignore
import { CompositionAttestationModeVsValidation } from '../fhirValueSets/CompositionAttestationModeVsValidation.js';
// @ts-ignore
import { ListModeCodes,  ListModeCodeType } from '../fhirValueSets/ListModeCodes.js';
// @ts-ignore
import { ListModeVsValidation } from '../fhirValueSets/ListModeVsValidation.js';
// @ts-ignore
import { CompositionStatusCodes,  CompositionStatusCodeType } from '../fhirValueSets/CompositionStatusCodes.js';
// @ts-ignore
import { CompositionStatusVsValidation } from '../fhirValueSets/CompositionStatusVsValidation.js';
// @ts-ignore
import { V3ConfidentialityCodes,  V3ConfidentialityCodeType } from '../fhirValueSets/V3ConfidentialityCodes.js';
// @ts-ignore
import { V3ConfidentialityVsValidation } from '../fhirValueSets/V3ConfidentialityVsValidation.js';
/**
 * Valid arguments for the CompositionAttester type.
 */
export interface CompositionAttesterArgs extends fhir.BackboneElementArgs {
  /**
   * Indicates the level of authority of the attestation.
   */
  mode: fhir.FhirCode<CompositionAttestationModeCodeType>[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: Composition.attester.mode
   */
  _mode?:(fhir.FhirElementArgs|null)[];
  /**
   * Identifies when the information in the composition was deemed accurate.  (Things may have changed since then.).
   */
  time?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Composition.attester.time
   */
  _time?:fhir.FhirElementArgs;
  /**
   * Identifies who has taken on the responsibility for accuracy of the composition content.
   */
  party?: fhir.ReferenceArgs|undefined;
}

/**
 * Identifies responsibility for the accuracy of the composition content.
 */
export class CompositionAttester extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'CompositionAttester';
  /**
   * Indicates the level of authority of the attestation.
   */
  public mode: fhir.FhirCode<CompositionAttestationModeCodeType>[];
  /**
   * Identifies when the information in the composition was deemed accurate.  (Things may have changed since then.).
   */
  public time?: fhir.FhirDateTime|undefined;
  /**
   * Identifies who has taken on the responsibility for accuracy of the composition content.
   */
  public party?: fhir.Reference|undefined;
  /**
   * Default constructor for CompositionAttester - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CompositionAttesterArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['mode']) { this.mode = source.mode.map((x) => new fhir.FhirCode<CompositionAttestationModeCodeType>({value: x})); }
    else { this.mode = []; }
    if (source['_mode']) {
      source._mode.forEach((x,i) => {
        if (this.mode.length >= i) { if (x) { this.mode[i].addExtendedProperties(x); } }
        else { if (x) { this.mode.push(new fhir.FhirCode<CompositionAttestationModeCodeType>(x as Partial<fhir.FhirCode>)); } }
      });
    }
    if (source['time']) { this.time = new fhir.FhirDateTime({value: source.time}); }
    if (source['_time']) {
      if (this.time) { this.time.addExtendedProperties(source._time!); }
      else { this.time = new fhir.FhirDateTime(source._time as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['party']) { this.party = new fhir.Reference(source.party); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Composition.attester' }
    this.vRAV('mode',exp,'CompositionAttestationMode',CompositionAttestationModeVsValidation,'r')
    this.vOS('time',exp)
    this.vOS('party',exp)
    return issues;
  }
}
/**
 * Valid arguments for the CompositionEvent type.
 */
export interface CompositionEventArgs extends fhir.BackboneElementArgs {
  /**
   * This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
   */
  code?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
   */
  period?: fhir.PeriodArgs|undefined;
  /**
   * The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
   */
  detail?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Provides context for the composition and creates a linkage between a resource describing an event and the composition created describing the event.
 */
export class CompositionEvent extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'CompositionEvent';
  /**
   * This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
   */
  public code: fhir.CodeableConcept[];
  /**
   * The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
   */
  public period?: fhir.Period|undefined;
  /**
   * The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
   */
  public detail: fhir.Reference[];
  /**
   * Default constructor for CompositionEvent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CompositionEventArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = source.code.map((x) => new fhir.CodeableConcept(x)); }
    else { this.code = []; }
    if (source['period']) { this.period = new fhir.Period(source.period); }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.Reference(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Composition.event' }
    this.vOA('code',exp)
    this.vOS('period',exp)
    this.vOA('detail',exp)
    return issues;
  }
}
/**
 * Valid arguments for the CompositionSection type.
 */
export interface CompositionSectionArgs extends fhir.BackboneElementArgs {
  /**
   * Section headings are often standardized for different types of documents.  They give guidance to humans on how the document is organized.
   */
  title?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Composition.section.title
   */
  _title?:fhir.FhirElementArgs;
  /**
   * Provides computable standardized labels to topics within the document.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
   */
  text?: fhir.NarrativeArgs|undefined;
  /**
   * Sections are used in various ways, and it must be known in what way it is safe to use the entries in them.
   */
  mode?: fhir.FhirCode<ListModeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Composition.section.mode
   */
  _mode?:fhir.FhirElementArgs;
  /**
   * Important for presentation and rendering.  Lists may be sorted to place more important information first or to group related entries.
   */
  orderedBy?: fhir.CodeableConceptArgs|undefined;
  /**
   * A reference to the actual resource from which the narrative in the section is derived.
   */
  entry?: fhir.ReferenceArgs[]|undefined;
  /**
   * Allows capturing things like "none exist" or "not asked" which can be important for most lists.
   */
  emptyReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * A nested sub-section within this section.
   */
  section?: fhir.CompositionSectionArgs[]|undefined;
}

/**
 * The root of the sections that make up the composition.
 */
export class CompositionSection extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'CompositionSection';
  /**
   * Section headings are often standardized for different types of documents.  They give guidance to humans on how the document is organized.
   */
  public title?: fhir.FhirString|undefined;
  /**
   * Provides computable standardized labels to topics within the document.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
   */
  public text?: fhir.Narrative|undefined;
  /**
   * Sections are used in various ways, and it must be known in what way it is safe to use the entries in them.
   */
  public mode?: fhir.FhirCode<ListModeCodeType>|undefined;
  /**
   * Important for presentation and rendering.  Lists may be sorted to place more important information first or to group related entries.
   */
  public orderedBy?: fhir.CodeableConcept|undefined;
  /**
   * A reference to the actual resource from which the narrative in the section is derived.
   */
  public entry: fhir.Reference[];
  /**
   * Allows capturing things like "none exist" or "not asked" which can be important for most lists.
   */
  public emptyReason?: fhir.CodeableConcept|undefined;
  /**
   * A nested sub-section within this section.
   */
  public section: fhir.CompositionSection[];
  /**
   * Default constructor for CompositionSection - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CompositionSectionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['title']) { this.title = new fhir.FhirString({value: source.title}); }
    if (source['_title']) {
      if (this.title) { this.title.addExtendedProperties(source._title!); }
      else { this.title = new fhir.FhirString(source._title as Partial<fhir.FhirStringArgs>); }
    }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['text']) { this.text = new fhir.Narrative(source.text); }
    if (source['mode']) { this.mode = new fhir.FhirCode<ListModeCodeType>({value: source.mode}); }
    if (source['_mode']) {
      if (this.mode) { this.mode.addExtendedProperties(source._mode!); }
      else { this.mode = new fhir.FhirCode<ListModeCodeType>(source._mode as Partial<fhir.FhirCode>); }
    }
    if (source['orderedBy']) { this.orderedBy = new fhir.CodeableConcept(source.orderedBy); }
    if (source['entry']) { this.entry = source.entry.map((x) => new fhir.Reference(x)); }
    else { this.entry = []; }
    if (source['emptyReason']) { this.emptyReason = new fhir.CodeableConcept(source.emptyReason); }
    if (source['section']) { this.section = source.section.map((x) => new fhir.CompositionSection(x)); }
    else { this.section = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Composition.section' }
    this.vOS('title',exp)
    this.vOS('code',exp)
    this.vOS('text',exp)
    this.vOSV('mode',exp,'ListMode',ListModeVsValidation,'r')
    this.vOS('orderedBy',exp)
    this.vOA('entry',exp)
    this.vOS('emptyReason',exp)
    this.vOA('section',exp)
    return issues;
  }
}
/**
 * Valid arguments for the Composition type.
 */
export interface CompositionArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Composition"|undefined;
  /**
   * Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * dateTime is used for tracking, organizing versions and searching.
   */
  date: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Composition.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * Key metadata element describing the composition, used in searching/filtering.
   */
  type: fhir.CodeableConceptArgs|null;
  /**
   * Helps humans to assess whether the composition is of interest when viewing an index of compositions or documents.
   */
  class?: fhir.CodeableConceptArgs|undefined;
  /**
   * Official human-readable label for the composition.
   */
  title: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: Composition.title
   */
  _title?:fhir.FhirElementArgs;
  /**
   * Need to be able to mark interim, amended, or withdrawn compositions or documents.
   */
  status: fhir.FhirCode<CompositionStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Composition.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * The code specifying the level of confidentiality of the Composition.
   */
  confidentiality?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: Composition.confidentiality
   */
  _confidentiality?:fhir.FhirElementArgs;
  /**
   * Essential metadata for searching for the composition. Identifies who and/or what the composition/document is about.
   */
  subject: fhir.ReferenceArgs|null;
  /**
   * Identifies who is responsible for the content.
   */
  author: fhir.ReferenceArgs[]|null;
  /**
   * Identifies responsibility for the accuracy of the composition content.
   */
  attester?: fhir.CompositionAttesterArgs[]|undefined;
  /**
   * Identifies where to go to find the current version, where to report issues, etc.
   */
  custodian?: fhir.ReferenceArgs|undefined;
  /**
   * Provides context for the composition and creates a linkage between a resource describing an event and the composition created describing the event.
   */
  event?: fhir.CompositionEventArgs[]|undefined;
  /**
   * Provides context for the composition and supports searching.
   */
  encounter?: fhir.ReferenceArgs|undefined;
  /**
   * The root of the sections that make up the composition.
   */
  section?: fhir.CompositionSectionArgs[]|undefined;
}

/**
 * A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
 */
export class Composition extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Composition';
  /**
   * Resource Type Name
   */
  public override resourceType: "Composition";
  /**
   * Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * dateTime is used for tracking, organizing versions and searching.
   */
  public date: fhir.FhirDateTime|null;
  /**
   * Key metadata element describing the composition, used in searching/filtering.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * Helps humans to assess whether the composition is of interest when viewing an index of compositions or documents.
   */
  public class?: fhir.CodeableConcept|undefined;
  /**
   * Official human-readable label for the composition.
   */
  public title: fhir.FhirString|null;
  /**
   * Need to be able to mark interim, amended, or withdrawn compositions or documents.
   */
  public status: fhir.FhirCode<CompositionStatusCodeType>|null;
  /**
   * The code specifying the level of confidentiality of the Composition.
   */
  public confidentiality?: fhir.FhirCode|undefined;
  /**
   * Essential metadata for searching for the composition. Identifies who and/or what the composition/document is about.
   */
  public subject: fhir.Reference|null;
  /**
   * Identifies who is responsible for the content.
   */
  public author: fhir.Reference[];
  /**
   * Identifies responsibility for the accuracy of the composition content.
   */
  public attester: fhir.CompositionAttester[];
  /**
   * Identifies where to go to find the current version, where to report issues, etc.
   */
  public custodian?: fhir.Reference|undefined;
  /**
   * Provides context for the composition and creates a linkage between a resource describing an event and the composition created describing the event.
   */
  public event: fhir.CompositionEvent[];
  /**
   * Provides context for the composition and supports searching.
   */
  public encounter?: fhir.Reference|undefined;
  /**
   * The root of the sections that make up the composition.
   */
  public section: fhir.CompositionSection[];
  /**
   * Default constructor for Composition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CompositionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Composition';
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
    else { this.date = null; }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    else { this.type = null; }
    if (source['class']) { this.class = new fhir.CodeableConcept(source.class); }
    if (source['title']) { this.title = new fhir.FhirString({value: source.title}); }
    else { this.title = null; }
    if (source['_title']) {
      if (this.title) { this.title.addExtendedProperties(source._title!); }
      else { this.title = new fhir.FhirString(source._title as Partial<fhir.FhirStringArgs>); }
    }
    if (source['status']) { this.status = new fhir.FhirCode<CompositionStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<CompositionStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['confidentiality']) { this.confidentiality = new fhir.FhirCode({value: source.confidentiality}); }
    if (source['_confidentiality']) {
      if (this.confidentiality) { this.confidentiality.addExtendedProperties(source._confidentiality!); }
      else { this.confidentiality = new fhir.FhirCode(source._confidentiality as Partial<fhir.FhirCodeArgs>); }
    }
    if (source['subject']) { this.subject = new fhir.Reference(source.subject); }
    else { this.subject = null; }
    if (source['author']) { this.author = source.author.map((x) => new fhir.Reference(x)); }
    else { this.author = []; }
    if (source['attester']) { this.attester = source.attester.map((x) => new fhir.CompositionAttester(x)); }
    else { this.attester = []; }
    if (source['custodian']) { this.custodian = new fhir.Reference(source.custodian); }
    if (source['event']) { this.event = source.event.map((x) => new fhir.CompositionEvent(x)); }
    else { this.event = []; }
    if (source['encounter']) { this.encounter = new fhir.Reference(source.encounter); }
    if (source['section']) { this.section = source.section.map((x) => new fhir.CompositionSection(x)); }
    else { this.section = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Composition' }
    this.vRS('resourceType',exp)
    this.vOS('identifier',exp)
    this.vRS('date',exp)
    this.vRS('type',exp)
    this.vOS('class',exp)
    this.vRS('title',exp)
    this.vRSV('status',exp,'CompositionStatus',CompositionStatusVsValidation,'r')
    this.vOSV('confidentiality',exp,'V3Confidentiality',V3ConfidentialityVsValidation,'r')
    this.vRS('subject',exp)
    this.vRA('author',exp)
    this.vOA('attester',exp)
    this.vOS('custodian',exp)
    this.vOA('event',exp)
    this.vOS('encounter',exp)
    this.vOA('section',exp)
    return issues;
  }
}
