// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Timing

import * as fhir from '../fhir.js';

// @ts-ignore
import { UnitsOfTimeCodes,  UnitsOfTimeCodeType } from '../fhirValueSets/UnitsOfTimeCodes.js';
// @ts-ignore
import { UnitsOfTimeVsValidation } from '../fhirValueSets/UnitsOfTimeVsValidation.js';
// @ts-ignore
import { EventTimingCodes,  EventTimingCodeType } from '../fhirValueSets/EventTimingCodes.js';
// @ts-ignore
import { EventTimingVsValidation } from '../fhirValueSets/EventTimingVsValidation.js';
/**
 * Valid arguments for the TimingRepeat type.
 */
export interface TimingRepeatArgs extends fhir.FhirElementArgs {
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  bounds?: fhir.Quantity|fhir.Range|fhir.Period|undefined;
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsRange?: fhir.RangeArgs|undefined;
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsPeriod?: fhir.PeriodArgs|undefined;
  /**
   * Repetitions may be limited by end time or total occurrences.
   */
  count?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.count
   */
  _count?:fhir.FhirElementArgs;
  /**
   * Some activities are not instantaneous and need to be maintained for a period of time.
   */
  duration?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.duration
   */
  _duration?:fhir.FhirElementArgs;
  /**
   * Some activities are not instantaneous and need to be maintained for a period of time.
   */
  durationMax?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.durationMax
   */
  _durationMax?:fhir.FhirElementArgs;
  /**
   * The units of time for the duration, in UCUM units.
   */
  durationUnits?: fhir.FhirCode<UnitsOfTimeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.durationUnits
   */
  _durationUnits?:fhir.FhirElementArgs;
  /**
   * The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
   */
  frequency?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.frequency
   */
  _frequency?:fhir.FhirElementArgs;
  /**
   * If present, indicates that the frequency is a range - so repeat between [frequency] and [frequencyMax] times within the period or period range.
   */
  frequencyMax?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.frequencyMax
   */
  _frequencyMax?:fhir.FhirElementArgs;
  /**
   * Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period.
   */
  period?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.period
   */
  _period?:fhir.FhirElementArgs;
  /**
   * If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   */
  periodMax?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.periodMax
   */
  _periodMax?:fhir.FhirElementArgs;
  /**
   * The units of time for the period in UCUM units.
   */
  periodUnits?: fhir.FhirCode<UnitsOfTimeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.periodUnits
   */
  _periodUnits?:fhir.FhirElementArgs;
  /**
   * Timings are frequently determined by occurrences such as waking, eating and sleep.
   */
  when?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: Timing.repeat.when
   */
  _when?:fhir.FhirElementArgs;
}

/**
 * Many timing schedules are determined by regular repetitions.
 */
export class TimingRepeat extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TimingRepeat';
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  public bounds?: (fhir.Quantity|fhir.Range|fhir.Period)|undefined;
  /**
   * Internal flag to properly serialize choice-type element Timing.repeat.bounds[x]
   */
  protected static readonly _fts_boundsIsChoice:true = true;
  /**
   * Repetitions may be limited by end time or total occurrences.
   */
  public count?: fhir.FhirInteger|undefined;
  /**
   * Some activities are not instantaneous and need to be maintained for a period of time.
   */
  public duration?: fhir.FhirDecimal|undefined;
  /**
   * Some activities are not instantaneous and need to be maintained for a period of time.
   */
  public durationMax?: fhir.FhirDecimal|undefined;
  /**
   * The units of time for the duration, in UCUM units.
   */
  public durationUnits?: fhir.FhirCode<UnitsOfTimeCodeType>|undefined;
  /**
   * The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
   */
  public frequency?: fhir.FhirInteger|undefined;
  /**
   * If present, indicates that the frequency is a range - so repeat between [frequency] and [frequencyMax] times within the period or period range.
   */
  public frequencyMax?: fhir.FhirInteger|undefined;
  /**
   * Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period.
   */
  public period?: fhir.FhirDecimal|undefined;
  /**
   * If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   */
  public periodMax?: fhir.FhirDecimal|undefined;
  /**
   * The units of time for the period in UCUM units.
   */
  public periodUnits?: fhir.FhirCode<UnitsOfTimeCodeType>|undefined;
  /**
   * Timings are frequently determined by occurrences such as waking, eating and sleep.
   */
  public when?: fhir.FhirCode|undefined;
  /**
   * Default constructor for TimingRepeat - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TimingRepeatArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['bounds']) { this.bounds = source.bounds; }
    else if (source['boundsQuantity']) { this.bounds = new fhir.Quantity(source.boundsQuantity, options); }
    else if (source['boundsRange']) { this.bounds = new fhir.Range(source.boundsRange, options); }
    else if (source['boundsPeriod']) { this.bounds = new fhir.Period(source.boundsPeriod, options); }
    if (source['count'] !== undefined) { this.count = new fhir.FhirInteger({value: source.count}, options); }
    if (source['_count']) {
      if (this.count) { this.count.addExtendedProperties(source._count!); }
      else { this.count = new fhir.FhirInteger(source._count as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['duration'] !== undefined) { this.duration = new fhir.FhirDecimal({value: source.duration}, options); }
    if (source['_duration']) {
      if (this.duration) { this.duration.addExtendedProperties(source._duration!); }
      else { this.duration = new fhir.FhirDecimal(source._duration as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['durationMax'] !== undefined) { this.durationMax = new fhir.FhirDecimal({value: source.durationMax}, options); }
    if (source['_durationMax']) {
      if (this.durationMax) { this.durationMax.addExtendedProperties(source._durationMax!); }
      else { this.durationMax = new fhir.FhirDecimal(source._durationMax as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['durationUnits'] !== undefined) { this.durationUnits = new fhir.FhirCode<UnitsOfTimeCodeType>({value: source.durationUnits}, options); }
    if (source['_durationUnits']) {
      if (this.durationUnits) { this.durationUnits.addExtendedProperties(source._durationUnits!); }
      else { this.durationUnits = new fhir.FhirCode<UnitsOfTimeCodeType>(source._durationUnits as Partial<fhir.FhirCode>, options); }
    }
    if (source['frequency'] !== undefined) { this.frequency = new fhir.FhirInteger({value: source.frequency}, options); }
    if (source['_frequency']) {
      if (this.frequency) { this.frequency.addExtendedProperties(source._frequency!); }
      else { this.frequency = new fhir.FhirInteger(source._frequency as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['frequencyMax'] !== undefined) { this.frequencyMax = new fhir.FhirInteger({value: source.frequencyMax}, options); }
    if (source['_frequencyMax']) {
      if (this.frequencyMax) { this.frequencyMax.addExtendedProperties(source._frequencyMax!); }
      else { this.frequencyMax = new fhir.FhirInteger(source._frequencyMax as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['period'] !== undefined) { this.period = new fhir.FhirDecimal({value: source.period}, options); }
    if (source['_period']) {
      if (this.period) { this.period.addExtendedProperties(source._period!); }
      else { this.period = new fhir.FhirDecimal(source._period as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['periodMax'] !== undefined) { this.periodMax = new fhir.FhirDecimal({value: source.periodMax}, options); }
    if (source['_periodMax']) {
      if (this.periodMax) { this.periodMax.addExtendedProperties(source._periodMax!); }
      else { this.periodMax = new fhir.FhirDecimal(source._periodMax as Partial<fhir.FhirDecimalArgs>, options); }
    }
    if (source['periodUnits'] !== undefined) { this.periodUnits = new fhir.FhirCode<UnitsOfTimeCodeType>({value: source.periodUnits}, options); }
    if (source['_periodUnits']) {
      if (this.periodUnits) { this.periodUnits.addExtendedProperties(source._periodUnits!); }
      else { this.periodUnits = new fhir.FhirCode<UnitsOfTimeCodeType>(source._periodUnits as Partial<fhir.FhirCode>, options); }
    }
    if (source['when'] !== undefined) { this.when = new fhir.FhirCode({value: source.when}, options); }
    if (source['_when']) {
      if (this.when) { this.when.addExtendedProperties(source._when!); }
      else { this.when = new fhir.FhirCode(source._when as Partial<fhir.FhirCodeArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Timing.repeat' }
    iss.push(...this.vOS('bounds',exp));
    iss.push(...this.vOS('count',exp));
    iss.push(...this.vOS('duration',exp));
    iss.push(...this.vOS('durationMax',exp));
    iss.push(...this.vOSV('durationUnits',exp,'UnitsOfTime',UnitsOfTimeVsValidation,'r'));
    iss.push(...this.vOS('frequency',exp));
    iss.push(...this.vOS('frequencyMax',exp));
    iss.push(...this.vOS('period',exp));
    iss.push(...this.vOS('periodMax',exp));
    iss.push(...this.vOSV('periodUnits',exp,'UnitsOfTime',UnitsOfTimeVsValidation,'r'));
    iss.push(...this.vOSV('when',exp,'EventTiming',EventTimingVsValidation,'r'));
    return iss;
  }
}
/**
 * Valid arguments for the Timing type.
 */
export interface TimingArgs extends fhir.FhirElementArgs {
  /**
   * In an MAR, for instance, you need to take a general specification, and turn it into a precise specification.
   */
  event?: fhir.FhirDateTime[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: Timing.event
   */
  _event?:(fhir.FhirElementArgs|null)[];
  /**
   * Many timing schedules are determined by regular repetitions.
   */
  repeat?: fhir.TimingRepeatArgs|undefined;
  /**
   * A code for the timing pattern. Some codes such as BID are ubiquitous, but many institutions define their own additional codes.
   */
  code?: fhir.CodeableConceptArgs|undefined;
}

/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds.
 */
export class Timing extends fhir.FhirElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Timing';
  /**
   * In an MAR, for instance, you need to take a general specification, and turn it into a precise specification.
   */
  public event: fhir.FhirDateTime[];
  /**
   * Many timing schedules are determined by regular repetitions.
   */
  public repeat?: fhir.TimingRepeat|undefined;
  /**
   * A code for the timing pattern. Some codes such as BID are ubiquitous, but many institutions define their own additional codes.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for Timing - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TimingArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['event'] !== undefined) { this.event = source.event.map((x) => new fhir.FhirDateTime({value: x}, options)); }
    else { this.event = []; }
    if (source['_event']) {
      source._event.forEach((x,i) => {
        if (this.event.length >= i) { if (x) { this.event[i].addExtendedProperties(x); } }
        else { if (x) { this.event.push(new fhir.FhirDateTime(x as Partial<fhir.FhirDateTimeArgs>)); } }
      });
    }
    if (source['repeat']) { this.repeat = new fhir.TimingRepeat(source.repeat, options); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Timing' }
    iss.push(...this.vOA('event',exp));
    iss.push(...this.vOS('repeat',exp));
    iss.push(...this.vOS('code',exp));
    return iss;
  }
}
