// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: ClaimResponse

import * as fhir from '../fhir.js';

// @ts-ignore
import { NoteTypeCodes,  NoteTypeCodeType } from '../fhirValueSets/NoteTypeCodes.js';
// @ts-ignore
import { NoteTypeVsValidation } from '../fhirValueSets/NoteTypeVsValidation.js';
// @ts-ignore
import { RemittanceOutcomeCodes,  RemittanceOutcomeCodeType } from '../fhirValueSets/RemittanceOutcomeCodes.js';
// @ts-ignore
import { RemittanceOutcomeVsValidation } from '../fhirValueSets/RemittanceOutcomeVsValidation.js';
/**
 * Valid arguments for the ClaimResponseItemAdjudication type.
 */
export interface ClaimResponseItemAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  code: fhir.CodingArgs|null;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.QuantityArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudications results.
 */
export class ClaimResponseItemAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public code: fhir.Coding|null;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseItemAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.adjudication' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetailAdjudication type.
 */
export interface ClaimResponseItemDetailAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  code: fhir.CodingArgs|null;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.QuantityArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudications results.
 */
export class ClaimResponseItemDetailAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetailAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public code: fhir.Coding|null;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseItemDetailAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail.adjudication' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetailSubDetailAdjudication type.
 */
export interface ClaimResponseItemDetailSubDetailAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  code: fhir.CodingArgs|null;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.QuantityArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.subDetail.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudications results.
 */
export class ClaimResponseItemDetailSubDetailAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetailSubDetailAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public code: fhir.Coding|null;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseItemDetailSubDetailAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailSubDetailAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail.subDetail.adjudication' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetailSubDetail type.
 */
export interface ClaimResponseItemDetailSubDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.subDetail.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemDetailSubDetailAdjudicationArgs[]|undefined;
}

/**
 * The third tier service adjudications for submitted services.
 */
export class ClaimResponseItemDetailSubDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetailSubDetail';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemDetailSubDetailAdjudication[];
  /**
   * Default constructor for ClaimResponseItemDetailSubDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailSubDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemDetailSubDetailAdjudication(x)); }
    else { this.adjudication = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail.subDetail' }
    iss.push(...this.vRS('sequenceLinkId',exp));
    iss.push(...this.vOA('adjudication',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseItemDetail type.
 */
export interface ClaimResponseItemDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.detail.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemDetailAdjudicationArgs[]|undefined;
  /**
   * The third tier service adjudications for submitted services.
   */
  subDetail?: fhir.ClaimResponseItemDetailSubDetailArgs[]|undefined;
}

/**
 * The second tier service adjudications for submitted services.
 */
export class ClaimResponseItemDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItemDetail';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemDetailAdjudication[];
  /**
   * The third tier service adjudications for submitted services.
   */
  public subDetail: fhir.ClaimResponseItemDetailSubDetail[];
  /**
   * Default constructor for ClaimResponseItemDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemDetailAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['subDetail']) { this.subDetail = source.subDetail.map((x) => new fhir.ClaimResponseItemDetailSubDetail(x)); }
    else { this.subDetail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item.detail' }
    iss.push(...this.vRS('sequenceLinkId',exp));
    iss.push(...this.vOA('adjudication',exp));
    iss.push(...this.vOA('subDetail',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseItem type.
 */
export interface ClaimResponseItemArgs extends fhir.BackboneElementArgs {
  /**
   * A service line number.
   */
  sequenceLinkId: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumber?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.item.noteNumber
   */
  _noteNumber?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseItemAdjudicationArgs[]|undefined;
  /**
   * The second tier service adjudications for submitted services.
   */
  detail?: fhir.ClaimResponseItemDetailArgs[]|undefined;
}

/**
 * The first tier service adjudications for submitted services.
 */
export class ClaimResponseItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseItem';
  /**
   * A service line number.
   */
  public sequenceLinkId: fhir.FhirPositiveInt|null;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumber: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseItemAdjudication[];
  /**
   * The second tier service adjudications for submitted services.
   */
  public detail: fhir.ClaimResponseItemDetail[];
  /**
   * Default constructor for ClaimResponseItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    else { this.sequenceLinkId = null; }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['noteNumber']) { this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumber = []; }
    if (source['_noteNumber']) {
      source._noteNumber.forEach((x,i) => {
        if (this.noteNumber.length >= i) { if (x) { this.noteNumber[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumber.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseItemAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.ClaimResponseItemDetail(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.item' }
    iss.push(...this.vRS('sequenceLinkId',exp));
    iss.push(...this.vOA('noteNumber',exp));
    iss.push(...this.vOA('adjudication',exp));
    iss.push(...this.vOA('detail',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItemAdjudication type.
 */
export interface ClaimResponseAddItemAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  code: fhir.CodingArgs|null;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.QuantityArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudications results.
 */
export class ClaimResponseAddItemAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItemAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public code: fhir.Coding|null;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseAddItemAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem.adjudication' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItemDetailAdjudication type.
 */
export interface ClaimResponseAddItemDetailAdjudicationArgs extends fhir.BackboneElementArgs {
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  code: fhir.CodingArgs|null;
  /**
   * Monetary amount associated with the code.
   */
  amount?: fhir.QuantityArgs|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  value?: fhir.FhirDecimal|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.detail.adjudication.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * The adjudications results.
 */
export class ClaimResponseAddItemDetailAdjudication extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItemDetailAdjudication';
  /**
   * Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
   */
  public code: fhir.Coding|null;
  /**
   * Monetary amount associated with the code.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
   */
  public value?: fhir.FhirDecimal|undefined;
  /**
   * Default constructor for ClaimResponseAddItemDetailAdjudication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemDetailAdjudicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
    if (source['value']) { this.value = new fhir.FhirDecimal({value: source.value}); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirDecimal(source._value as Partial<fhir.FhirDecimalArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem.detail.adjudication' }
    iss.push(...this.vRS('code',exp));
    iss.push(...this.vOS('amount',exp));
    iss.push(...this.vOS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItemDetail type.
 */
export interface ClaimResponseAddItemDetailArgs extends fhir.BackboneElementArgs {
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  service: fhir.CodingArgs|null;
  /**
   * The fee charged for the professional service or product..
   */
  fee?: fhir.QuantityArgs|undefined;
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseAddItemDetailAdjudicationArgs[]|undefined;
}

/**
 * The second tier service adjudications for payor added services.
 */
export class ClaimResponseAddItemDetail extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItemDetail';
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  public service: fhir.Coding|null;
  /**
   * The fee charged for the professional service or product..
   */
  public fee?: fhir.Quantity|undefined;
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseAddItemDetailAdjudication[];
  /**
   * Default constructor for ClaimResponseAddItemDetail - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemDetailArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['service']) { this.service = new fhir.Coding(source.service); }
    else { this.service = null; }
    if (source['fee']) { this.fee = new fhir.Quantity(source.fee); }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseAddItemDetailAdjudication(x)); }
    else { this.adjudication = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem.detail' }
    iss.push(...this.vRS('service',exp));
    iss.push(...this.vOS('fee',exp));
    iss.push(...this.vOA('adjudication',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseAddItem type.
 */
export interface ClaimResponseAddItemArgs extends fhir.BackboneElementArgs {
  /**
   * List of input service items which this service line is intended to replace.
   */
  sequenceLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.sequenceLinkId
   */
  _sequenceLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  service: fhir.CodingArgs|null;
  /**
   * The fee charged for the professional service or product..
   */
  fee?: fhir.QuantityArgs|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  noteNumberLinkId?: fhir.FhirPositiveInt[]|(number|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.addItem.noteNumberLinkId
   */
  _noteNumberLinkId?:(fhir.FhirElementArgs|null)[];
  /**
   * The adjudications results.
   */
  adjudication?: fhir.ClaimResponseAddItemAdjudicationArgs[]|undefined;
  /**
   * The second tier service adjudications for payor added services.
   */
  detail?: fhir.ClaimResponseAddItemDetailArgs[]|undefined;
}

/**
 * The first tier service adjudications for payor added services.
 */
export class ClaimResponseAddItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseAddItem';
  /**
   * List of input service items which this service line is intended to replace.
   */
  public sequenceLinkId: fhir.FhirPositiveInt[];
  /**
   * A code to indicate the Professional Service or Product supplied.
   */
  public service: fhir.Coding|null;
  /**
   * The fee charged for the professional service or product..
   */
  public fee?: fhir.Quantity|undefined;
  /**
   * A list of note references to the notes provided below.
   */
  public noteNumberLinkId: fhir.FhirPositiveInt[];
  /**
   * The adjudications results.
   */
  public adjudication: fhir.ClaimResponseAddItemAdjudication[];
  /**
   * The second tier service adjudications for payor added services.
   */
  public detail: fhir.ClaimResponseAddItemDetail[];
  /**
   * Default constructor for ClaimResponseAddItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseAddItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = source.sequenceLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.sequenceLinkId = []; }
    if (source['_sequenceLinkId']) {
      source._sequenceLinkId.forEach((x,i) => {
        if (this.sequenceLinkId.length >= i) { if (x) { this.sequenceLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.sequenceLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['service']) { this.service = new fhir.Coding(source.service); }
    else { this.service = null; }
    if (source['fee']) { this.fee = new fhir.Quantity(source.fee); }
    if (source['noteNumberLinkId']) { this.noteNumberLinkId = source.noteNumberLinkId.map((x) => new fhir.FhirPositiveInt({value: x})); }
    else { this.noteNumberLinkId = []; }
    if (source['_noteNumberLinkId']) {
      source._noteNumberLinkId.forEach((x,i) => {
        if (this.noteNumberLinkId.length >= i) { if (x) { this.noteNumberLinkId[i].addExtendedProperties(x); } }
        else { if (x) { this.noteNumberLinkId.push(new fhir.FhirPositiveInt(x as Partial<fhir.FhirPositiveIntArgs>)); } }
      });
    }
    if (source['adjudication']) { this.adjudication = source.adjudication.map((x) => new fhir.ClaimResponseAddItemAdjudication(x)); }
    else { this.adjudication = []; }
    if (source['detail']) { this.detail = source.detail.map((x) => new fhir.ClaimResponseAddItemDetail(x)); }
    else { this.detail = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.addItem' }
    iss.push(...this.vOA('sequenceLinkId',exp));
    iss.push(...this.vRS('service',exp));
    iss.push(...this.vOS('fee',exp));
    iss.push(...this.vOA('noteNumberLinkId',exp));
    iss.push(...this.vOA('adjudication',exp));
    iss.push(...this.vOA('detail',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseError type.
 */
export interface ClaimResponseErrorArgs extends fhir.BackboneElementArgs {
  /**
   * The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
   */
  sequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.sequenceLinkId
   */
  _sequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  detailSequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.detailSequenceLinkId
   */
  _detailSequenceLinkId?:fhir.FhirElementArgs;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  subdetailSequenceLinkId?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.error.subdetailSequenceLinkId
   */
  _subdetailSequenceLinkId?:fhir.FhirElementArgs;
  /**
   * An error code,froma specified code system, which details why the claim could not be adjudicated.
   */
  code: fhir.CodingArgs|null;
}

/**
 * Mutually exclusive with Services Provided (Item).
 */
export class ClaimResponseError extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseError';
  /**
   * The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
   */
  public sequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  public detailSequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
   */
  public subdetailSequenceLinkId?: fhir.FhirPositiveInt|undefined;
  /**
   * An error code,froma specified code system, which details why the claim could not be adjudicated.
   */
  public code: fhir.Coding|null;
  /**
   * Default constructor for ClaimResponseError - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseErrorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequenceLinkId']) { this.sequenceLinkId = new fhir.FhirPositiveInt({value: source.sequenceLinkId}); }
    if (source['_sequenceLinkId']) {
      if (this.sequenceLinkId) { this.sequenceLinkId.addExtendedProperties(source._sequenceLinkId!); }
      else { this.sequenceLinkId = new fhir.FhirPositiveInt(source._sequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['detailSequenceLinkId']) { this.detailSequenceLinkId = new fhir.FhirPositiveInt({value: source.detailSequenceLinkId}); }
    if (source['_detailSequenceLinkId']) {
      if (this.detailSequenceLinkId) { this.detailSequenceLinkId.addExtendedProperties(source._detailSequenceLinkId!); }
      else { this.detailSequenceLinkId = new fhir.FhirPositiveInt(source._detailSequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['subdetailSequenceLinkId']) { this.subdetailSequenceLinkId = new fhir.FhirPositiveInt({value: source.subdetailSequenceLinkId}); }
    if (source['_subdetailSequenceLinkId']) {
      if (this.subdetailSequenceLinkId) { this.subdetailSequenceLinkId.addExtendedProperties(source._subdetailSequenceLinkId!); }
      else { this.subdetailSequenceLinkId = new fhir.FhirPositiveInt(source._subdetailSequenceLinkId as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['code']) { this.code = new fhir.Coding(source.code); }
    else { this.code = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.error' }
    iss.push(...this.vOS('sequenceLinkId',exp));
    iss.push(...this.vOS('detailSequenceLinkId',exp));
    iss.push(...this.vOS('subdetailSequenceLinkId',exp));
    iss.push(...this.vRS('code',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseNote type.
 */
export interface ClaimResponseNoteArgs extends fhir.BackboneElementArgs {
  /**
   * An integer associated with each note which may be referred to from each service line item.
   */
  number?: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.note.number
   */
  _number?:fhir.FhirElementArgs;
  /**
   * The note purpose: Print/Display.
   */
  type?: fhir.CodingArgs|undefined;
  /**
   * The note text.
   */
  text?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.note.text
   */
  _text?:fhir.FhirElementArgs;
}

/**
 * Note text.
 */
export class ClaimResponseNote extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseNote';
  /**
   * An integer associated with each note which may be referred to from each service line item.
   */
  public number?: fhir.FhirPositiveInt|undefined;
  /**
   * The note purpose: Print/Display.
   */
  public type?: fhir.Coding|undefined;
  /**
   * The note text.
   */
  public text?: fhir.FhirString|undefined;
  /**
   * Default constructor for ClaimResponseNote - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseNoteArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['number']) { this.number = new fhir.FhirPositiveInt({value: source.number}); }
    if (source['_number']) {
      if (this.number) { this.number.addExtendedProperties(source._number!); }
      else { this.number = new fhir.FhirPositiveInt(source._number as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['type']) { this.type = new fhir.Coding(source.type); }
    if (source['text']) { this.text = new fhir.FhirString({value: source.text}); }
    if (source['_text']) {
      if (this.text) { this.text.addExtendedProperties(source._text!); }
      else { this.text = new fhir.FhirString(source._text as Partial<fhir.FhirStringArgs>); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.note' }
    iss.push(...this.vOS('number',exp));
    iss.push(...this.vOSV('type',exp,'NoteType',NoteTypeVsValidation,'r'));
    iss.push(...this.vOS('text',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponseCoverage type.
 */
export interface ClaimResponseCoverageArgs extends fhir.BackboneElementArgs {
  /**
   * To maintain order of the coverages.
   */
  sequence: fhir.FhirPositiveInt|number|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.coverage.sequence
   */
  _sequence?:fhir.FhirElementArgs;
  /**
   * To identify which coverage is being adjudicated.
   */
  focal: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.coverage.focal
   */
  _focal?:fhir.FhirElementArgs;
  /**
   * Need to identify the issuer to target for processing and for coordination of benefit processing.
   */
  coverage: fhir.ReferenceArgs|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  businessArrangement?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.coverage.businessArrangement
   */
  _businessArrangement?:fhir.FhirElementArgs;
  /**
   * To determine the relationship between the patient and the subscriber.
   */
  relationship: fhir.CodingArgs|null;
  /**
   * To provide any pre-determination or prior authorization reference.
   */
  preAuthRef?: fhir.FhirString[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.coverage.preAuthRef
   */
  _preAuthRef?:(fhir.FhirElementArgs|null)[];
  /**
   * Used by downstream payers to determine what balance remains and the net payable.
   */
  claimResponse?: fhir.ReferenceArgs|undefined;
  /**
   * Knowledge of the original version can inform the processing of this instance so that information which is processable by the originating system may be generated.
   */
  originalRuleset?: fhir.CodingArgs|undefined;
}

/**
 * Health care programs and insurers are significant payors of health service costs.
 */
export class ClaimResponseCoverage extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponseCoverage';
  /**
   * To maintain order of the coverages.
   */
  public sequence: fhir.FhirPositiveInt|null;
  /**
   * To identify which coverage is being adjudicated.
   */
  public focal: fhir.FhirBoolean|null;
  /**
   * Need to identify the issuer to target for processing and for coordination of benefit processing.
   */
  public coverage: fhir.Reference|null;
  /**
   * The contract number of a business agreement which describes the terms and conditions.
   */
  public businessArrangement?: fhir.FhirString|undefined;
  /**
   * To determine the relationship between the patient and the subscriber.
   */
  public relationship: fhir.Coding|null;
  /**
   * To provide any pre-determination or prior authorization reference.
   */
  public preAuthRef: fhir.FhirString[];
  /**
   * Used by downstream payers to determine what balance remains and the net payable.
   */
  public claimResponse?: fhir.Reference|undefined;
  /**
   * Knowledge of the original version can inform the processing of this instance so that information which is processable by the originating system may be generated.
   */
  public originalRuleset?: fhir.Coding|undefined;
  /**
   * Default constructor for ClaimResponseCoverage - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseCoverageArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['sequence']) { this.sequence = new fhir.FhirPositiveInt({value: source.sequence}); }
    else { this.sequence = null; }
    if (source['_sequence']) {
      if (this.sequence) { this.sequence.addExtendedProperties(source._sequence!); }
      else { this.sequence = new fhir.FhirPositiveInt(source._sequence as Partial<fhir.FhirPositiveIntArgs>); }
    }
    if (source['focal']) { this.focal = new fhir.FhirBoolean({value: source.focal}); }
    else { this.focal = null; }
    if (source['_focal']) {
      if (this.focal) { this.focal.addExtendedProperties(source._focal!); }
      else { this.focal = new fhir.FhirBoolean(source._focal as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['coverage']) { this.coverage = new fhir.Reference(source.coverage); }
    else { this.coverage = null; }
    if (source['businessArrangement']) { this.businessArrangement = new fhir.FhirString({value: source.businessArrangement}); }
    if (source['_businessArrangement']) {
      if (this.businessArrangement) { this.businessArrangement.addExtendedProperties(source._businessArrangement!); }
      else { this.businessArrangement = new fhir.FhirString(source._businessArrangement as Partial<fhir.FhirStringArgs>); }
    }
    if (source['relationship']) { this.relationship = new fhir.Coding(source.relationship); }
    else { this.relationship = null; }
    if (source['preAuthRef']) { this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({value: x})); }
    else { this.preAuthRef = []; }
    if (source['_preAuthRef']) {
      source._preAuthRef.forEach((x,i) => {
        if (this.preAuthRef.length >= i) { if (x) { this.preAuthRef[i].addExtendedProperties(x); } }
        else { if (x) { this.preAuthRef.push(new fhir.FhirString(x as Partial<fhir.FhirStringArgs>)); } }
      });
    }
    if (source['claimResponse']) { this.claimResponse = new fhir.Reference(source.claimResponse); }
    if (source['originalRuleset']) { this.originalRuleset = new fhir.Coding(source.originalRuleset); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse.coverage' }
    iss.push(...this.vRS('sequence',exp));
    iss.push(...this.vRS('focal',exp));
    iss.push(...this.vRS('coverage',exp));
    iss.push(...this.vOS('businessArrangement',exp));
    iss.push(...this.vRS('relationship',exp));
    iss.push(...this.vOA('preAuthRef',exp));
    iss.push(...this.vOS('claimResponse',exp));
    iss.push(...this.vOS('originalRuleset',exp));
    return iss;
  }
}
/**
 * Valid arguments for the ClaimResponse type.
 */
export interface ClaimResponseArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "ClaimResponse"|undefined;
  /**
   * The Response business identifier.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * Original request resource referrence.
   */
  request?: fhir.ReferenceArgs|undefined;
  /**
   * The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
   */
  ruleset?: fhir.CodingArgs|undefined;
  /**
   * Knowledge of the original version can inform the processing of this instance so that information which is processable by the originating system may be generated.
   */
  originalRuleset?: fhir.CodingArgs|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  created?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.created
   */
  _created?:fhir.FhirElementArgs;
  /**
   * The Insurer who produced this adjudicated response.
   */
  organization?: fhir.ReferenceArgs|undefined;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  requestProvider?: fhir.ReferenceArgs|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  requestOrganization?: fhir.ReferenceArgs|undefined;
  /**
   * Transaction status: error, complete.
   */
  outcome?: fhir.FhirCode<RemittanceOutcomeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.outcome
   */
  _outcome?:fhir.FhirElementArgs;
  /**
   * A description of the status of the adjudication.
   */
  disposition?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.disposition
   */
  _disposition?:fhir.FhirElementArgs;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  payeeType?: fhir.CodingArgs|undefined;
  /**
   * The first tier service adjudications for submitted services.
   */
  item?: fhir.ClaimResponseItemArgs[]|undefined;
  /**
   * The first tier service adjudications for payor added services.
   */
  addItem?: fhir.ClaimResponseAddItemArgs[]|undefined;
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  error?: fhir.ClaimResponseErrorArgs[]|undefined;
  /**
   * This is a check value that the receiver calculates and returns.
   */
  totalCost?: fhir.QuantityArgs|undefined;
  /**
   * The amount of deductible applied which was not allocated to any particular service line.
   */
  unallocDeductable?: fhir.QuantityArgs|undefined;
  /**
   * Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
   */
  totalBenefit?: fhir.QuantityArgs|undefined;
  /**
   * Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
   */
  paymentAdjustment?: fhir.QuantityArgs|undefined;
  /**
   * Reason for the payment adjustment.
   */
  paymentAdjustmentReason?: fhir.CodingArgs|undefined;
  /**
   * Estimated payment data.
   */
  paymentDate?: fhir.FhirDate|string|undefined;
  /**
   * Extended properties for primitive element: ClaimResponse.paymentDate
   */
  _paymentDate?:fhir.FhirElementArgs;
  /**
   * Payable less any payment adjustment.
   */
  paymentAmount?: fhir.QuantityArgs|undefined;
  /**
   * Payment identifier.
   */
  paymentRef?: fhir.IdentifierArgs|undefined;
  /**
   * Status of funds reservation (For provider, for Patient, None).
   */
  reserved?: fhir.CodingArgs|undefined;
  /**
   * The form to be used for printing the content.
   */
  form?: fhir.CodingArgs|undefined;
  /**
   * Note text.
   */
  note?: fhir.ClaimResponseNoteArgs[]|undefined;
  /**
   * Health care programs and insurers are significant payors of health service costs.
   */
  coverage?: fhir.ClaimResponseCoverageArgs[]|undefined;
}

/**
 * This resource provides the adjudication details from the processing of a Claim resource.
 */
export class ClaimResponse extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'ClaimResponse';
  /**
   * Resource Type Name
   */
  public override resourceType: "ClaimResponse";
  /**
   * The Response business identifier.
   */
  public identifier: fhir.Identifier[];
  /**
   * Original request resource referrence.
   */
  public request?: fhir.Reference|undefined;
  /**
   * The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
   */
  public ruleset?: fhir.Coding|undefined;
  /**
   * Knowledge of the original version can inform the processing of this instance so that information which is processable by the originating system may be generated.
   */
  public originalRuleset?: fhir.Coding|undefined;
  /**
   * The date when the enclosed suite of services were performed or completed.
   */
  public created?: fhir.FhirDateTime|undefined;
  /**
   * The Insurer who produced this adjudicated response.
   */
  public organization?: fhir.Reference|undefined;
  /**
   * The practitioner who is responsible for the services rendered to the patient.
   */
  public requestProvider?: fhir.Reference|undefined;
  /**
   * The organization which is responsible for the services rendered to the patient.
   */
  public requestOrganization?: fhir.Reference|undefined;
  /**
   * Transaction status: error, complete.
   */
  public outcome?: fhir.FhirCode<RemittanceOutcomeCodeType>|undefined;
  /**
   * A description of the status of the adjudication.
   */
  public disposition?: fhir.FhirString|undefined;
  /**
   * Party to be reimbursed: Subscriber, provider, other.
   */
  public payeeType?: fhir.Coding|undefined;
  /**
   * The first tier service adjudications for submitted services.
   */
  public item: fhir.ClaimResponseItem[];
  /**
   * The first tier service adjudications for payor added services.
   */
  public addItem: fhir.ClaimResponseAddItem[];
  /**
   * Mutually exclusive with Services Provided (Item).
   */
  public error: fhir.ClaimResponseError[];
  /**
   * This is a check value that the receiver calculates and returns.
   */
  public totalCost?: fhir.Quantity|undefined;
  /**
   * The amount of deductible applied which was not allocated to any particular service line.
   */
  public unallocDeductable?: fhir.Quantity|undefined;
  /**
   * Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
   */
  public totalBenefit?: fhir.Quantity|undefined;
  /**
   * Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
   */
  public paymentAdjustment?: fhir.Quantity|undefined;
  /**
   * Reason for the payment adjustment.
   */
  public paymentAdjustmentReason?: fhir.Coding|undefined;
  /**
   * Estimated payment data.
   */
  public paymentDate?: fhir.FhirDate|undefined;
  /**
   * Payable less any payment adjustment.
   */
  public paymentAmount?: fhir.Quantity|undefined;
  /**
   * Payment identifier.
   */
  public paymentRef?: fhir.Identifier|undefined;
  /**
   * Status of funds reservation (For provider, for Patient, None).
   */
  public reserved?: fhir.Coding|undefined;
  /**
   * The form to be used for printing the content.
   */
  public form?: fhir.Coding|undefined;
  /**
   * Note text.
   */
  public note: fhir.ClaimResponseNote[];
  /**
   * Health care programs and insurers are significant payors of health service costs.
   */
  public coverage: fhir.ClaimResponseCoverage[];
  /**
   * Default constructor for ClaimResponse - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ClaimResponseArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'ClaimResponse';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['request']) { this.request = new fhir.Reference(source.request); }
    if (source['ruleset']) { this.ruleset = new fhir.Coding(source.ruleset); }
    if (source['originalRuleset']) { this.originalRuleset = new fhir.Coding(source.originalRuleset); }
    if (source['created']) { this.created = new fhir.FhirDateTime({value: source.created}); }
    if (source['_created']) {
      if (this.created) { this.created.addExtendedProperties(source._created!); }
      else { this.created = new fhir.FhirDateTime(source._created as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['organization']) { this.organization = new fhir.Reference(source.organization); }
    if (source['requestProvider']) { this.requestProvider = new fhir.Reference(source.requestProvider); }
    if (source['requestOrganization']) { this.requestOrganization = new fhir.Reference(source.requestOrganization); }
    if (source['outcome']) { this.outcome = new fhir.FhirCode<RemittanceOutcomeCodeType>({value: source.outcome}); }
    if (source['_outcome']) {
      if (this.outcome) { this.outcome.addExtendedProperties(source._outcome!); }
      else { this.outcome = new fhir.FhirCode<RemittanceOutcomeCodeType>(source._outcome as Partial<fhir.FhirCode>); }
    }
    if (source['disposition']) { this.disposition = new fhir.FhirString({value: source.disposition}); }
    if (source['_disposition']) {
      if (this.disposition) { this.disposition.addExtendedProperties(source._disposition!); }
      else { this.disposition = new fhir.FhirString(source._disposition as Partial<fhir.FhirStringArgs>); }
    }
    if (source['payeeType']) { this.payeeType = new fhir.Coding(source.payeeType); }
    if (source['item']) { this.item = source.item.map((x) => new fhir.ClaimResponseItem(x)); }
    else { this.item = []; }
    if (source['addItem']) { this.addItem = source.addItem.map((x) => new fhir.ClaimResponseAddItem(x)); }
    else { this.addItem = []; }
    if (source['error']) { this.error = source.error.map((x) => new fhir.ClaimResponseError(x)); }
    else { this.error = []; }
    if (source['totalCost']) { this.totalCost = new fhir.Quantity(source.totalCost); }
    if (source['unallocDeductable']) { this.unallocDeductable = new fhir.Quantity(source.unallocDeductable); }
    if (source['totalBenefit']) { this.totalBenefit = new fhir.Quantity(source.totalBenefit); }
    if (source['paymentAdjustment']) { this.paymentAdjustment = new fhir.Quantity(source.paymentAdjustment); }
    if (source['paymentAdjustmentReason']) { this.paymentAdjustmentReason = new fhir.Coding(source.paymentAdjustmentReason); }
    if (source['paymentDate']) { this.paymentDate = new fhir.FhirDate({value: source.paymentDate}); }
    if (source['_paymentDate']) {
      if (this.paymentDate) { this.paymentDate.addExtendedProperties(source._paymentDate!); }
      else { this.paymentDate = new fhir.FhirDate(source._paymentDate as Partial<fhir.FhirDateArgs>); }
    }
    if (source['paymentAmount']) { this.paymentAmount = new fhir.Quantity(source.paymentAmount); }
    if (source['paymentRef']) { this.paymentRef = new fhir.Identifier(source.paymentRef); }
    if (source['reserved']) { this.reserved = new fhir.Coding(source.reserved); }
    if (source['form']) { this.form = new fhir.Coding(source.form); }
    if (source['note']) { this.note = source.note.map((x) => new fhir.ClaimResponseNote(x)); }
    else { this.note = []; }
    if (source['coverage']) { this.coverage = source.coverage.map((x) => new fhir.ClaimResponseCoverage(x)); }
    else { this.coverage = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'ClaimResponse' }
    iss.push(...this.vOA('identifier',exp));
    iss.push(...this.vOS('request',exp));
    iss.push(...this.vOS('ruleset',exp));
    iss.push(...this.vOS('originalRuleset',exp));
    iss.push(...this.vOS('created',exp));
    iss.push(...this.vOS('organization',exp));
    iss.push(...this.vOS('requestProvider',exp));
    iss.push(...this.vOS('requestOrganization',exp));
    iss.push(...this.vOSV('outcome',exp,'RemittanceOutcome',RemittanceOutcomeVsValidation,'r'));
    iss.push(...this.vOS('disposition',exp));
    iss.push(...this.vOS('payeeType',exp));
    iss.push(...this.vOA('item',exp));
    iss.push(...this.vOA('addItem',exp));
    iss.push(...this.vOA('error',exp));
    iss.push(...this.vOS('totalCost',exp));
    iss.push(...this.vOS('unallocDeductable',exp));
    iss.push(...this.vOS('totalBenefit',exp));
    iss.push(...this.vOS('paymentAdjustment',exp));
    iss.push(...this.vOS('paymentAdjustmentReason',exp));
    iss.push(...this.vOS('paymentDate',exp));
    iss.push(...this.vOS('paymentAmount',exp));
    iss.push(...this.vOS('paymentRef',exp));
    iss.push(...this.vOS('reserved',exp));
    iss.push(...this.vOS('form',exp));
    iss.push(...this.vOA('note',exp));
    iss.push(...this.vOA('coverage',exp));
    return iss;
  }
}
