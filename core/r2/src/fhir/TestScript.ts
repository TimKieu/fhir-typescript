// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: TestScript

import * as fhir from '../fhir.js';

// @ts-ignore
import { DefinedTypesCodes,  DefinedTypesCodeType } from '../fhirValueSets/DefinedTypesCodes.js';
// @ts-ignore
import { DefinedTypesVsValidation } from '../fhirValueSets/DefinedTypesVsValidation.js';
// @ts-ignore
import { ContentTypeCodes,  ContentTypeCodeType } from '../fhirValueSets/ContentTypeCodes.js';
// @ts-ignore
import { ContentTypeVsValidation } from '../fhirValueSets/ContentTypeVsValidation.js';
// @ts-ignore
import { AssertDirectionCodes,  AssertDirectionCodeType } from '../fhirValueSets/AssertDirectionCodes.js';
// @ts-ignore
import { AssertDirectionVsValidation } from '../fhirValueSets/AssertDirectionVsValidation.js';
// @ts-ignore
import { AssertOperatorCodes,  AssertOperatorCodeType } from '../fhirValueSets/AssertOperatorCodes.js';
// @ts-ignore
import { AssertOperatorVsValidation } from '../fhirValueSets/AssertOperatorVsValidation.js';
// @ts-ignore
import { AssertResponseCodeTypesCodes,  AssertResponseCodeTypesCodeType } from '../fhirValueSets/AssertResponseCodeTypesCodes.js';
// @ts-ignore
import { AssertResponseCodeTypesVsValidation } from '../fhirValueSets/AssertResponseCodeTypesVsValidation.js';
// @ts-ignore
import { ConformanceResourceStatusCodes,  ConformanceResourceStatusCodeType } from '../fhirValueSets/ConformanceResourceStatusCodes.js';
// @ts-ignore
import { ConformanceResourceStatusVsValidation } from '../fhirValueSets/ConformanceResourceStatusVsValidation.js';
/**
 * Valid arguments for the TestScriptContact type.
 */
export interface TestScriptContactArgs extends fhir.BackboneElementArgs {
  /**
   * The name of an individual to contact regarding the Test Script.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.contact.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Contact details for individual (if a name was provided) or the publisher.
   */
  telecom?: fhir.ContactPointArgs[]|undefined;
}

/**
 * Contacts to assist a user in finding and communicating with the publisher.
 */
export class TestScriptContact extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptContact';
  /**
   * The name of an individual to contact regarding the Test Script.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Contact details for individual (if a name was provided) or the publisher.
   */
  public telecom: fhir.ContactPoint[];
  /**
   * Default constructor for TestScriptContact - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptContactArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['telecom']) { this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x, options)); }
    else { this.telecom = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.contact' }
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOA('telecom',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptMetadataLink type.
 */
export interface TestScriptMetadataLinkArgs extends fhir.BackboneElementArgs {
  /**
   * URL to a particular requirement or feature within the FHIR specification.
   */
  url: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.link.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * Short description of the link.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.link.description
   */
  _description?:fhir.FhirElementArgs;
}

/**
 * A link to the FHIR specification that this test is covering.
 */
export class TestScriptMetadataLink extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptMetadataLink';
  /**
   * URL to a particular requirement or feature within the FHIR specification.
   */
  public url: fhir.FhirUri|null;
  /**
   * Short description of the link.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Default constructor for TestScriptMetadataLink - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptMetadataLinkArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['url'] !== undefined) { this.url = new fhir.FhirUri({value: source.url}, options); }
    else { this.url = null; }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.metadata.link' }
    iss.push(...this.vRS('url',exp));
    iss.push(...this.vOS('description',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptMetadataCapability type.
 */
export interface TestScriptMetadataCapabilityArgs extends fhir.BackboneElementArgs {
  /**
   * Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
   */
  required?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.capability.required
   */
  _required?:fhir.FhirElementArgs;
  /**
   * Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
   */
  validated?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.capability.validated
   */
  _validated?:fhir.FhirElementArgs;
  /**
   * Description of the capabilities that this test script is requiring the server to support.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.capability.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Which server these requirements apply to.
   */
  destination?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.capability.destination
   */
  _destination?:fhir.FhirElementArgs;
  /**
   * Links to the FHIR specification that describes this interaction and the resources involved in more detail.
   */
  link?: fhir.FhirUri[]|(string|null)[]|undefined;
  /**
   * Extended properties for primitive element: TestScript.metadata.capability.link
   */
  _link?:(fhir.FhirElementArgs|null)[];
  /**
   * Minimum conformance required of server for test script to execute successfully.   If server does not meet at a minimum the reference conformance definition, then all tests in this script are skipped.
   */
  conformance: fhir.ReferenceArgs|null;
}

/**
 * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
 */
export class TestScriptMetadataCapability extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptMetadataCapability';
  /**
   * Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
   */
  public required?: fhir.FhirBoolean|undefined;
  /**
   * Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
   */
  public validated?: fhir.FhirBoolean|undefined;
  /**
   * Description of the capabilities that this test script is requiring the server to support.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Which server these requirements apply to.
   */
  public destination?: fhir.FhirInteger|undefined;
  /**
   * Links to the FHIR specification that describes this interaction and the resources involved in more detail.
   */
  public link: fhir.FhirUri[];
  /**
   * Minimum conformance required of server for test script to execute successfully.   If server does not meet at a minimum the reference conformance definition, then all tests in this script are skipped.
   */
  public conformance: fhir.Reference|null;
  /**
   * Default constructor for TestScriptMetadataCapability - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptMetadataCapabilityArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['required'] !== undefined) { this.required = new fhir.FhirBoolean({value: source.required}, options); }
    if (source['_required']) {
      if (this.required) { this.required.addExtendedProperties(source._required!); }
      else { this.required = new fhir.FhirBoolean(source._required as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['validated'] !== undefined) { this.validated = new fhir.FhirBoolean({value: source.validated}, options); }
    if (source['_validated']) {
      if (this.validated) { this.validated.addExtendedProperties(source._validated!); }
      else { this.validated = new fhir.FhirBoolean(source._validated as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['destination'] !== undefined) { this.destination = new fhir.FhirInteger({value: source.destination}, options); }
    if (source['_destination']) {
      if (this.destination) { this.destination.addExtendedProperties(source._destination!); }
      else { this.destination = new fhir.FhirInteger(source._destination as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['link'] !== undefined) { this.link = source.link.map((x) => new fhir.FhirUri({value: x}, options)); }
    else { this.link = []; }
    if (source['_link']) {
      source._link.forEach((x,i) => {
        if (this.link.length >= i) { if (x) { this.link[i].addExtendedProperties(x); } }
        else { if (x) { this.link.push(new fhir.FhirUri(x as Partial<fhir.FhirUriArgs>)); } }
      });
    }
    if (source['conformance']) { this.conformance = new fhir.Reference(source.conformance, options); }
    else { this.conformance = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.metadata.capability' }
    iss.push(...this.vOS('required',exp));
    iss.push(...this.vOS('validated',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOS('destination',exp));
    iss.push(...this.vOA('link',exp));
    iss.push(...this.vRS('conformance',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptMetadata type.
 */
export interface TestScriptMetadataArgs extends fhir.BackboneElementArgs {
  /**
   * A link to the FHIR specification that this test is covering.
   */
  link?: fhir.TestScriptMetadataLinkArgs[]|undefined;
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  capability: fhir.TestScriptMetadataCapabilityArgs[]|null;
}

/**
 * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
 */
export class TestScriptMetadata extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptMetadata';
  /**
   * A link to the FHIR specification that this test is covering.
   */
  public link: fhir.TestScriptMetadataLink[];
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  public capability: fhir.TestScriptMetadataCapability[];
  /**
   * Default constructor for TestScriptMetadata - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptMetadataArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['link']) { this.link = source.link.map((x) => new fhir.TestScriptMetadataLink(x, options)); }
    else { this.link = []; }
    if (source['capability']) { this.capability = source.capability.map((x) => new fhir.TestScriptMetadataCapability(x, options)); }
    else { this.capability = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.metadata' }
    iss.push(...this.vOA('link',exp));
    iss.push(...this.vRA('capability',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptFixture type.
 */
export interface TestScriptFixtureArgs extends fhir.BackboneElementArgs {
  /**
   * Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
   */
  autocreate?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.fixture.autocreate
   */
  _autocreate?:fhir.FhirElementArgs;
  /**
   * Whether or not to implicitly delete the fixture during teardown If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
   */
  autodelete?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.fixture.autodelete
   */
  _autodelete?:fhir.FhirElementArgs;
  /**
   * Reference to the resource (containing the contents of the resource needed for operations).
   */
  resource?: fhir.ReferenceArgs|undefined;
}

/**
 * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
 */
export class TestScriptFixture extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptFixture';
  /**
   * Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
   */
  public autocreate?: fhir.FhirBoolean|undefined;
  /**
   * Whether or not to implicitly delete the fixture during teardown If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
   */
  public autodelete?: fhir.FhirBoolean|undefined;
  /**
   * Reference to the resource (containing the contents of the resource needed for operations).
   */
  public resource?: fhir.Reference|undefined;
  /**
   * Default constructor for TestScriptFixture - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptFixtureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['autocreate'] !== undefined) { this.autocreate = new fhir.FhirBoolean({value: source.autocreate}, options); }
    if (source['_autocreate']) {
      if (this.autocreate) { this.autocreate.addExtendedProperties(source._autocreate!); }
      else { this.autocreate = new fhir.FhirBoolean(source._autocreate as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['autodelete'] !== undefined) { this.autodelete = new fhir.FhirBoolean({value: source.autodelete}, options); }
    if (source['_autodelete']) {
      if (this.autodelete) { this.autodelete.addExtendedProperties(source._autodelete!); }
      else { this.autodelete = new fhir.FhirBoolean(source._autodelete as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['resource']) { this.resource = new fhir.Reference(source.resource, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.fixture' }
    iss.push(...this.vOS('autocreate',exp));
    iss.push(...this.vOS('autodelete',exp));
    iss.push(...this.vOS('resource',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptVariable type.
 */
export interface TestScriptVariableArgs extends fhir.BackboneElementArgs {
  /**
   * Descriptive name for this variable.
   */
  name: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.variable.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
   */
  headerField?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.variable.headerField
   */
  _headerField?:fhir.FhirElementArgs;
  /**
   * XPath or JSONPath against the fixture body.  When variables are defined, either headerField must be specified or path, but not both.
   */
  path?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.variable.path
   */
  _path?:fhir.FhirElementArgs;
  /**
   * Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
   */
  sourceId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.variable.sourceId
   */
  _sourceId?:fhir.FhirElementArgs;
}

/**
 * Variable is set based either on element value in response body or on header field value in the response headers.
 */
export class TestScriptVariable extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptVariable';
  /**
   * Descriptive name for this variable.
   */
  public name: fhir.FhirString|null;
  /**
   * Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
   */
  public headerField?: fhir.FhirString|undefined;
  /**
   * XPath or JSONPath against the fixture body.  When variables are defined, either headerField must be specified or path, but not both.
   */
  public path?: fhir.FhirString|undefined;
  /**
   * Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
   */
  public sourceId?: fhir.FhirId|undefined;
  /**
   * Default constructor for TestScriptVariable - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptVariableArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    else { this.name = null; }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['headerField'] !== undefined) { this.headerField = new fhir.FhirString({value: source.headerField}, options); }
    if (source['_headerField']) {
      if (this.headerField) { this.headerField.addExtendedProperties(source._headerField!); }
      else { this.headerField = new fhir.FhirString(source._headerField as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['path'] !== undefined) { this.path = new fhir.FhirString({value: source.path}, options); }
    if (source['_path']) {
      if (this.path) { this.path.addExtendedProperties(source._path!); }
      else { this.path = new fhir.FhirString(source._path as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['sourceId'] !== undefined) { this.sourceId = new fhir.FhirId({value: source.sourceId}, options); }
    if (source['_sourceId']) {
      if (this.sourceId) { this.sourceId.addExtendedProperties(source._sourceId!); }
      else { this.sourceId = new fhir.FhirId(source._sourceId as Partial<fhir.FhirIdArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.variable' }
    iss.push(...this.vRS('name',exp));
    iss.push(...this.vOS('headerField',exp));
    iss.push(...this.vOS('path',exp));
    iss.push(...this.vOS('sourceId',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptSetupActionOperationRequestHeader type.
 */
export interface TestScriptSetupActionOperationRequestHeaderArgs extends fhir.BackboneElementArgs {
  /**
   * The HTTP header field e.g. "Accept".
   */
  field: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.requestHeader.field
   */
  _field?:fhir.FhirElementArgs;
  /**
   * The value of the header e.g. "application/xml".
   */
  value: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.requestHeader.value
   */
  _value?:fhir.FhirElementArgs;
}

/**
 * Header elements would be used to set HTTP headers.
 */
export class TestScriptSetupActionOperationRequestHeader extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptSetupActionOperationRequestHeader';
  /**
   * The HTTP header field e.g. "Accept".
   */
  public field: fhir.FhirString|null;
  /**
   * The value of the header e.g. "application/xml".
   */
  public value: fhir.FhirString|null;
  /**
   * Default constructor for TestScriptSetupActionOperationRequestHeader - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptSetupActionOperationRequestHeaderArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['field'] !== undefined) { this.field = new fhir.FhirString({value: source.field}, options); }
    else { this.field = null; }
    if (source['_field']) {
      if (this.field) { this.field.addExtendedProperties(source._field!); }
      else { this.field = new fhir.FhirString(source._field as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['value'] !== undefined) { this.value = new fhir.FhirString({value: source.value}, options); }
    else { this.value = null; }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirString(source._value as Partial<fhir.FhirStringArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.setup.action.operation.requestHeader' }
    iss.push(...this.vRS('field',exp));
    iss.push(...this.vRS('value',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptSetupActionOperation type.
 */
export interface TestScriptSetupActionOperationArgs extends fhir.BackboneElementArgs {
  /**
   * Server interaction or operation type.
   */
  type?: fhir.CodingArgs|undefined;
  /**
   * The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
   */
  resource?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.resource
   */
  _resource?:fhir.FhirElementArgs;
  /**
   * The label would be used for tracking/logging purposes by test engines.
   */
  label?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.label
   */
  _label?:fhir.FhirElementArgs;
  /**
   * The description would be used by test engines for tracking and reporting purposes.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Accept' header.
   */
  accept?: fhir.FhirCode<ContentTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.accept
   */
  _accept?:fhir.FhirElementArgs;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
   */
  contentType?: fhir.FhirCode<ContentTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.contentType
   */
  _contentType?:fhir.FhirElementArgs;
  /**
   * Which server to perform the operation on.
   */
  destination?: fhir.FhirInteger|number|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.destination
   */
  _destination?:fhir.FhirElementArgs;
  /**
   * Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
   */
  encodeRequestUrl?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.encodeRequestUrl
   */
  _encodeRequestUrl?:fhir.FhirElementArgs;
  /**
   * Path plus parameters after [type].  Used to set parts of the request URL explicitly.
   */
  params?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.params
   */
  _params?:fhir.FhirElementArgs;
  /**
   * Header elements would be used to set HTTP headers.
   */
  requestHeader?: fhir.TestScriptSetupActionOperationRequestHeaderArgs[]|undefined;
  /**
   * The fixture id (maybe new) to map to the response.
   */
  responseId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.responseId
   */
  _responseId?:fhir.FhirElementArgs;
  /**
   * The id of the fixture used as the body of a PUT or POST request.
   */
  sourceId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.sourceId
   */
  _sourceId?:fhir.FhirElementArgs;
  /**
   * Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
   */
  targetId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.targetId
   */
  _targetId?:fhir.FhirElementArgs;
  /**
   * Complete request URL.
   */
  url?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.operation.url
   */
  _url?:fhir.FhirElementArgs;
}

/**
 * The operation to perform.
 */
export class TestScriptSetupActionOperation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptSetupActionOperation';
  /**
   * Server interaction or operation type.
   */
  public type?: fhir.Coding|undefined;
  /**
   * The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
   */
  public resource?: fhir.FhirCode|undefined;
  /**
   * The label would be used for tracking/logging purposes by test engines.
   */
  public label?: fhir.FhirString|undefined;
  /**
   * The description would be used by test engines for tracking and reporting purposes.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Accept' header.
   */
  public accept?: fhir.FhirCode<ContentTypeCodeType>|undefined;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
   */
  public contentType?: fhir.FhirCode<ContentTypeCodeType>|undefined;
  /**
   * Which server to perform the operation on.
   */
  public destination?: fhir.FhirInteger|undefined;
  /**
   * Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
   */
  public encodeRequestUrl?: fhir.FhirBoolean|undefined;
  /**
   * Path plus parameters after [type].  Used to set parts of the request URL explicitly.
   */
  public params?: fhir.FhirString|undefined;
  /**
   * Header elements would be used to set HTTP headers.
   */
  public requestHeader: fhir.TestScriptSetupActionOperationRequestHeader[];
  /**
   * The fixture id (maybe new) to map to the response.
   */
  public responseId?: fhir.FhirId|undefined;
  /**
   * The id of the fixture used as the body of a PUT or POST request.
   */
  public sourceId?: fhir.FhirId|undefined;
  /**
   * Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
   */
  public targetId?: fhir.FhirId|undefined;
  /**
   * Complete request URL.
   */
  public url?: fhir.FhirString|undefined;
  /**
   * Default constructor for TestScriptSetupActionOperation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptSetupActionOperationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.Coding(source.type, options); }
    if (source['resource'] !== undefined) { this.resource = new fhir.FhirCode({value: source.resource}, options); }
    if (source['_resource']) {
      if (this.resource) { this.resource.addExtendedProperties(source._resource!); }
      else { this.resource = new fhir.FhirCode(source._resource as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['label'] !== undefined) { this.label = new fhir.FhirString({value: source.label}, options); }
    if (source['_label']) {
      if (this.label) { this.label.addExtendedProperties(source._label!); }
      else { this.label = new fhir.FhirString(source._label as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['accept'] !== undefined) { this.accept = new fhir.FhirCode<ContentTypeCodeType>({value: source.accept}, options); }
    if (source['_accept']) {
      if (this.accept) { this.accept.addExtendedProperties(source._accept!); }
      else { this.accept = new fhir.FhirCode<ContentTypeCodeType>(source._accept as Partial<fhir.FhirCode>, options); }
    }
    if (source['contentType'] !== undefined) { this.contentType = new fhir.FhirCode<ContentTypeCodeType>({value: source.contentType}, options); }
    if (source['_contentType']) {
      if (this.contentType) { this.contentType.addExtendedProperties(source._contentType!); }
      else { this.contentType = new fhir.FhirCode<ContentTypeCodeType>(source._contentType as Partial<fhir.FhirCode>, options); }
    }
    if (source['destination'] !== undefined) { this.destination = new fhir.FhirInteger({value: source.destination}, options); }
    if (source['_destination']) {
      if (this.destination) { this.destination.addExtendedProperties(source._destination!); }
      else { this.destination = new fhir.FhirInteger(source._destination as Partial<fhir.FhirIntegerArgs>, options); }
    }
    if (source['encodeRequestUrl'] !== undefined) { this.encodeRequestUrl = new fhir.FhirBoolean({value: source.encodeRequestUrl}, options); }
    if (source['_encodeRequestUrl']) {
      if (this.encodeRequestUrl) { this.encodeRequestUrl.addExtendedProperties(source._encodeRequestUrl!); }
      else { this.encodeRequestUrl = new fhir.FhirBoolean(source._encodeRequestUrl as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['params'] !== undefined) { this.params = new fhir.FhirString({value: source.params}, options); }
    if (source['_params']) {
      if (this.params) { this.params.addExtendedProperties(source._params!); }
      else { this.params = new fhir.FhirString(source._params as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['requestHeader']) { this.requestHeader = source.requestHeader.map((x) => new fhir.TestScriptSetupActionOperationRequestHeader(x, options)); }
    else { this.requestHeader = []; }
    if (source['responseId'] !== undefined) { this.responseId = new fhir.FhirId({value: source.responseId}, options); }
    if (source['_responseId']) {
      if (this.responseId) { this.responseId.addExtendedProperties(source._responseId!); }
      else { this.responseId = new fhir.FhirId(source._responseId as Partial<fhir.FhirIdArgs>, options); }
    }
    if (source['sourceId'] !== undefined) { this.sourceId = new fhir.FhirId({value: source.sourceId}, options); }
    if (source['_sourceId']) {
      if (this.sourceId) { this.sourceId.addExtendedProperties(source._sourceId!); }
      else { this.sourceId = new fhir.FhirId(source._sourceId as Partial<fhir.FhirIdArgs>, options); }
    }
    if (source['targetId'] !== undefined) { this.targetId = new fhir.FhirId({value: source.targetId}, options); }
    if (source['_targetId']) {
      if (this.targetId) { this.targetId.addExtendedProperties(source._targetId!); }
      else { this.targetId = new fhir.FhirId(source._targetId as Partial<fhir.FhirIdArgs>, options); }
    }
    if (source['url'] !== undefined) { this.url = new fhir.FhirString({value: source.url}, options); }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirString(source._url as Partial<fhir.FhirStringArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.setup.action.operation' }
    iss.push(...this.vOS('type',exp));
    iss.push(...this.vOSV('resource',exp,'DefinedTypes',DefinedTypesVsValidation,'r'));
    iss.push(...this.vOS('label',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOSV('accept',exp,'ContentType',ContentTypeVsValidation,'r'));
    iss.push(...this.vOSV('contentType',exp,'ContentType',ContentTypeVsValidation,'r'));
    iss.push(...this.vOS('destination',exp));
    iss.push(...this.vOS('encodeRequestUrl',exp));
    iss.push(...this.vOS('params',exp));
    iss.push(...this.vOA('requestHeader',exp));
    iss.push(...this.vOS('responseId',exp));
    iss.push(...this.vOS('sourceId',exp));
    iss.push(...this.vOS('targetId',exp));
    iss.push(...this.vOS('url',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptSetupActionAssert type.
 */
export interface TestScriptSetupActionAssertArgs extends fhir.BackboneElementArgs {
  /**
   * The label would be used for tracking/logging purposes by test engines.
   */
  label?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.label
   */
  _label?:fhir.FhirElementArgs;
  /**
   * The description would be used by test engines for tracking and reporting purposes.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * The direction to use for the assertion.
   */
  direction?: fhir.FhirCode<AssertDirectionCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.direction
   */
  _direction?:fhir.FhirElementArgs;
  /**
   * Id of fixture used to compare the "sourceId/path" evaluations to.
   */
  compareToSourceId?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.compareToSourceId
   */
  _compareToSourceId?:fhir.FhirElementArgs;
  /**
   * XPath or JSONPath expression against fixture used to compare the "sourceId/path" evaluations to.
   */
  compareToSourcePath?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.compareToSourcePath
   */
  _compareToSourcePath?:fhir.FhirElementArgs;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
   */
  contentType?: fhir.FhirCode<ContentTypeCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.contentType
   */
  _contentType?:fhir.FhirElementArgs;
  /**
   * The HTTP header field name e.g. 'Location'.
   */
  headerField?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.headerField
   */
  _headerField?:fhir.FhirElementArgs;
  /**
   * The ID of a fixture.  Asserts that the response contains at a minimumId the fixture specified by minimumId.
   */
  minimumId?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.minimumId
   */
  _minimumId?:fhir.FhirElementArgs;
  /**
   * Whether or not the test execution performs validation on the bundle navigation links.
   */
  navigationLinks?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.navigationLinks
   */
  _navigationLinks?:fhir.FhirElementArgs;
  /**
   * The operator type.
   */
  operator?: fhir.FhirCode<AssertOperatorCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.operator
   */
  _operator?:fhir.FhirElementArgs;
  /**
   * The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
   */
  path?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.path
   */
  _path?:fhir.FhirElementArgs;
  /**
   * The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
   */
  resource?: fhir.FhirCode|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.resource
   */
  _resource?:fhir.FhirElementArgs;
  /**
   * okay | created | noContent | notModified | bad | forbidden | notFound | methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
   */
  response?: fhir.FhirCode<AssertResponseCodeTypesCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.response
   */
  _response?:fhir.FhirElementArgs;
  /**
   * The value of the HTTP response code to be tested.
   */
  responseCode?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.responseCode
   */
  _responseCode?:fhir.FhirElementArgs;
  /**
   * Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
   */
  sourceId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.sourceId
   */
  _sourceId?:fhir.FhirElementArgs;
  /**
   * The ID of the Profile to validate against.
   */
  validateProfileId?: fhir.FhirId|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.validateProfileId
   */
  _validateProfileId?:fhir.FhirElementArgs;
  /**
   * The value to compare to.
   */
  value?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.value
   */
  _value?:fhir.FhirElementArgs;
  /**
   * Whether or not the test execution will produce a warning only on error for this assert.
   */
  warningOnly?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.setup.action.assert.warningOnly
   */
  _warningOnly?:fhir.FhirElementArgs;
}

/**
 * Evaluates the results of previous operations to determine if the server under test behaves appropriately.
 */
export class TestScriptSetupActionAssert extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptSetupActionAssert';
  /**
   * The label would be used for tracking/logging purposes by test engines.
   */
  public label?: fhir.FhirString|undefined;
  /**
   * The description would be used by test engines for tracking and reporting purposes.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * The direction to use for the assertion.
   */
  public direction?: fhir.FhirCode<AssertDirectionCodeType>|undefined;
  /**
   * Id of fixture used to compare the "sourceId/path" evaluations to.
   */
  public compareToSourceId?: fhir.FhirString|undefined;
  /**
   * XPath or JSONPath expression against fixture used to compare the "sourceId/path" evaluations to.
   */
  public compareToSourcePath?: fhir.FhirString|undefined;
  /**
   * The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
   */
  public contentType?: fhir.FhirCode<ContentTypeCodeType>|undefined;
  /**
   * The HTTP header field name e.g. 'Location'.
   */
  public headerField?: fhir.FhirString|undefined;
  /**
   * The ID of a fixture.  Asserts that the response contains at a minimumId the fixture specified by minimumId.
   */
  public minimumId?: fhir.FhirString|undefined;
  /**
   * Whether or not the test execution performs validation on the bundle navigation links.
   */
  public navigationLinks?: fhir.FhirBoolean|undefined;
  /**
   * The operator type.
   */
  public operator?: fhir.FhirCode<AssertOperatorCodeType>|undefined;
  /**
   * The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
   */
  public path?: fhir.FhirString|undefined;
  /**
   * The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
   */
  public resource?: fhir.FhirCode|undefined;
  /**
   * okay | created | noContent | notModified | bad | forbidden | notFound | methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
   */
  public response?: fhir.FhirCode<AssertResponseCodeTypesCodeType>|undefined;
  /**
   * The value of the HTTP response code to be tested.
   */
  public responseCode?: fhir.FhirString|undefined;
  /**
   * Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
   */
  public sourceId?: fhir.FhirId|undefined;
  /**
   * The ID of the Profile to validate against.
   */
  public validateProfileId?: fhir.FhirId|undefined;
  /**
   * The value to compare to.
   */
  public value?: fhir.FhirString|undefined;
  /**
   * Whether or not the test execution will produce a warning only on error for this assert.
   */
  public warningOnly?: fhir.FhirBoolean|undefined;
  /**
   * Default constructor for TestScriptSetupActionAssert - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptSetupActionAssertArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['label'] !== undefined) { this.label = new fhir.FhirString({value: source.label}, options); }
    if (source['_label']) {
      if (this.label) { this.label.addExtendedProperties(source._label!); }
      else { this.label = new fhir.FhirString(source._label as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['direction'] !== undefined) { this.direction = new fhir.FhirCode<AssertDirectionCodeType>({value: source.direction}, options); }
    if (source['_direction']) {
      if (this.direction) { this.direction.addExtendedProperties(source._direction!); }
      else { this.direction = new fhir.FhirCode<AssertDirectionCodeType>(source._direction as Partial<fhir.FhirCode>, options); }
    }
    if (source['compareToSourceId'] !== undefined) { this.compareToSourceId = new fhir.FhirString({value: source.compareToSourceId}, options); }
    if (source['_compareToSourceId']) {
      if (this.compareToSourceId) { this.compareToSourceId.addExtendedProperties(source._compareToSourceId!); }
      else { this.compareToSourceId = new fhir.FhirString(source._compareToSourceId as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['compareToSourcePath'] !== undefined) { this.compareToSourcePath = new fhir.FhirString({value: source.compareToSourcePath}, options); }
    if (source['_compareToSourcePath']) {
      if (this.compareToSourcePath) { this.compareToSourcePath.addExtendedProperties(source._compareToSourcePath!); }
      else { this.compareToSourcePath = new fhir.FhirString(source._compareToSourcePath as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['contentType'] !== undefined) { this.contentType = new fhir.FhirCode<ContentTypeCodeType>({value: source.contentType}, options); }
    if (source['_contentType']) {
      if (this.contentType) { this.contentType.addExtendedProperties(source._contentType!); }
      else { this.contentType = new fhir.FhirCode<ContentTypeCodeType>(source._contentType as Partial<fhir.FhirCode>, options); }
    }
    if (source['headerField'] !== undefined) { this.headerField = new fhir.FhirString({value: source.headerField}, options); }
    if (source['_headerField']) {
      if (this.headerField) { this.headerField.addExtendedProperties(source._headerField!); }
      else { this.headerField = new fhir.FhirString(source._headerField as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['minimumId'] !== undefined) { this.minimumId = new fhir.FhirString({value: source.minimumId}, options); }
    if (source['_minimumId']) {
      if (this.minimumId) { this.minimumId.addExtendedProperties(source._minimumId!); }
      else { this.minimumId = new fhir.FhirString(source._minimumId as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['navigationLinks'] !== undefined) { this.navigationLinks = new fhir.FhirBoolean({value: source.navigationLinks}, options); }
    if (source['_navigationLinks']) {
      if (this.navigationLinks) { this.navigationLinks.addExtendedProperties(source._navigationLinks!); }
      else { this.navigationLinks = new fhir.FhirBoolean(source._navigationLinks as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['operator'] !== undefined) { this.operator = new fhir.FhirCode<AssertOperatorCodeType>({value: source.operator}, options); }
    if (source['_operator']) {
      if (this.operator) { this.operator.addExtendedProperties(source._operator!); }
      else { this.operator = new fhir.FhirCode<AssertOperatorCodeType>(source._operator as Partial<fhir.FhirCode>, options); }
    }
    if (source['path'] !== undefined) { this.path = new fhir.FhirString({value: source.path}, options); }
    if (source['_path']) {
      if (this.path) { this.path.addExtendedProperties(source._path!); }
      else { this.path = new fhir.FhirString(source._path as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['resource'] !== undefined) { this.resource = new fhir.FhirCode({value: source.resource}, options); }
    if (source['_resource']) {
      if (this.resource) { this.resource.addExtendedProperties(source._resource!); }
      else { this.resource = new fhir.FhirCode(source._resource as Partial<fhir.FhirCodeArgs>, options); }
    }
    if (source['response'] !== undefined) { this.response = new fhir.FhirCode<AssertResponseCodeTypesCodeType>({value: source.response}, options); }
    if (source['_response']) {
      if (this.response) { this.response.addExtendedProperties(source._response!); }
      else { this.response = new fhir.FhirCode<AssertResponseCodeTypesCodeType>(source._response as Partial<fhir.FhirCode>, options); }
    }
    if (source['responseCode'] !== undefined) { this.responseCode = new fhir.FhirString({value: source.responseCode}, options); }
    if (source['_responseCode']) {
      if (this.responseCode) { this.responseCode.addExtendedProperties(source._responseCode!); }
      else { this.responseCode = new fhir.FhirString(source._responseCode as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['sourceId'] !== undefined) { this.sourceId = new fhir.FhirId({value: source.sourceId}, options); }
    if (source['_sourceId']) {
      if (this.sourceId) { this.sourceId.addExtendedProperties(source._sourceId!); }
      else { this.sourceId = new fhir.FhirId(source._sourceId as Partial<fhir.FhirIdArgs>, options); }
    }
    if (source['validateProfileId'] !== undefined) { this.validateProfileId = new fhir.FhirId({value: source.validateProfileId}, options); }
    if (source['_validateProfileId']) {
      if (this.validateProfileId) { this.validateProfileId.addExtendedProperties(source._validateProfileId!); }
      else { this.validateProfileId = new fhir.FhirId(source._validateProfileId as Partial<fhir.FhirIdArgs>, options); }
    }
    if (source['value'] !== undefined) { this.value = new fhir.FhirString({value: source.value}, options); }
    if (source['_value']) {
      if (this.value) { this.value.addExtendedProperties(source._value!); }
      else { this.value = new fhir.FhirString(source._value as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['warningOnly'] !== undefined) { this.warningOnly = new fhir.FhirBoolean({value: source.warningOnly}, options); }
    if (source['_warningOnly']) {
      if (this.warningOnly) { this.warningOnly.addExtendedProperties(source._warningOnly!); }
      else { this.warningOnly = new fhir.FhirBoolean(source._warningOnly as Partial<fhir.FhirBooleanArgs>, options); }
    }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.setup.action.assert' }
    iss.push(...this.vOS('label',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOSV('direction',exp,'AssertDirection',AssertDirectionVsValidation,'r'));
    iss.push(...this.vOS('compareToSourceId',exp));
    iss.push(...this.vOS('compareToSourcePath',exp));
    iss.push(...this.vOSV('contentType',exp,'ContentType',ContentTypeVsValidation,'r'));
    iss.push(...this.vOS('headerField',exp));
    iss.push(...this.vOS('minimumId',exp));
    iss.push(...this.vOS('navigationLinks',exp));
    iss.push(...this.vOSV('operator',exp,'AssertOperator',AssertOperatorVsValidation,'r'));
    iss.push(...this.vOS('path',exp));
    iss.push(...this.vOSV('resource',exp,'DefinedTypes',DefinedTypesVsValidation,'r'));
    iss.push(...this.vOSV('response',exp,'AssertResponseCodeTypes',AssertResponseCodeTypesVsValidation,'r'));
    iss.push(...this.vOS('responseCode',exp));
    iss.push(...this.vOS('sourceId',exp));
    iss.push(...this.vOS('validateProfileId',exp));
    iss.push(...this.vOS('value',exp));
    iss.push(...this.vOS('warningOnly',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptSetupAction type.
 */
export interface TestScriptSetupActionArgs extends fhir.BackboneElementArgs {
  /**
   * The operation to perform.
   */
  operation?: fhir.TestScriptSetupActionOperationArgs|undefined;
  /**
   * Evaluates the results of previous operations to determine if the server under test behaves appropriately.
   */
  assert?: fhir.TestScriptSetupActionAssertArgs|undefined;
}

/**
 * Action would contain either an operation or an assertion.
 */
export class TestScriptSetupAction extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptSetupAction';
  /**
   * The operation to perform.
   */
  public operation?: fhir.TestScriptSetupActionOperation|undefined;
  /**
   * Evaluates the results of previous operations to determine if the server under test behaves appropriately.
   */
  public assert?: fhir.TestScriptSetupActionAssert|undefined;
  /**
   * Default constructor for TestScriptSetupAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptSetupActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestScriptSetupActionOperation(source.operation, options); }
    if (source['assert']) { this.assert = new fhir.TestScriptSetupActionAssert(source.assert, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.setup.action' }
    iss.push(...this.vOS('operation',exp));
    iss.push(...this.vOS('assert',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptSetup type.
 */
export interface TestScriptSetupArgs extends fhir.BackboneElementArgs {
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  metadata?: fhir.TestScriptMetadataArgs|undefined;
  /**
   * Action would contain either an operation or an assertion.
   */
  action: fhir.TestScriptSetupActionArgs[]|null;
}

/**
 * A series of required setup operations before tests are executed.
 */
export class TestScriptSetup extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptSetup';
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  public metadata?: fhir.TestScriptMetadata|undefined;
  /**
   * Action would contain either an operation or an assertion.
   */
  public action: fhir.TestScriptSetupAction[];
  /**
   * Default constructor for TestScriptSetup - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptSetupArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['metadata']) { this.metadata = new fhir.TestScriptMetadata(source.metadata, options); }
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestScriptSetupAction(x, options)); }
    else { this.action = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.setup' }
    iss.push(...this.vOS('metadata',exp));
    iss.push(...this.vRA('action',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptTestAction type.
 */
export interface TestScriptTestActionArgs extends fhir.BackboneElementArgs {
  /**
   * An operation would involve a REST request to a server.
   */
  operation?: fhir.TestScriptSetupActionOperationArgs|undefined;
  /**
   * Evaluates the results of previous operations to determine if the server under test behaves appropriately.
   */
  assert?: fhir.TestScriptSetupActionAssertArgs|undefined;
}

/**
 * Action would contain either an operation or an assertion.
 */
export class TestScriptTestAction extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptTestAction';
  /**
   * An operation would involve a REST request to a server.
   */
  public operation?: fhir.TestScriptSetupActionOperation|undefined;
  /**
   * Evaluates the results of previous operations to determine if the server under test behaves appropriately.
   */
  public assert?: fhir.TestScriptSetupActionAssert|undefined;
  /**
   * Default constructor for TestScriptTestAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptTestActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestScriptSetupActionOperation(source.operation, options); }
    if (source['assert']) { this.assert = new fhir.TestScriptSetupActionAssert(source.assert, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.test.action' }
    iss.push(...this.vOS('operation',exp));
    iss.push(...this.vOS('assert',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptTest type.
 */
export interface TestScriptTestArgs extends fhir.BackboneElementArgs {
  /**
   * The name of this test used for tracking/logging purposes by test engines.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.test.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * A short description of the test used by test engines for tracking and reporting purposes.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.test.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  metadata?: fhir.TestScriptMetadataArgs|undefined;
  /**
   * Action would contain either an operation or an assertion.
   */
  action: fhir.TestScriptTestActionArgs[]|null;
}

/**
 * A test in this script.
 */
export class TestScriptTest extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptTest';
  /**
   * The name of this test used for tracking/logging purposes by test engines.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * A short description of the test used by test engines for tracking and reporting purposes.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
   */
  public metadata?: fhir.TestScriptMetadata|undefined;
  /**
   * Action would contain either an operation or an assertion.
   */
  public action: fhir.TestScriptTestAction[];
  /**
   * Default constructor for TestScriptTest - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptTestArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['metadata']) { this.metadata = new fhir.TestScriptMetadata(source.metadata, options); }
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestScriptTestAction(x, options)); }
    else { this.action = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.test' }
    iss.push(...this.vOS('name',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOS('metadata',exp));
    iss.push(...this.vRA('action',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptTeardownAction type.
 */
export interface TestScriptTeardownActionArgs extends fhir.BackboneElementArgs {
  /**
   * An operation would involve a REST request to a server.
   */
  operation?: fhir.TestScriptSetupActionOperationArgs|undefined;
}

/**
 * The teardown action will only contain an operation.
 */
export class TestScriptTeardownAction extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptTeardownAction';
  /**
   * An operation would involve a REST request to a server.
   */
  public operation?: fhir.TestScriptSetupActionOperation|undefined;
  /**
   * Default constructor for TestScriptTeardownAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptTeardownActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestScriptSetupActionOperation(source.operation, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.teardown.action' }
    iss.push(...this.vOS('operation',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScriptTeardown type.
 */
export interface TestScriptTeardownArgs extends fhir.BackboneElementArgs {
  /**
   * The teardown action will only contain an operation.
   */
  action: fhir.TestScriptTeardownActionArgs[]|null;
}

/**
 * A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
 */
export class TestScriptTeardown extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScriptTeardown';
  /**
   * The teardown action will only contain an operation.
   */
  public action: fhir.TestScriptTeardownAction[];
  /**
   * Default constructor for TestScriptTeardown - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptTeardownArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestScriptTeardownAction(x, options)); }
    else { this.action = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript.teardown' }
    iss.push(...this.vRA('action',exp));
    return iss;
  }
}
/**
 * Valid arguments for the TestScript type.
 */
export interface TestScriptArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "TestScript"|undefined;
  /**
   * An absolute URL that is used to identify this Test Script. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Test Script is (or will be) published.
   */
  url: fhir.FhirUri|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.url
   */
  _url?:fhir.FhirElementArgs;
  /**
   * There may be multiple resource versions of the TestScript that have this same identifier. The resource version id will change for technical reasons, whereas the stated version number needs to be under the author's control.
   */
  version?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.version
   */
  _version?:fhir.FhirElementArgs;
  /**
   * A free text natural language name identifying the TestScript.
   */
  name: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.name
   */
  _name?:fhir.FhirElementArgs;
  /**
   * Allows filtering of TestScripts that are appropriate for use vs. not.
   */
  status: fhir.FhirCode<ConformanceResourceStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * Identifier for the TestScript assigned for external purposes outside the context of FHIR.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * Allows filtering of TestScripts that are appropriate for use vs. not.
   */
  experimental?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.experimental
   */
  _experimental?:fhir.FhirElementArgs;
  /**
   * Helps establish the "authority/credibility" of the Test Script.  May also allow for contact.
   */
  publisher?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.publisher
   */
  _publisher?:fhir.FhirElementArgs;
  /**
   * Contacts to assist a user in finding and communicating with the publisher.
   */
  contact?: fhir.TestScriptContactArgs[]|undefined;
  /**
   * The date this version of the test tcript was published. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the test cases change.
   */
  date?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.date
   */
  _date?:fhir.FhirElementArgs;
  /**
   * A free text natural language description of the TestScript and its use.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.description
   */
  _description?:fhir.FhirElementArgs;
  /**
   * Assist in searching for appropriate content.
   */
  useContext?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Explains why this Test Script is needed and why it's been constrained as it has.
   */
  requirements?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.requirements
   */
  _requirements?:fhir.FhirElementArgs;
  /**
   * A copyright statement relating to the Test Script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
   */
  copyright?: fhir.FhirString|string|undefined;
  /**
   * Extended properties for primitive element: TestScript.copyright
   */
  _copyright?:fhir.FhirElementArgs;
  /**
   * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
   */
  metadata?: fhir.TestScriptMetadataArgs|undefined;
  /**
   * If the tests apply to more than one FHIR server (e.g. cross-server interoperability tests) then multiserver=true. Defaults to false if value is unspecified.
   */
  multiserver?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: TestScript.multiserver
   */
  _multiserver?:fhir.FhirElementArgs;
  /**
   * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
   */
  fixture?: fhir.TestScriptFixtureArgs[]|undefined;
  /**
   * Reference to the profile to be used for validation.
   */
  profile?: fhir.ReferenceArgs[]|undefined;
  /**
   * Variable is set based either on element value in response body or on header field value in the response headers.
   */
  variable?: fhir.TestScriptVariableArgs[]|undefined;
  /**
   * A series of required setup operations before tests are executed.
   */
  setup?: fhir.TestScriptSetupArgs|undefined;
  /**
   * A test in this script.
   */
  test?: fhir.TestScriptTestArgs[]|undefined;
  /**
   * A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
   */
  teardown?: fhir.TestScriptTeardownArgs|undefined;
}

/**
 * TestScript is a resource that specifies a suite of tests against a FHIR server implementation to determine compliance against the FHIR specification.
 */
export class TestScript extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'TestScript';
  /**
   * Resource Type Name
   */
  public override resourceType: "TestScript";
  /**
   * An absolute URL that is used to identify this Test Script. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Test Script is (or will be) published.
   */
  public url: fhir.FhirUri|null;
  /**
   * There may be multiple resource versions of the TestScript that have this same identifier. The resource version id will change for technical reasons, whereas the stated version number needs to be under the author's control.
   */
  public version?: fhir.FhirString|undefined;
  /**
   * A free text natural language name identifying the TestScript.
   */
  public name: fhir.FhirString|null;
  /**
   * Allows filtering of TestScripts that are appropriate for use vs. not.
   */
  public status: fhir.FhirCode<ConformanceResourceStatusCodeType>|null;
  /**
   * Identifier for the TestScript assigned for external purposes outside the context of FHIR.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Allows filtering of TestScripts that are appropriate for use vs. not.
   */
  public experimental?: fhir.FhirBoolean|undefined;
  /**
   * Helps establish the "authority/credibility" of the Test Script.  May also allow for contact.
   */
  public publisher?: fhir.FhirString|undefined;
  /**
   * Contacts to assist a user in finding and communicating with the publisher.
   */
  public contact: fhir.TestScriptContact[];
  /**
   * The date this version of the test tcript was published. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the test cases change.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * A free text natural language description of the TestScript and its use.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Assist in searching for appropriate content.
   */
  public useContext: fhir.CodeableConcept[];
  /**
   * Explains why this Test Script is needed and why it's been constrained as it has.
   */
  public requirements?: fhir.FhirString|undefined;
  /**
   * A copyright statement relating to the Test Script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
   */
  public copyright?: fhir.FhirString|undefined;
  /**
   * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
   */
  public metadata?: fhir.TestScriptMetadata|undefined;
  /**
   * If the tests apply to more than one FHIR server (e.g. cross-server interoperability tests) then multiserver=true. Defaults to false if value is unspecified.
   */
  public multiserver?: fhir.FhirBoolean|undefined;
  /**
   * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
   */
  public fixture: fhir.TestScriptFixture[];
  /**
   * Reference to the profile to be used for validation.
   */
  public profile: fhir.Reference[];
  /**
   * Variable is set based either on element value in response body or on header field value in the response headers.
   */
  public variable: fhir.TestScriptVariable[];
  /**
   * A series of required setup operations before tests are executed.
   */
  public setup?: fhir.TestScriptSetup|undefined;
  /**
   * A test in this script.
   */
  public test: fhir.TestScriptTest[];
  /**
   * A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
   */
  public teardown?: fhir.TestScriptTeardown|undefined;
  /**
   * Default constructor for TestScript - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestScriptArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'TestScript';
    if (source['url'] !== undefined) { this.url = new fhir.FhirUri({value: source.url}, options); }
    else { this.url = null; }
    if (source['_url']) {
      if (this.url) { this.url.addExtendedProperties(source._url!); }
      else { this.url = new fhir.FhirUri(source._url as Partial<fhir.FhirUriArgs>, options); }
    }
    if (source['version'] !== undefined) { this.version = new fhir.FhirString({value: source.version}, options); }
    if (source['_version']) {
      if (this.version) { this.version.addExtendedProperties(source._version!); }
      else { this.version = new fhir.FhirString(source._version as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['name'] !== undefined) { this.name = new fhir.FhirString({value: source.name}, options); }
    else { this.name = null; }
    if (source['_name']) {
      if (this.name) { this.name.addExtendedProperties(source._name!); }
      else { this.name = new fhir.FhirString(source._name as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['status'] !== undefined) { this.status = new fhir.FhirCode<ConformanceResourceStatusCodeType>({value: source.status}, options); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<ConformanceResourceStatusCodeType>(source._status as Partial<fhir.FhirCode>, options); }
    }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier, options); }
    if (source['experimental'] !== undefined) { this.experimental = new fhir.FhirBoolean({value: source.experimental}, options); }
    if (source['_experimental']) {
      if (this.experimental) { this.experimental.addExtendedProperties(source._experimental!); }
      else { this.experimental = new fhir.FhirBoolean(source._experimental as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['publisher'] !== undefined) { this.publisher = new fhir.FhirString({value: source.publisher}, options); }
    if (source['_publisher']) {
      if (this.publisher) { this.publisher.addExtendedProperties(source._publisher!); }
      else { this.publisher = new fhir.FhirString(source._publisher as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['contact']) { this.contact = source.contact.map((x) => new fhir.TestScriptContact(x, options)); }
    else { this.contact = []; }
    if (source['date'] !== undefined) { this.date = new fhir.FhirDateTime({value: source.date}, options); }
    if (source['_date']) {
      if (this.date) { this.date.addExtendedProperties(source._date!); }
      else { this.date = new fhir.FhirDateTime(source._date as Partial<fhir.FhirDateTimeArgs>, options); }
    }
    if (source['description'] !== undefined) { this.description = new fhir.FhirString({value: source.description}, options); }
    if (source['_description']) {
      if (this.description) { this.description.addExtendedProperties(source._description!); }
      else { this.description = new fhir.FhirString(source._description as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['useContext']) { this.useContext = source.useContext.map((x) => new fhir.CodeableConcept(x, options)); }
    else { this.useContext = []; }
    if (source['requirements'] !== undefined) { this.requirements = new fhir.FhirString({value: source.requirements}, options); }
    if (source['_requirements']) {
      if (this.requirements) { this.requirements.addExtendedProperties(source._requirements!); }
      else { this.requirements = new fhir.FhirString(source._requirements as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['copyright'] !== undefined) { this.copyright = new fhir.FhirString({value: source.copyright}, options); }
    if (source['_copyright']) {
      if (this.copyright) { this.copyright.addExtendedProperties(source._copyright!); }
      else { this.copyright = new fhir.FhirString(source._copyright as Partial<fhir.FhirStringArgs>, options); }
    }
    if (source['metadata']) { this.metadata = new fhir.TestScriptMetadata(source.metadata, options); }
    if (source['multiserver'] !== undefined) { this.multiserver = new fhir.FhirBoolean({value: source.multiserver}, options); }
    if (source['_multiserver']) {
      if (this.multiserver) { this.multiserver.addExtendedProperties(source._multiserver!); }
      else { this.multiserver = new fhir.FhirBoolean(source._multiserver as Partial<fhir.FhirBooleanArgs>, options); }
    }
    if (source['fixture']) { this.fixture = source.fixture.map((x) => new fhir.TestScriptFixture(x, options)); }
    else { this.fixture = []; }
    if (source['profile']) { this.profile = source.profile.map((x) => new fhir.Reference(x, options)); }
    else { this.profile = []; }
    if (source['variable']) { this.variable = source.variable.map((x) => new fhir.TestScriptVariable(x, options)); }
    else { this.variable = []; }
    if (source['setup']) { this.setup = new fhir.TestScriptSetup(source.setup, options); }
    if (source['test']) { this.test = source.test.map((x) => new fhir.TestScriptTest(x, options)); }
    else { this.test = []; }
    if (source['teardown']) { this.teardown = new fhir.TestScriptTeardown(source.teardown, options); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'TestScript' }
    iss.push(...this.vRS('url',exp));
    iss.push(...this.vOS('version',exp));
    iss.push(...this.vRS('name',exp));
    iss.push(...this.vRSV('status',exp,'ConformanceResourceStatus',ConformanceResourceStatusVsValidation,'r'));
    iss.push(...this.vOS('identifier',exp));
    iss.push(...this.vOS('experimental',exp));
    iss.push(...this.vOS('publisher',exp));
    iss.push(...this.vOA('contact',exp));
    iss.push(...this.vOS('date',exp));
    iss.push(...this.vOS('description',exp));
    iss.push(...this.vOA('useContext',exp));
    iss.push(...this.vOS('requirements',exp));
    iss.push(...this.vOS('copyright',exp));
    iss.push(...this.vOS('metadata',exp));
    iss.push(...this.vOS('multiserver',exp));
    iss.push(...this.vOA('fixture',exp));
    iss.push(...this.vOA('profile',exp));
    iss.push(...this.vOA('variable',exp));
    iss.push(...this.vOS('setup',exp));
    iss.push(...this.vOA('test',exp));
    iss.push(...this.vOS('teardown',exp));
    return iss;
  }
}
